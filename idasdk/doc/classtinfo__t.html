<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>IDA SDK: tinfo_t Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">IDA SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="files.html"><span>Header&#160;Files</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classtinfo__t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tinfo_t Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Primary mechanism for managing type information. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac199b2fcbce50a1328e732ef3cfcdc08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac199b2fcbce50a1328e732ef3cfcdc08"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#ac199b2fcbce50a1328e732ef3cfcdc08">tinfo_t</a> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> decl_type=<a class="el" href="group__tf__unk.html#ga9c2f460ca1ce121f26cf35a2fd56435c">BT_UNK</a>)</td></tr>
<tr class="memdesc:ac199b2fcbce50a1328e732ef3cfcdc08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor - can only be used to initialize simple types! <br /></td></tr>
<tr class="separator:ac199b2fcbce50a1328e732ef3cfcdc08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4a30ae71d54304d7cbe80d3384b73f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b4a30ae71d54304d7cbe80d3384b73f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a3b4a30ae71d54304d7cbe80d3384b73f">tinfo_t</a> (const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;r)</td></tr>
<tr class="memdesc:a3b4a30ae71d54304d7cbe80d3384b73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a3b4a30ae71d54304d7cbe80d3384b73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d468cf7ca30f4496add128133de334"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96d468cf7ca30f4496add128133de334"></a>
<a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a96d468cf7ca30f4496add128133de334">operator=</a> (const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;r)</td></tr>
<tr class="memdesc:a96d468cf7ca30f4496add128133de334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy contents of given tinfo into this one. <br /></td></tr>
<tr class="separator:a96d468cf7ca30f4496add128133de334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e99c7d5c6d03b6e4c9eba7c5b4f490"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80e99c7d5c6d03b6e4c9eba7c5b4f490"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a80e99c7d5c6d03b6e4c9eba7c5b4f490">~tinfo_t</a> (void)</td></tr>
<tr class="memdesc:a80e99c7d5c6d03b6e4c9eba7c5b4f490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a80e99c7d5c6d03b6e4c9eba7c5b4f490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2870999077263051967bb654149e092f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2870999077263051967bb654149e092f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a2870999077263051967bb654149e092f">clear</a> (void)</td></tr>
<tr class="memdesc:a2870999077263051967bb654149e092f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear contents of this tinfo, and remove from the type system. <br /></td></tr>
<tr class="separator:a2870999077263051967bb654149e092f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4e021d8c7e2ecea89b869d8a842576"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd4e021d8c7e2ecea89b869d8a842576"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#abd4e021d8c7e2ecea89b869d8a842576">swap</a> (<a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;r)</td></tr>
<tr class="memdesc:abd4e021d8c7e2ecea89b869d8a842576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign this = r and r = this. <br /></td></tr>
<tr class="separator:abd4e021d8c7e2ecea89b869d8a842576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d412272832b545ffdf4019e736ff7b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a8d412272832b545ffdf4019e736ff7b7">get_named_type</a> (const <a class="el" href="structtil__t.html">til_t</a> *til, const char *name, <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> decl_type=<a class="el" href="group__tf__shortcuts.html#ga64e49eed2f4e754689e7bcc7f6efdd74">BTF_TYPEDEF</a>, bool resolve=true, bool try_ordinal=true)</td></tr>
<tr class="memdesc:a8d412272832b545ffdf4019e736ff7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information. ">tinfo_t</a> object for an existing named type.  <a href="#a8d412272832b545ffdf4019e736ff7b7">More...</a><br /></td></tr>
<tr class="separator:a8d412272832b545ffdf4019e736ff7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a0edf6c7baed76c657aee40e431572"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a86a0edf6c7baed76c657aee40e431572">get_numbered_type</a> (const <a class="el" href="structtil__t.html">til_t</a> *til, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ordinal, <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> decl_type=<a class="el" href="group__tf__shortcuts.html#ga64e49eed2f4e754689e7bcc7f6efdd74">BTF_TYPEDEF</a>, bool resolve=true)</td></tr>
<tr class="memdesc:a86a0edf6c7baed76c657aee40e431572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information. ">tinfo_t</a> object for an existing ordinal type.  <a href="#a86a0edf6c7baed76c657aee40e431572">More...</a><br /></td></tr>
<tr class="separator:a86a0edf6c7baed76c657aee40e431572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4579350fc689d4ad76849bd79e33ef5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4579350fc689d4ad76849bd79e33ef5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#aa4579350fc689d4ad76849bd79e33ef5">serialize</a> (<a class="el" href="pro_8h.html#a7fad0f3973de5825c480e27517e159f3">qtype</a> *type, <a class="el" href="pro_8h.html#a7fad0f3973de5825c480e27517e159f3">qtype</a> *fields=NULL, <a class="el" href="pro_8h.html#a7fad0f3973de5825c480e27517e159f3">qtype</a> *fldcmts=NULL, int sudt_flags=<a class="el" href="group___s_u_d_t__.html#gaeaa511ce041efaeb0ce9659fcb35b7a7">SUDT_FAST</a>|<a class="el" href="group___s_u_d_t__.html#ga1e082c951f7e37bafdf409d66aa785a2">SUDT_TRUNC</a>) const </td></tr>
<tr class="memdesc:aa4579350fc689d4ad76849bd79e33ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize <a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information. ">tinfo_t</a> object into a type string. <br /></td></tr>
<tr class="separator:aa4579350fc689d4ad76849bd79e33ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380c6dc7c423cca6cad0adbc27dfeccd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a380c6dc7c423cca6cad0adbc27dfeccd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a380c6dc7c423cca6cad0adbc27dfeccd">deserialize</a> (const <a class="el" href="structtil__t.html">til_t</a> *til, const <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> **ptype, const <a class="el" href="typeinf_8hpp.html#a828c7e985f83b1e74eb4ea7b716abfb1">p_list</a> **pfields=NULL, const <a class="el" href="typeinf_8hpp.html#a828c7e985f83b1e74eb4ea7b716abfb1">p_list</a> **pfldcmts=NULL)</td></tr>
<tr class="memdesc:a380c6dc7c423cca6cad0adbc27dfeccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize a type string into a <a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information. ">tinfo_t</a> object. <br /></td></tr>
<tr class="separator:a380c6dc7c423cca6cad0adbc27dfeccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc913b2fce03d59b0ce3e1a2dfa07ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a0bc913b2fce03d59b0ce3e1a2dfa07ed">deserialize</a> (const <a class="el" href="structtil__t.html">til_t</a> *til, const <a class="el" href="pro_8h.html#a7fad0f3973de5825c480e27517e159f3">qtype</a> *ptype, const <a class="el" href="pro_8h.html#a7fad0f3973de5825c480e27517e159f3">qtype</a> *pfields=NULL, const <a class="el" href="pro_8h.html#a7fad0f3973de5825c480e27517e159f3">qtype</a> *pfldcmts=NULL)</td></tr>
<tr class="memdesc:a0bc913b2fce03d59b0ce3e1a2dfa07ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize a type string into a <a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information. ">tinfo_t</a> object.  <a href="#a0bc913b2fce03d59b0ce3e1a2dfa07ed">More...</a><br /></td></tr>
<tr class="separator:a0bc913b2fce03d59b0ce3e1a2dfa07ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a560fccc25a67c150bddbb99013f4a847"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a560fccc25a67c150bddbb99013f4a847">is_correct</a> (void) const </td></tr>
<tr class="memdesc:a560fccc25a67c150bddbb99013f4a847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the type object correct?.  <a href="#a560fccc25a67c150bddbb99013f4a847">More...</a><br /></td></tr>
<tr class="separator:a560fccc25a67c150bddbb99013f4a847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6b9b21fce581447232d0ca3bae4feb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb">get_realtype</a> (bool full=false) const </td></tr>
<tr class="memdesc:aec6b9b21fce581447232d0ca3bae4feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the resolved base type.  <a href="#aec6b9b21fce581447232d0ca3bae4feb">More...</a><br /></td></tr>
<tr class="separator:aec6b9b21fce581447232d0ca3bae4feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49b27cb43a61932bf83045dbf0e8e20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20">get_decltype</a> (void) const </td></tr>
<tr class="memdesc:ad49b27cb43a61932bf83045dbf0e8e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get declared type (without resolving type references; they are returned as is).  <a href="#ad49b27cb43a61932bf83045dbf0e8e20">More...</a><br /></td></tr>
<tr class="separator:ad49b27cb43a61932bf83045dbf0e8e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe582a29ba03312969840ad91ef3384e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe582a29ba03312969840ad91ef3384e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#afe582a29ba03312969840ad91ef3384e">empty</a> (void) const </td></tr>
<tr class="memdesc:afe582a29ba03312969840ad91ef3384e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Was <a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information. ">tinfo_t</a> initialized with some type info or not? <br /></td></tr>
<tr class="separator:afe582a29ba03312969840ad91ef3384e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a68cfd1bc2054a900b85438e2aa2ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02a68cfd1bc2054a900b85438e2aa2ec"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a02a68cfd1bc2054a900b85438e2aa2ec">present</a> (void) const </td></tr>
<tr class="memdesc:a02a68cfd1bc2054a900b85438e2aa2ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the type really present? (not a reference to a missing type, for example) <br /></td></tr>
<tr class="separator:a02a68cfd1bc2054a900b85438e2aa2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e028c207d564e387d233fc79195f9a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a85e028c207d564e387d233fc79195f9a">get_size</a> (<a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> *p_effalign=NULL, int gts_code=0) const </td></tr>
<tr class="memdesc:a85e028c207d564e387d233fc79195f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type size in bytes.  <a href="#a85e028c207d564e387d233fc79195f9a">More...</a><br /></td></tr>
<tr class="separator:a85e028c207d564e387d233fc79195f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b41d32a72cf765b8745500391100fad"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a8b41d32a72cf765b8745500391100fad">get_unpadded_size</a> (void) const </td></tr>
<tr class="memdesc:a8b41d32a72cf765b8745500391100fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type size in bytes without the final padding.  <a href="#a8b41d32a72cf765b8745500391100fad">More...</a><br /></td></tr>
<tr class="separator:a8b41d32a72cf765b8745500391100fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ce44f0fee045e60f2f74e2bd39d694"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18ce44f0fee045e60f2f74e2bd39d694"></a>
<a class="el" href="group__tattr__ext.html#ga91970b0d779fe968b3b22572526048a0">type_sign_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a18ce44f0fee045e60f2f74e2bd39d694">get_sign</a> (void) const </td></tr>
<tr class="memdesc:a18ce44f0fee045e60f2f74e2bd39d694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get type sign. <br /></td></tr>
<tr class="separator:a18ce44f0fee045e60f2f74e2bd39d694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9acfd10453c5c3a8f0b25d55dab97477"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9acfd10453c5c3a8f0b25d55dab97477"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a9acfd10453c5c3a8f0b25d55dab97477">is_signed</a> (void) const </td></tr>
<tr class="memdesc:a9acfd10453c5c3a8f0b25d55dab97477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this a signed type? <br /></td></tr>
<tr class="separator:a9acfd10453c5c3a8f0b25d55dab97477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c7daf8522e6e695734036ca056ac7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79c7daf8522e6e695734036ca056ac7f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a79c7daf8522e6e695734036ca056ac7f">is_unsigned</a> (void) const </td></tr>
<tr class="memdesc:a79c7daf8522e6e695734036ca056ac7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this an unsigned type? <br /></td></tr>
<tr class="separator:a79c7daf8522e6e695734036ca056ac7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92a9a71049633be2ba6f19060d465b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac92a9a71049633be2ba6f19060d465b7"></a>
<a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#ac92a9a71049633be2ba6f19060d465b7">get_declalign</a> (void) const </td></tr>
<tr class="memdesc:ac92a9a71049633be2ba6f19060d465b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get declared alignment of the type. <br /></td></tr>
<tr class="separator:ac92a9a71049633be2ba6f19060d465b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50abfc9c0a7dcbaa6f398f7ece0c172d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50abfc9c0a7dcbaa6f398f7ece0c172d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a50abfc9c0a7dcbaa6f398f7ece0c172d">set_declalign</a> (<a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> declalign)</td></tr>
<tr class="memdesc:a50abfc9c0a7dcbaa6f398f7ece0c172d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set declared alignment of the type. <br /></td></tr>
<tr class="separator:a50abfc9c0a7dcbaa6f398f7ece0c172d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf258b6e0e8103697118b762fa6fd1ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#aaf258b6e0e8103697118b762fa6fd1ff">is_typeref</a> (void) const </td></tr>
<tr class="memdesc:aaf258b6e0e8103697118b762fa6fd1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this type a type reference?.  <a href="#aaf258b6e0e8103697118b762fa6fd1ff">More...</a><br /></td></tr>
<tr class="separator:aaf258b6e0e8103697118b762fa6fd1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb31fda9e80da3e6b9e4f3138bad6b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bb31fda9e80da3e6b9e4f3138bad6b0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a9bb31fda9e80da3e6b9e4f3138bad6b0">has_details</a> (void) const </td></tr>
<tr class="memdesc:a9bb31fda9e80da3e6b9e4f3138bad6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this type refer to a nontrivial type? <br /></td></tr>
<tr class="separator:a9bb31fda9e80da3e6b9e4f3138bad6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84af273ca27a03a5b81e09fe5d56f2cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a84af273ca27a03a5b81e09fe5d56f2cb">get_type_name</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *name) const </td></tr>
<tr class="memdesc:a84af273ca27a03a5b81e09fe5d56f2cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does a type refer to a name?.  <a href="#a84af273ca27a03a5b81e09fe5d56f2cb">More...</a><br /></td></tr>
<tr class="separator:a84af273ca27a03a5b81e09fe5d56f2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09bac545345c06dbf4d29c966e5523c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#ae09bac545345c06dbf4d29c966e5523c">get_final_type_name</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *name) const </td></tr>
<tr class="memdesc:ae09bac545345c06dbf4d29c966e5523c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use in the case of typedef chain (TYPE1 -&gt; TYPE2 -&gt; TYPE3...TYPEn).  <a href="#ae09bac545345c06dbf4d29c966e5523c">More...</a><br /></td></tr>
<tr class="separator:ae09bac545345c06dbf4d29c966e5523c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516a0d94c0ebd7d036bff3be7fcda383"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a516a0d94c0ebd7d036bff3be7fcda383">get_next_type_name</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *name) const </td></tr>
<tr class="memdesc:a516a0d94c0ebd7d036bff3be7fcda383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use In the case of typedef chain (TYPE1 -&gt; TYPE2 -&gt; TYPE3...TYPEn).  <a href="#a516a0d94c0ebd7d036bff3be7fcda383">More...</a><br /></td></tr>
<tr class="separator:a516a0d94c0ebd7d036bff3be7fcda383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43bfb980195ac47a33f4bc7da2f0738"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae43bfb980195ac47a33f4bc7da2f0738"></a>
<a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#ae43bfb980195ac47a33f4bc7da2f0738">get_ordinal</a> (void) const </td></tr>
<tr class="memdesc:ae43bfb980195ac47a33f4bc7da2f0738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get type ordinal (only if the type was created as a numbered type, 0 if none) <br /></td></tr>
<tr class="separator:ae43bfb980195ac47a33f4bc7da2f0738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4acf2d747c410042f93f23c6129d4031"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4acf2d747c410042f93f23c6129d4031"></a>
<a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a4acf2d747c410042f93f23c6129d4031">get_final_ordinal</a> (void) const </td></tr>
<tr class="memdesc:a4acf2d747c410042f93f23c6129d4031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get final type ordinal (0 is none) <br /></td></tr>
<tr class="separator:a4acf2d747c410042f93f23c6129d4031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34359e10559ffcdbcf71a065b2e11dd1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34359e10559ffcdbcf71a065b2e11dd1"></a>
const <a class="el" href="structtil__t.html">til_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a34359e10559ffcdbcf71a065b2e11dd1">get_til</a> (void) const </td></tr>
<tr class="memdesc:a34359e10559ffcdbcf71a065b2e11dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type library for <a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information. ">tinfo_t</a>. <br /></td></tr>
<tr class="separator:a34359e10559ffcdbcf71a065b2e11dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0e0873c6fae468e9928e1fb2739c9c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a6c0e0873c6fae468e9928e1fb2739c9c">is_from_subtil</a> (void) const </td></tr>
<tr class="memdesc:a6c0e0873c6fae468e9928e1fb2739c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Was the named type found in some base type library (not the top level type library)?.  <a href="#a6c0e0873c6fae468e9928e1fb2739c9c">More...</a><br /></td></tr>
<tr class="separator:a6c0e0873c6fae468e9928e1fb2739c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72fa94c7b1b58690b38010d8115d8c43"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a72fa94c7b1b58690b38010d8115d8c43">is_forward_decl</a> (void) const </td></tr>
<tr class="memdesc:a72fa94c7b1b58690b38010d8115d8c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this a forward declaration?.  <a href="#a72fa94c7b1b58690b38010d8115d8c43">More...</a><br /></td></tr>
<tr class="separator:a72fa94c7b1b58690b38010d8115d8c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67df919f298b73fae324cdbcf16023e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67df919f298b73fae324cdbcf16023e9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a67df919f298b73fae324cdbcf16023e9">is_decl_const</a> (void) const </td></tr>
<tr class="memdesc:a67df919f298b73fae324cdbcf16023e9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a51cf9b1a0d28c71ca65aee38bfa8fac7">is_type_const</a>(<a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20" title="Get declared type (without resolving type references; they are returned as is). ">get_decltype()</a>) <br /></td></tr>
<tr class="separator:a67df919f298b73fae324cdbcf16023e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386d09b1377e3ed1318925bee876d6c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a386d09b1377e3ed1318925bee876d6c7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a386d09b1377e3ed1318925bee876d6c7">is_decl_volatile</a> (void) const </td></tr>
<tr class="memdesc:a386d09b1377e3ed1318925bee876d6c7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a80b10ea9b3431c45ac22eda54d1366f9">is_type_volatile</a>(<a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20" title="Get declared type (without resolving type references; they are returned as is). ">get_decltype()</a>) <br /></td></tr>
<tr class="separator:a386d09b1377e3ed1318925bee876d6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952101ec14b0465e0f97619849ddbc56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a952101ec14b0465e0f97619849ddbc56"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a952101ec14b0465e0f97619849ddbc56">is_decl_void</a> (void) const </td></tr>
<tr class="memdesc:a952101ec14b0465e0f97619849ddbc56"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a77e6888e9d135e8d5c0327966f693d0b">is_type_void</a>(<a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20" title="Get declared type (without resolving type references; they are returned as is). ">get_decltype()</a>) <br /></td></tr>
<tr class="separator:a952101ec14b0465e0f97619849ddbc56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3184fd051cd2ab7acea40c1fb2e3b911"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3184fd051cd2ab7acea40c1fb2e3b911"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a3184fd051cd2ab7acea40c1fb2e3b911">is_decl_partial</a> (void) const </td></tr>
<tr class="memdesc:a3184fd051cd2ab7acea40c1fb2e3b911"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#ab83f8b87f1a116b28de6f39367907e57">is_type_partial</a>(<a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20" title="Get declared type (without resolving type references; they are returned as is). ">get_decltype()</a>) <br /></td></tr>
<tr class="separator:a3184fd051cd2ab7acea40c1fb2e3b911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaec36d3dc6b286fc97b4dddc346f231"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abaec36d3dc6b286fc97b4dddc346f231"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#abaec36d3dc6b286fc97b4dddc346f231">is_decl_unknown</a> (void) const </td></tr>
<tr class="memdesc:abaec36d3dc6b286fc97b4dddc346f231"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a24515193010b7f58015ee8cc03eca7f1">is_type_unknown</a>(<a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20" title="Get declared type (without resolving type references; they are returned as is). ">get_decltype()</a>) <br /></td></tr>
<tr class="separator:abaec36d3dc6b286fc97b4dddc346f231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6747a760871a72fe833fa13f2559152"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6747a760871a72fe833fa13f2559152"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#ab6747a760871a72fe833fa13f2559152">is_decl_last</a> (void) const </td></tr>
<tr class="memdesc:ab6747a760871a72fe833fa13f2559152"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#aebd7e7fd4f1041fc1980308b22daec4c">is_typeid_last</a>(<a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20" title="Get declared type (without resolving type references; they are returned as is). ">get_decltype()</a>) <br /></td></tr>
<tr class="separator:ab6747a760871a72fe833fa13f2559152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ffcf1e456007cbea543c985cb4aa11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8ffcf1e456007cbea543c985cb4aa11"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#ac8ffcf1e456007cbea543c985cb4aa11">is_decl_ptr</a> (void) const </td></tr>
<tr class="memdesc:ac8ffcf1e456007cbea543c985cb4aa11"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a18054ce101e6143625b7db3dcffa84f3">is_type_ptr</a>(<a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20" title="Get declared type (without resolving type references; they are returned as is). ">get_decltype()</a>) <br /></td></tr>
<tr class="separator:ac8ffcf1e456007cbea543c985cb4aa11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f60cbcc10e4bf38efe29c4aae7f028"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41f60cbcc10e4bf38efe29c4aae7f028"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a41f60cbcc10e4bf38efe29c4aae7f028">is_decl_array</a> (void) const </td></tr>
<tr class="memdesc:a41f60cbcc10e4bf38efe29c4aae7f028"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#afb67b217c6de98ef862d41dc6c32e6d5">is_type_array</a>(<a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20" title="Get declared type (without resolving type references; they are returned as is). ">get_decltype()</a>) <br /></td></tr>
<tr class="separator:a41f60cbcc10e4bf38efe29c4aae7f028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d04c959264ea2d82a92ab9253a9c88"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9d04c959264ea2d82a92ab9253a9c88"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#ac9d04c959264ea2d82a92ab9253a9c88">is_decl_func</a> (void) const </td></tr>
<tr class="memdesc:ac9d04c959264ea2d82a92ab9253a9c88"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a3c986cca864998ea2aed51a973a1edb5">is_type_func</a>(<a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20" title="Get declared type (without resolving type references; they are returned as is). ">get_decltype()</a>) <br /></td></tr>
<tr class="separator:ac9d04c959264ea2d82a92ab9253a9c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3eb22220b9f18f6f720a4dd886b2ec7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3eb22220b9f18f6f720a4dd886b2ec7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#af3eb22220b9f18f6f720a4dd886b2ec7">is_decl_complex</a> (void) const </td></tr>
<tr class="memdesc:af3eb22220b9f18f6f720a4dd886b2ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a934f8fa64631f43d359f0e1b568effc0">is_type_complex</a>(<a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20" title="Get declared type (without resolving type references; they are returned as is). ">get_decltype()</a>) <br /></td></tr>
<tr class="separator:af3eb22220b9f18f6f720a4dd886b2ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f6de5188c6eb0710328b86c0971065"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1f6de5188c6eb0710328b86c0971065"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#af1f6de5188c6eb0710328b86c0971065">is_decl_typedef</a> (void) const </td></tr>
<tr class="memdesc:af1f6de5188c6eb0710328b86c0971065"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a42961bafc2706f67389414331347e50d">is_type_typedef</a>(<a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20" title="Get declared type (without resolving type references; they are returned as is). ">get_decltype()</a>) <br /></td></tr>
<tr class="separator:af1f6de5188c6eb0710328b86c0971065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ebea18eb12f37b74bfe814be99d288"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3ebea18eb12f37b74bfe814be99d288"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#aa3ebea18eb12f37b74bfe814be99d288">is_decl_sue</a> (void) const </td></tr>
<tr class="memdesc:aa3ebea18eb12f37b74bfe814be99d288"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#afd24208ac9c5428140cd420576db5895">is_type_sue</a>(<a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20" title="Get declared type (without resolving type references; they are returned as is). ">get_decltype()</a>) <br /></td></tr>
<tr class="separator:aa3ebea18eb12f37b74bfe814be99d288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d57e53eae1e6f7d48c99af4eaf626c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7d57e53eae1e6f7d48c99af4eaf626c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#ab7d57e53eae1e6f7d48c99af4eaf626c">is_decl_struct</a> (void) const </td></tr>
<tr class="memdesc:ab7d57e53eae1e6f7d48c99af4eaf626c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a1cbf1afd168669521c3d4d12a931c40a">is_type_struct</a>(<a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20" title="Get declared type (without resolving type references; they are returned as is). ">get_decltype()</a>) <br /></td></tr>
<tr class="separator:ab7d57e53eae1e6f7d48c99af4eaf626c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5a3aa1ddcb572a9d9f959d2d14e257"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a5a3aa1ddcb572a9d9f959d2d14e257"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a9a5a3aa1ddcb572a9d9f959d2d14e257">is_decl_union</a> (void) const </td></tr>
<tr class="memdesc:a9a5a3aa1ddcb572a9d9f959d2d14e257"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a01cb639868cc0e5df063602cedc2e995">is_type_union</a>(<a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20" title="Get declared type (without resolving type references; they are returned as is). ">get_decltype()</a>) <br /></td></tr>
<tr class="separator:a9a5a3aa1ddcb572a9d9f959d2d14e257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe4bb58804d140691c1f868822f953e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbe4bb58804d140691c1f868822f953e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#adbe4bb58804d140691c1f868822f953e">is_decl_udt</a> (void) const </td></tr>
<tr class="memdesc:adbe4bb58804d140691c1f868822f953e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a33b3b29c8f85c37e109d703ec8967bf9">is_type_struni</a>(<a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20" title="Get declared type (without resolving type references; they are returned as is). ">get_decltype()</a>) <br /></td></tr>
<tr class="separator:adbe4bb58804d140691c1f868822f953e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b53925e69af8d52bd41c6de6a9c394b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b53925e69af8d52bd41c6de6a9c394b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a0b53925e69af8d52bd41c6de6a9c394b">is_decl_enum</a> (void) const </td></tr>
<tr class="memdesc:a0b53925e69af8d52bd41c6de6a9c394b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#adebf867753ddabcfbf0436cc77735e9b">is_type_enum</a>(<a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20" title="Get declared type (without resolving type references; they are returned as is). ">get_decltype()</a>) <br /></td></tr>
<tr class="separator:a0b53925e69af8d52bd41c6de6a9c394b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a5bb8d69e82e0b0a4324b17e72b985"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0a5bb8d69e82e0b0a4324b17e72b985"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#ae0a5bb8d69e82e0b0a4324b17e72b985">is_decl_bitfield</a> (void) const </td></tr>
<tr class="memdesc:ae0a5bb8d69e82e0b0a4324b17e72b985"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a2a9e6ee314e917f99d6a019193e1cd62">is_type_bitfld</a>(<a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20" title="Get declared type (without resolving type references; they are returned as is). ">get_decltype()</a>) <br /></td></tr>
<tr class="separator:ae0a5bb8d69e82e0b0a4324b17e72b985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2482e6833d7f5ed0230db422668d69e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2482e6833d7f5ed0230db422668d69e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#ad2482e6833d7f5ed0230db422668d69e">is_decl_int128</a> (void) const </td></tr>
<tr class="memdesc:ad2482e6833d7f5ed0230db422668d69e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a0ff3cf0a5abe2c0c670a558a7bac8510">is_type_int128</a>(<a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20" title="Get declared type (without resolving type references; they are returned as is). ">get_decltype()</a>) <br /></td></tr>
<tr class="separator:ad2482e6833d7f5ed0230db422668d69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f1430bf48cd3dac0b520fb8c1d7ffe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1f1430bf48cd3dac0b520fb8c1d7ffe"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#aa1f1430bf48cd3dac0b520fb8c1d7ffe">is_decl_int64</a> (void) const </td></tr>
<tr class="memdesc:aa1f1430bf48cd3dac0b520fb8c1d7ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#aa33b5f0e344daa1ba546ca60718698ca">is_type_int64</a>(<a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20" title="Get declared type (without resolving type references; they are returned as is). ">get_decltype()</a>) <br /></td></tr>
<tr class="separator:aa1f1430bf48cd3dac0b520fb8c1d7ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad108f62d6d8e5563dbd0fe1f37efca0b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad108f62d6d8e5563dbd0fe1f37efca0b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#ad108f62d6d8e5563dbd0fe1f37efca0b">is_decl_int32</a> (void) const </td></tr>
<tr class="memdesc:ad108f62d6d8e5563dbd0fe1f37efca0b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a5f015c8f5fbd18e963d890bbab3708f0">is_type_int32</a>(<a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20" title="Get declared type (without resolving type references; they are returned as is). ">get_decltype()</a>) <br /></td></tr>
<tr class="separator:ad108f62d6d8e5563dbd0fe1f37efca0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a81c3cee968e66f434a45f99d2dd76"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0a81c3cee968e66f434a45f99d2dd76"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#aa0a81c3cee968e66f434a45f99d2dd76">is_decl_int16</a> (void) const </td></tr>
<tr class="memdesc:aa0a81c3cee968e66f434a45f99d2dd76"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a03b7cf251e25554e61cdcceaa5570027">is_type_int16</a>(<a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20" title="Get declared type (without resolving type references; they are returned as is). ">get_decltype()</a>) <br /></td></tr>
<tr class="separator:aa0a81c3cee968e66f434a45f99d2dd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2760ff789a08cb396ee4e8c4b3b0fcea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2760ff789a08cb396ee4e8c4b3b0fcea"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a2760ff789a08cb396ee4e8c4b3b0fcea">is_decl_char</a> (void) const </td></tr>
<tr class="memdesc:a2760ff789a08cb396ee4e8c4b3b0fcea"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a5c42a545c36c52ea2a401c4d4446125e">is_type_char</a>(<a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20" title="Get declared type (without resolving type references; they are returned as is). ">get_decltype()</a>) <br /></td></tr>
<tr class="separator:a2760ff789a08cb396ee4e8c4b3b0fcea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa973ce93e18152721b5afa495ab87a4d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa973ce93e18152721b5afa495ab87a4d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#aa973ce93e18152721b5afa495ab87a4d">is_decl_uint</a> (void) const </td></tr>
<tr class="memdesc:aa973ce93e18152721b5afa495ab87a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a87fc1280da78d15e1fd7b923c3811128">is_type_uint</a>(<a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20" title="Get declared type (without resolving type references; they are returned as is). ">get_decltype()</a>) <br /></td></tr>
<tr class="separator:aa973ce93e18152721b5afa495ab87a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4f3dc75d5d7863eef9a4fdc50df5c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb4f3dc75d5d7863eef9a4fdc50df5c6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#acb4f3dc75d5d7863eef9a4fdc50df5c6">is_decl_uchar</a> (void) const </td></tr>
<tr class="memdesc:acb4f3dc75d5d7863eef9a4fdc50df5c6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a845e6498c46db9509b76eb47d2803621">is_type_uchar</a>(<a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20" title="Get declared type (without resolving type references; they are returned as is). ">get_decltype()</a>) <br /></td></tr>
<tr class="separator:acb4f3dc75d5d7863eef9a4fdc50df5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1f02d9bf35f8e9d6746531978bd13e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe1f02d9bf35f8e9d6746531978bd13e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#abe1f02d9bf35f8e9d6746531978bd13e">is_decl_uint16</a> (void) const </td></tr>
<tr class="memdesc:abe1f02d9bf35f8e9d6746531978bd13e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a31658f442e0074ebae9a7b1b51e91f42">is_type_uint16</a>(<a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20" title="Get declared type (without resolving type references; they are returned as is). ">get_decltype()</a>) <br /></td></tr>
<tr class="separator:abe1f02d9bf35f8e9d6746531978bd13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57385a79df52b672c39ac62290efa2b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57385a79df52b672c39ac62290efa2b8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a57385a79df52b672c39ac62290efa2b8">is_decl_uint32</a> (void) const </td></tr>
<tr class="memdesc:a57385a79df52b672c39ac62290efa2b8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#ae4a178b7e9b4e4dd9acc64f4b4425c8f">is_type_uint32</a>(<a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20" title="Get declared type (without resolving type references; they are returned as is). ">get_decltype()</a>) <br /></td></tr>
<tr class="separator:a57385a79df52b672c39ac62290efa2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381241363d29d5464c8e2a4d7203544e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a381241363d29d5464c8e2a4d7203544e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a381241363d29d5464c8e2a4d7203544e">is_decl_uint64</a> (void) const </td></tr>
<tr class="memdesc:a381241363d29d5464c8e2a4d7203544e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#af9257b8b383a8f3f27bf7fa583dd9de0">is_type_uint64</a>(<a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20" title="Get declared type (without resolving type references; they are returned as is). ">get_decltype()</a>) <br /></td></tr>
<tr class="separator:a381241363d29d5464c8e2a4d7203544e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969891010ddb6f693e1c4964bfdcaf17"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a969891010ddb6f693e1c4964bfdcaf17"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a969891010ddb6f693e1c4964bfdcaf17">is_decl_uint128</a> (void) const </td></tr>
<tr class="memdesc:a969891010ddb6f693e1c4964bfdcaf17"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a902ad6b8abee96b307c85c9b7550c009">is_type_uint128</a>(<a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20" title="Get declared type (without resolving type references; they are returned as is). ">get_decltype()</a>) <br /></td></tr>
<tr class="separator:a969891010ddb6f693e1c4964bfdcaf17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad890e9776e7501ce8d4b0f19f769c4bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad890e9776e7501ce8d4b0f19f769c4bb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#ad890e9776e7501ce8d4b0f19f769c4bb">is_decl_ldouble</a> (void) const </td></tr>
<tr class="memdesc:ad890e9776e7501ce8d4b0f19f769c4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#adf37ca46ae9033692d248c13f4cbce10">is_type_ldouble</a>(<a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20" title="Get declared type (without resolving type references; they are returned as is). ">get_decltype()</a>) <br /></td></tr>
<tr class="separator:ad890e9776e7501ce8d4b0f19f769c4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d44e0e4bb90fce7bf935d2aeec326e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d44e0e4bb90fce7bf935d2aeec326e5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a5d44e0e4bb90fce7bf935d2aeec326e5">is_decl_double</a> (void) const </td></tr>
<tr class="memdesc:a5d44e0e4bb90fce7bf935d2aeec326e5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#adce756c3cbaa4dbad990412334db918e">is_type_double</a>(<a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20" title="Get declared type (without resolving type references; they are returned as is). ">get_decltype()</a>) <br /></td></tr>
<tr class="separator:a5d44e0e4bb90fce7bf935d2aeec326e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22daa41c3ffc1e56486e34f94dbb6b91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22daa41c3ffc1e56486e34f94dbb6b91"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a22daa41c3ffc1e56486e34f94dbb6b91">is_decl_float</a> (void) const </td></tr>
<tr class="memdesc:a22daa41c3ffc1e56486e34f94dbb6b91"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a44d232a226337a1935b1ee5667572bf1">is_type_float</a>(<a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20" title="Get declared type (without resolving type references; they are returned as is). ">get_decltype()</a>) <br /></td></tr>
<tr class="separator:a22daa41c3ffc1e56486e34f94dbb6b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb462229f4ae1defefd61a3c91c2e4e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb462229f4ae1defefd61a3c91c2e4e5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#afb462229f4ae1defefd61a3c91c2e4e5">is_decl_floating</a> (void) const </td></tr>
<tr class="memdesc:afb462229f4ae1defefd61a3c91c2e4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#af3d6f80786dc0d53d399dcd0646ff6b6">is_type_floating</a>(<a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20" title="Get declared type (without resolving type references; they are returned as is). ">get_decltype()</a>) <br /></td></tr>
<tr class="separator:afb462229f4ae1defefd61a3c91c2e4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5cc698ef7428b75cc5619be915521ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5cc698ef7428b75cc5619be915521ea"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#ad5cc698ef7428b75cc5619be915521ea">is_decl_bool</a> (void) const </td></tr>
<tr class="memdesc:ad5cc698ef7428b75cc5619be915521ea"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a30e6e0c0fb51e070782953fedcc19c13">is_type_bool</a>(<a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20" title="Get declared type (without resolving type references; they are returned as is). ">get_decltype()</a>) <br /></td></tr>
<tr class="separator:ad5cc698ef7428b75cc5619be915521ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9b06b4c3024724711fdf0a97f44b0d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd9b06b4c3024724711fdf0a97f44b0d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#acd9b06b4c3024724711fdf0a97f44b0d">is_decl_paf</a> (void) const </td></tr>
<tr class="memdesc:acd9b06b4c3024724711fdf0a97f44b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a4017476ec73427bc8dcb2dc477dfeb63">is_type_paf</a>(<a class="el" href="classtinfo__t.html#ad49b27cb43a61932bf83045dbf0e8e20" title="Get declared type (without resolving type references; they are returned as is). ">get_decltype()</a>) <br /></td></tr>
<tr class="separator:acd9b06b4c3024724711fdf0a97f44b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3322c056f9173b2294f0ac7ff5f12f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3322c056f9173b2294f0ac7ff5f12f9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#ad3322c056f9173b2294f0ac7ff5f12f9">is_well_defined</a> (void) const </td></tr>
<tr class="memdesc:ad3322c056f9173b2294f0ac7ff5f12f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">!(<a class="el" href="classtinfo__t.html#afe582a29ba03312969840ad91ef3384e" title="Was tinfo_t initialized with some type info or not? ">empty()</a>) &amp;&amp; !(<a class="el" href="classtinfo__t.html#a3184fd051cd2ab7acea40c1fb2e3b911" title="is_type_partial(get_decltype()) ">is_decl_partial()</a>) <br /></td></tr>
<tr class="separator:ad3322c056f9173b2294f0ac7ff5f12f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ca696dfe4108285f83488af59c75f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6ca696dfe4108285f83488af59c75f2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#ae6ca696dfe4108285f83488af59c75f2">is_const</a> (void) const </td></tr>
<tr class="memdesc:ae6ca696dfe4108285f83488af59c75f2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a51cf9b1a0d28c71ca65aee38bfa8fac7">is_type_const</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:ae6ca696dfe4108285f83488af59c75f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c319303cc75c0c282bf7f92d052376"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07c319303cc75c0c282bf7f92d052376"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a07c319303cc75c0c282bf7f92d052376">is_volatile</a> (void) const </td></tr>
<tr class="memdesc:a07c319303cc75c0c282bf7f92d052376"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a80b10ea9b3431c45ac22eda54d1366f9">is_type_volatile</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:a07c319303cc75c0c282bf7f92d052376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356268fdf4f1b182a159bec43e8b2c14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a356268fdf4f1b182a159bec43e8b2c14"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a356268fdf4f1b182a159bec43e8b2c14">is_void</a> (void) const </td></tr>
<tr class="memdesc:a356268fdf4f1b182a159bec43e8b2c14"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a77e6888e9d135e8d5c0327966f693d0b">is_type_void</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:a356268fdf4f1b182a159bec43e8b2c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7ed47d8edbc453c4c9a1564aeddc3b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c7ed47d8edbc453c4c9a1564aeddc3b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a7c7ed47d8edbc453c4c9a1564aeddc3b">is_partial</a> (void) const </td></tr>
<tr class="memdesc:a7c7ed47d8edbc453c4c9a1564aeddc3b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#ab83f8b87f1a116b28de6f39367907e57">is_type_partial</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:a7c7ed47d8edbc453c4c9a1564aeddc3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a9545333a3aaf5bbe529de451de1ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95a9545333a3aaf5bbe529de451de1ea"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a95a9545333a3aaf5bbe529de451de1ea">is_unknown</a> (void) const </td></tr>
<tr class="memdesc:a95a9545333a3aaf5bbe529de451de1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a24515193010b7f58015ee8cc03eca7f1">is_type_unknown</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:a95a9545333a3aaf5bbe529de451de1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860c08460c26af31545a99976ab42bb7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a860c08460c26af31545a99976ab42bb7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a860c08460c26af31545a99976ab42bb7">is_ptr</a> (void) const </td></tr>
<tr class="memdesc:a860c08460c26af31545a99976ab42bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a18054ce101e6143625b7db3dcffa84f3">is_type_ptr</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:a860c08460c26af31545a99976ab42bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ba159e0cee00b7012345d7f5360479"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26ba159e0cee00b7012345d7f5360479"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a26ba159e0cee00b7012345d7f5360479">is_array</a> (void) const </td></tr>
<tr class="memdesc:a26ba159e0cee00b7012345d7f5360479"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#afb67b217c6de98ef862d41dc6c32e6d5">is_type_array</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:a26ba159e0cee00b7012345d7f5360479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66079755f5f02e2a0864d270cf4dbd6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa66079755f5f02e2a0864d270cf4dbd6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#aa66079755f5f02e2a0864d270cf4dbd6">is_func</a> (void) const </td></tr>
<tr class="memdesc:aa66079755f5f02e2a0864d270cf4dbd6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a3c986cca864998ea2aed51a973a1edb5">is_type_func</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:aa66079755f5f02e2a0864d270cf4dbd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5067b36acec106ca2a7f9347c900244a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5067b36acec106ca2a7f9347c900244a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a5067b36acec106ca2a7f9347c900244a">is_complex</a> (void) const </td></tr>
<tr class="memdesc:a5067b36acec106ca2a7f9347c900244a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a934f8fa64631f43d359f0e1b568effc0">is_type_complex</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:a5067b36acec106ca2a7f9347c900244a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399f5bb5b002ce307cf73ca7b8e5d353"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a399f5bb5b002ce307cf73ca7b8e5d353"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a399f5bb5b002ce307cf73ca7b8e5d353">is_struct</a> (void) const </td></tr>
<tr class="memdesc:a399f5bb5b002ce307cf73ca7b8e5d353"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a1cbf1afd168669521c3d4d12a931c40a">is_type_struct</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:a399f5bb5b002ce307cf73ca7b8e5d353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805d21699d8c8590ab80ca8ca3fe2064"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a805d21699d8c8590ab80ca8ca3fe2064"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a805d21699d8c8590ab80ca8ca3fe2064">is_union</a> (void) const </td></tr>
<tr class="memdesc:a805d21699d8c8590ab80ca8ca3fe2064"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a01cb639868cc0e5df063602cedc2e995">is_type_union</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:a805d21699d8c8590ab80ca8ca3fe2064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781b6a55ad5cfe2bef8bbd6f9a20cb57"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a781b6a55ad5cfe2bef8bbd6f9a20cb57"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a781b6a55ad5cfe2bef8bbd6f9a20cb57">is_udt</a> (void) const </td></tr>
<tr class="memdesc:a781b6a55ad5cfe2bef8bbd6f9a20cb57"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a33b3b29c8f85c37e109d703ec8967bf9">is_type_struni</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:a781b6a55ad5cfe2bef8bbd6f9a20cb57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ac4521c8bfda233a529e3641b3824a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6ac4521c8bfda233a529e3641b3824a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#ac6ac4521c8bfda233a529e3641b3824a">is_enum</a> (void) const </td></tr>
<tr class="memdesc:ac6ac4521c8bfda233a529e3641b3824a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#adebf867753ddabcfbf0436cc77735e9b">is_type_enum</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:ac6ac4521c8bfda233a529e3641b3824a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf991b25bad153da1e9c68a52b07a36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="addf991b25bad153da1e9c68a52b07a36"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#addf991b25bad153da1e9c68a52b07a36">is_sue</a> (void) const </td></tr>
<tr class="memdesc:addf991b25bad153da1e9c68a52b07a36"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#afd24208ac9c5428140cd420576db5895">is_type_sue</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:addf991b25bad153da1e9c68a52b07a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aec0fa94705aac0edd4882d4e430f52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7aec0fa94705aac0edd4882d4e430f52"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a7aec0fa94705aac0edd4882d4e430f52">is_bitfield</a> (void) const </td></tr>
<tr class="memdesc:a7aec0fa94705aac0edd4882d4e430f52"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a2a9e6ee314e917f99d6a019193e1cd62">is_type_bitfld</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:a7aec0fa94705aac0edd4882d4e430f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1dc72ace4c431a3d08fd494794226bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1dc72ace4c431a3d08fd494794226bf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#ac1dc72ace4c431a3d08fd494794226bf">is_int128</a> (void) const </td></tr>
<tr class="memdesc:ac1dc72ace4c431a3d08fd494794226bf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a0ff3cf0a5abe2c0c670a558a7bac8510">is_type_int128</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:ac1dc72ace4c431a3d08fd494794226bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0ceb9d0f925275a3c07d39969c1985"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d0ceb9d0f925275a3c07d39969c1985"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a5d0ceb9d0f925275a3c07d39969c1985">is_int64</a> (void) const </td></tr>
<tr class="memdesc:a5d0ceb9d0f925275a3c07d39969c1985"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#aa33b5f0e344daa1ba546ca60718698ca">is_type_int64</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:a5d0ceb9d0f925275a3c07d39969c1985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087f40b2478b17474ea4d9c9e4b39bae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a087f40b2478b17474ea4d9c9e4b39bae"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a087f40b2478b17474ea4d9c9e4b39bae">is_int32</a> (void) const </td></tr>
<tr class="memdesc:a087f40b2478b17474ea4d9c9e4b39bae"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a5f015c8f5fbd18e963d890bbab3708f0">is_type_int32</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:a087f40b2478b17474ea4d9c9e4b39bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d3842ef3b23a932a43bfb3350d3da5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6d3842ef3b23a932a43bfb3350d3da5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#ad6d3842ef3b23a932a43bfb3350d3da5">is_int16</a> (void) const </td></tr>
<tr class="memdesc:ad6d3842ef3b23a932a43bfb3350d3da5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a03b7cf251e25554e61cdcceaa5570027">is_type_int16</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:ad6d3842ef3b23a932a43bfb3350d3da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43a7ceecb998762e3f32a7f70274586"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa43a7ceecb998762e3f32a7f70274586"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#aa43a7ceecb998762e3f32a7f70274586">is_char</a> (void) const </td></tr>
<tr class="memdesc:aa43a7ceecb998762e3f32a7f70274586"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a5c42a545c36c52ea2a401c4d4446125e">is_type_char</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:aa43a7ceecb998762e3f32a7f70274586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de7da12012e69858f4762539c58ee60"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4de7da12012e69858f4762539c58ee60"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a4de7da12012e69858f4762539c58ee60">is_uint</a> (void) const </td></tr>
<tr class="memdesc:a4de7da12012e69858f4762539c58ee60"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a87fc1280da78d15e1fd7b923c3811128">is_type_uint</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:a4de7da12012e69858f4762539c58ee60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ac034fc99ebf570b9c1d48eacd20c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74ac034fc99ebf570b9c1d48eacd20c5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a74ac034fc99ebf570b9c1d48eacd20c5">is_uchar</a> (void) const </td></tr>
<tr class="memdesc:a74ac034fc99ebf570b9c1d48eacd20c5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a845e6498c46db9509b76eb47d2803621">is_type_uchar</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:a74ac034fc99ebf570b9c1d48eacd20c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0868efdaf770802babaffc85651e85d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0868efdaf770802babaffc85651e85d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#ac0868efdaf770802babaffc85651e85d">is_uint16</a> (void) const </td></tr>
<tr class="memdesc:ac0868efdaf770802babaffc85651e85d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a31658f442e0074ebae9a7b1b51e91f42">is_type_uint16</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:ac0868efdaf770802babaffc85651e85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a1abe014de858c490a56eb98a8c84a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79a1abe014de858c490a56eb98a8c84a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a79a1abe014de858c490a56eb98a8c84a">is_uint32</a> (void) const </td></tr>
<tr class="memdesc:a79a1abe014de858c490a56eb98a8c84a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#ae4a178b7e9b4e4dd9acc64f4b4425c8f">is_type_uint32</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:a79a1abe014de858c490a56eb98a8c84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029fef568323f48b014fbb9fc174e9f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a029fef568323f48b014fbb9fc174e9f2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a029fef568323f48b014fbb9fc174e9f2">is_uint64</a> (void) const </td></tr>
<tr class="memdesc:a029fef568323f48b014fbb9fc174e9f2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#af9257b8b383a8f3f27bf7fa583dd9de0">is_type_uint64</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:a029fef568323f48b014fbb9fc174e9f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ce9c932c580a36e3556b4eeeb04457"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03ce9c932c580a36e3556b4eeeb04457"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a03ce9c932c580a36e3556b4eeeb04457">is_uint128</a> (void) const </td></tr>
<tr class="memdesc:a03ce9c932c580a36e3556b4eeeb04457"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a902ad6b8abee96b307c85c9b7550c009">is_type_uint128</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:a03ce9c932c580a36e3556b4eeeb04457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1852e12d139b969210fcef73cd0be36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1852e12d139b969210fcef73cd0be36"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#ad1852e12d139b969210fcef73cd0be36">is_ldouble</a> (void) const </td></tr>
<tr class="memdesc:ad1852e12d139b969210fcef73cd0be36"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#adf37ca46ae9033692d248c13f4cbce10">is_type_ldouble</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:ad1852e12d139b969210fcef73cd0be36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b44e25f29a1f94af1092db9b6cc1a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28b44e25f29a1f94af1092db9b6cc1a2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a28b44e25f29a1f94af1092db9b6cc1a2">is_double</a> (void) const </td></tr>
<tr class="memdesc:a28b44e25f29a1f94af1092db9b6cc1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#adce756c3cbaa4dbad990412334db918e">is_type_double</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:a28b44e25f29a1f94af1092db9b6cc1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ad7fccfed35aa2f3f0aa3720c94909"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2ad7fccfed35aa2f3f0aa3720c94909"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#aa2ad7fccfed35aa2f3f0aa3720c94909">is_float</a> (void) const </td></tr>
<tr class="memdesc:aa2ad7fccfed35aa2f3f0aa3720c94909"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a44d232a226337a1935b1ee5667572bf1">is_type_float</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:aa2ad7fccfed35aa2f3f0aa3720c94909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0967f6ada6b8a55e95fb2e3bb5c44ab9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0967f6ada6b8a55e95fb2e3bb5c44ab9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a0967f6ada6b8a55e95fb2e3bb5c44ab9">is_bool</a> (void) const </td></tr>
<tr class="memdesc:a0967f6ada6b8a55e95fb2e3bb5c44ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a30e6e0c0fb51e070782953fedcc19c13">is_type_bool</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:a0967f6ada6b8a55e95fb2e3bb5c44ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf87a108804d200d7177a9938709c5d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf87a108804d200d7177a9938709c5d1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#adf87a108804d200d7177a9938709c5d1">is_paf</a> (void) const </td></tr>
<tr class="memdesc:adf87a108804d200d7177a9938709c5d1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a4017476ec73427bc8dcb2dc477dfeb63">is_type_paf</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:adf87a108804d200d7177a9938709c5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4427ae14fc8b30c5453a8ec08b15e78"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4427ae14fc8b30c5453a8ec08b15e78"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#ac4427ae14fc8b30c5453a8ec08b15e78">is_ptr_or_array</a> (void) const </td></tr>
<tr class="memdesc:ac4427ae14fc8b30c5453a8ec08b15e78"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a21d8bd88f9651c87d55c8b7e147065df">is_type_ptr_or_array</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:ac4427ae14fc8b30c5453a8ec08b15e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256d6b4fcf14132791e12d2fa0f0e2d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a256d6b4fcf14132791e12d2fa0f0e2d7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a256d6b4fcf14132791e12d2fa0f0e2d7">is_integral</a> (void) const </td></tr>
<tr class="memdesc:a256d6b4fcf14132791e12d2fa0f0e2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a6ee202b9eefc9650f08483c7e5f47877">is_type_integral</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:a256d6b4fcf14132791e12d2fa0f0e2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926b3a5067b4912975b2003a25e676bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a926b3a5067b4912975b2003a25e676bc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a926b3a5067b4912975b2003a25e676bc">is_ext_integral</a> (void) const </td></tr>
<tr class="memdesc:a926b3a5067b4912975b2003a25e676bc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#aa8ffbdef24a7b79f750a9953e1669d0e">is_type_ext_integral</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:a926b3a5067b4912975b2003a25e676bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42205098da492bfdc827e2904d6172d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af42205098da492bfdc827e2904d6172d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#af42205098da492bfdc827e2904d6172d">is_floating</a> (void) const </td></tr>
<tr class="memdesc:af42205098da492bfdc827e2904d6172d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#af3d6f80786dc0d53d399dcd0646ff6b6">is_type_floating</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:af42205098da492bfdc827e2904d6172d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e2ebb7120cba1345d0ec20cb576535"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7e2ebb7120cba1345d0ec20cb576535"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#ab7e2ebb7120cba1345d0ec20cb576535">is_arithmetic</a> (void) const </td></tr>
<tr class="memdesc:ab7e2ebb7120cba1345d0ec20cb576535"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#aeda334071dd5e4a32394763f4f7f10d3">is_type_arithmetic</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:ab7e2ebb7120cba1345d0ec20cb576535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8b0464dc19614caa09c67a11e2b178"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a8b0464dc19614caa09c67a11e2b178"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a4a8b0464dc19614caa09c67a11e2b178">is_ext_arithmetic</a> (void) const </td></tr>
<tr class="memdesc:a4a8b0464dc19614caa09c67a11e2b178"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#ae853c2aaf6dfcbdb71c68247421318d1">is_type_ext_arithmetic</a>(<a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a>) <br /></td></tr>
<tr class="separator:a4a8b0464dc19614caa09c67a11e2b178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f83edf0bbd7cccec66a612a82c6d67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23f83edf0bbd7cccec66a612a82c6d67"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a23f83edf0bbd7cccec66a612a82c6d67">is_scalar</a> (void) const </td></tr>
<tr class="memdesc:a23f83edf0bbd7cccec66a612a82c6d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the type represent a single number? <br /></td></tr>
<tr class="separator:a23f83edf0bbd7cccec66a612a82c6d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a205c186569b169d78ebf1d7ef448f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68a205c186569b169d78ebf1d7ef448f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a68a205c186569b169d78ebf1d7ef448f">get_ptr_details</a> (<a class="el" href="structptr__type__data__t.html">ptr_type_data_t</a> *pi) const </td></tr>
<tr class="memdesc:a68a205c186569b169d78ebf1d7ef448f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get only the pointer specific info for this <a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information. ">tinfo_t</a>. <br /></td></tr>
<tr class="separator:a68a205c186569b169d78ebf1d7ef448f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab580f443ce50b81bf6f129f3d44ac01c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab580f443ce50b81bf6f129f3d44ac01c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#ab580f443ce50b81bf6f129f3d44ac01c">get_array_details</a> (<a class="el" href="structarray__type__data__t.html">array_type_data_t</a> *ai) const </td></tr>
<tr class="memdesc:ab580f443ce50b81bf6f129f3d44ac01c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get only the array specific info for this <a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information. ">tinfo_t</a>. <br /></td></tr>
<tr class="separator:ab580f443ce50b81bf6f129f3d44ac01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82e04da425c451c3081e8ffc68f01a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af82e04da425c451c3081e8ffc68f01a2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#af82e04da425c451c3081e8ffc68f01a2">get_enum_details</a> (<a class="el" href="structenum__type__data__t.html">enum_type_data_t</a> *ei) const </td></tr>
<tr class="memdesc:af82e04da425c451c3081e8ffc68f01a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get only the enum specific info for this <a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information. ">tinfo_t</a>. <br /></td></tr>
<tr class="separator:af82e04da425c451c3081e8ffc68f01a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01fee070f4fd57b4ba815f403d169a51"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01fee070f4fd57b4ba815f403d169a51"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a01fee070f4fd57b4ba815f403d169a51">get_bitfield_details</a> (<a class="el" href="structbitfield__type__data__t.html">bitfield_type_data_t</a> *bi) const </td></tr>
<tr class="memdesc:a01fee070f4fd57b4ba815f403d169a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get only the bitfield specific info for this <a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information. ">tinfo_t</a>. <br /></td></tr>
<tr class="separator:a01fee070f4fd57b4ba815f403d169a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8682a9456cf9d4ed6bbafa58e681bb14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8682a9456cf9d4ed6bbafa58e681bb14"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a8682a9456cf9d4ed6bbafa58e681bb14">get_udt_details</a> (<a class="el" href="structudt__type__data__t.html">udt_type_data_t</a> *udt, <a class="el" href="typeinf_8hpp.html#a6a3b7b00fcc1f35943355ff4a59ee27b">gtd_udt_t</a> gtd=<a class="el" href="typeinf_8hpp.html#a6a3b7b00fcc1f35943355ff4a59ee27ba1c0801cf7075c0d784cf8d66c608160c">GTD_CALC_LAYOUT</a>) const </td></tr>
<tr class="memdesc:a8682a9456cf9d4ed6bbafa58e681bb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get only the udt specific info for this <a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information. ">tinfo_t</a>. <br /></td></tr>
<tr class="separator:a8682a9456cf9d4ed6bbafa58e681bb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996dc865e23635a156f0af19e6e1d4b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a996dc865e23635a156f0af19e6e1d4b4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a996dc865e23635a156f0af19e6e1d4b4">get_func_details</a> (<a class="el" href="structfunc__type__data__t.html">func_type_data_t</a> *fi, <a class="el" href="typeinf_8hpp.html#ab7f0a2e39ac376a1f6e903e970e527c9">gtd_func_t</a> gtd=<a class="el" href="typeinf_8hpp.html#ab7f0a2e39ac376a1f6e903e970e527c9a5bd1413dc6a22cf8e0b2d924da8db70b">GTD_CALC_ARGLOCS</a>) const </td></tr>
<tr class="memdesc:a996dc865e23635a156f0af19e6e1d4b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get only the function specific info for this <a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information. ">tinfo_t</a>. <br /></td></tr>
<tr class="separator:a996dc865e23635a156f0af19e6e1d4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84fc95e90e4e8a1d4ee810d4c3ae8bbb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84fc95e90e4e8a1d4ee810d4c3ae8bbb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a84fc95e90e4e8a1d4ee810d4c3ae8bbb">is_funcptr</a> (void) const </td></tr>
<tr class="memdesc:a84fc95e90e4e8a1d4ee810d4c3ae8bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this pointer to a function? <br /></td></tr>
<tr class="separator:a84fc95e90e4e8a1d4ee810d4c3ae8bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27f2fbd0657501751d1e46d7f56245f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab27f2fbd0657501751d1e46d7f56245f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#ab27f2fbd0657501751d1e46d7f56245f">get_ptrarr_objsize</a> (void) const </td></tr>
<tr class="memdesc:ab27f2fbd0657501751d1e46d7f56245f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__tf__ptr.html#ga1ea9ae22535f9fb09b2c74f6e7526d4e" title="pointer. ">BT_PTR</a> &amp; <a class="el" href="group__tf__array.html#ga8c17124d38e796e7cd8804808e4bb5b3" title="array ">BT_ARRAY</a>: get size of pointed object or array element. On error returns -1 <br /></td></tr>
<tr class="separator:ab27f2fbd0657501751d1e46d7f56245f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95a2d0673d45449c180b37054cdcd44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtinfo__t.html">tinfo_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#af95a2d0673d45449c180b37054cdcd44">get_ptrarr_object</a> (void) const </td></tr>
<tr class="memdesc:af95a2d0673d45449c180b37054cdcd44"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__tf__ptr.html#ga1ea9ae22535f9fb09b2c74f6e7526d4e" title="pointer. ">BT_PTR</a> &amp; <a class="el" href="group__tf__array.html#ga8c17124d38e796e7cd8804808e4bb5b3" title="array ">BT_ARRAY</a>: get the pointed object or array element.  <a href="#af95a2d0673d45449c180b37054cdcd44">More...</a><br /></td></tr>
<tr class="separator:af95a2d0673d45449c180b37054cdcd44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab572c0ccd60df3f5414c133859f7c98a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtinfo__t.html">tinfo_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#ab572c0ccd60df3f5414c133859f7c98a">get_pointed_object</a> (void) const </td></tr>
<tr class="memdesc:ab572c0ccd60df3f5414c133859f7c98a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__tf__ptr.html#ga1ea9ae22535f9fb09b2c74f6e7526d4e" title="pointer. ">BT_PTR</a>: get type of pointed object.  <a href="#ab572c0ccd60df3f5414c133859f7c98a">More...</a><br /></td></tr>
<tr class="separator:ab572c0ccd60df3f5414c133859f7c98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a713995fa5352243be9b6138e9fd77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24a713995fa5352243be9b6138e9fd77"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a24a713995fa5352243be9b6138e9fd77">is_pvoid</a> (void) const </td></tr>
<tr class="memdesc:a24a713995fa5352243be9b6138e9fd77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is "void *"?. This function does not check the pointer attributes and type modifiers. <br /></td></tr>
<tr class="separator:a24a713995fa5352243be9b6138e9fd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f5859014ef22f444d1849373f03648"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0f5859014ef22f444d1849373f03648"></a>
<a class="el" href="classtinfo__t.html">tinfo_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#ab0f5859014ef22f444d1849373f03648">get_array_element</a> (void) const </td></tr>
<tr class="memdesc:ab0f5859014ef22f444d1849373f03648"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__tf__array.html#ga8c17124d38e796e7cd8804808e4bb5b3" title="array ">BT_ARRAY</a>: get type of array element. See also <a class="el" href="classtinfo__t.html#af95a2d0673d45449c180b37054cdcd44" title="BT_PTR & BT_ARRAY: get the pointed object or array element. ">get_ptrarr_object()</a> <br /></td></tr>
<tr class="separator:ab0f5859014ef22f444d1849373f03648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da75b0bdbeb396e495d9b264c010032"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6da75b0bdbeb396e495d9b264c010032"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a6da75b0bdbeb396e495d9b264c010032">get_array_nelems</a> (void) const </td></tr>
<tr class="memdesc:a6da75b0bdbeb396e495d9b264c010032"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__tf__array.html#ga8c17124d38e796e7cd8804808e4bb5b3" title="array ">BT_ARRAY</a>: get number of elements (-1 means error) <br /></td></tr>
<tr class="separator:a6da75b0bdbeb396e495d9b264c010032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68822722376263853ae876cb5a0c2cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac68822722376263853ae876cb5a0c2cc"></a>
<a class="el" href="classtinfo__t.html">tinfo_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#ac68822722376263853ae876cb5a0c2cc">get_nth_arg</a> (int n) const </td></tr>
<tr class="memdesc:ac68822722376263853ae876cb5a0c2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__tf__func.html#ga7b7fee21f21237beb6d91e854410e0fa" title="function. ">BT_FUNC</a> or <a class="el" href="group__tf__ptr.html#ga1ea9ae22535f9fb09b2c74f6e7526d4e" title="pointer. ">BT_PTR</a> <a class="el" href="group__tf__func.html#ga7b7fee21f21237beb6d91e854410e0fa" title="function. ">BT_FUNC</a>: Get type of n-th arg (-1 means return type, see <a class="el" href="classtinfo__t.html#aa7313852a764be8768fff62c10567ff8" title="BT_FUNC or BT_PTR BT_FUNC: Get the function&#39;s return type ">get_rettype()</a>) <br /></td></tr>
<tr class="separator:ac68822722376263853ae876cb5a0c2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7313852a764be8768fff62c10567ff8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7313852a764be8768fff62c10567ff8"></a>
<a class="el" href="classtinfo__t.html">tinfo_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#aa7313852a764be8768fff62c10567ff8">get_rettype</a> (void) const </td></tr>
<tr class="memdesc:aa7313852a764be8768fff62c10567ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__tf__func.html#ga7b7fee21f21237beb6d91e854410e0fa" title="function. ">BT_FUNC</a> or <a class="el" href="group__tf__ptr.html#ga1ea9ae22535f9fb09b2c74f6e7526d4e" title="pointer. ">BT_PTR</a> <a class="el" href="group__tf__func.html#ga7b7fee21f21237beb6d91e854410e0fa" title="function. ">BT_FUNC</a>: Get the function's return type <br /></td></tr>
<tr class="separator:aa7313852a764be8768fff62c10567ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3cb52bbe82dc6466ad9b67ff89fa46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a3cb52bbe82dc6466ad9b67ff89fa46"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a8a3cb52bbe82dc6466ad9b67ff89fa46">get_nargs</a> (void) const </td></tr>
<tr class="memdesc:a8a3cb52bbe82dc6466ad9b67ff89fa46"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__tf__func.html#ga7b7fee21f21237beb6d91e854410e0fa" title="function. ">BT_FUNC</a> or <a class="el" href="group__tf__ptr.html#ga1ea9ae22535f9fb09b2c74f6e7526d4e" title="pointer. ">BT_PTR</a> <a class="el" href="group__tf__func.html#ga7b7fee21f21237beb6d91e854410e0fa" title="function. ">BT_FUNC</a>: Calculate number of arguments (-1 - error) <br /></td></tr>
<tr class="separator:a8a3cb52bbe82dc6466ad9b67ff89fa46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586079fc1f3d50d584b17b87cf5a34be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a586079fc1f3d50d584b17b87cf5a34be"></a>
<a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9">cm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a586079fc1f3d50d584b17b87cf5a34be">get_cc</a> (void) const </td></tr>
<tr class="memdesc:a586079fc1f3d50d584b17b87cf5a34be"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__tf__func.html#ga7b7fee21f21237beb6d91e854410e0fa" title="function. ">BT_FUNC</a> or <a class="el" href="group__tf__ptr.html#ga1ea9ae22535f9fb09b2c74f6e7526d4e" title="pointer. ">BT_PTR</a> <a class="el" href="group__tf__func.html#ga7b7fee21f21237beb6d91e854410e0fa" title="function. ">BT_FUNC</a>: Get calling convention <br /></td></tr>
<tr class="separator:a586079fc1f3d50d584b17b87cf5a34be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad988d01dd6a07cfec8207cffbdb2f359"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad988d01dd6a07cfec8207cffbdb2f359"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#ad988d01dd6a07cfec8207cffbdb2f359">is_user_cc</a> (void) const </td></tr>
<tr class="memdesc:ad988d01dd6a07cfec8207cffbdb2f359"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#ae03a1134c9f208dcfccc1ce88ee8f8b0">is_user_cc</a>(<a class="el" href="classtinfo__t.html#a586079fc1f3d50d584b17b87cf5a34be" title="BT_FUNC or BT_PTR BT_FUNC: Get calling convention ">get_cc()</a>) <br /></td></tr>
<tr class="separator:ad988d01dd6a07cfec8207cffbdb2f359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4731cbab7a2e906ebd405cfa857552c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4731cbab7a2e906ebd405cfa857552c2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a4731cbab7a2e906ebd405cfa857552c2">is_vararg_cc</a> (void) const </td></tr>
<tr class="memdesc:a4731cbab7a2e906ebd405cfa857552c2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a1f176ed40797c64c31673cab8a8e3dfa">is_vararg_cc</a>(<a class="el" href="classtinfo__t.html#a586079fc1f3d50d584b17b87cf5a34be" title="BT_FUNC or BT_PTR BT_FUNC: Get calling convention ">get_cc()</a>) <br /></td></tr>
<tr class="separator:a4731cbab7a2e906ebd405cfa857552c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e5dbb432df770f1b4ec27025c93635"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6e5dbb432df770f1b4ec27025c93635"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#af6e5dbb432df770f1b4ec27025c93635">is_purging_cc</a> (void) const </td></tr>
<tr class="memdesc:af6e5dbb432df770f1b4ec27025c93635"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="typeinf_8hpp.html#a0a5c9be4004fe43ea3946b8aea40c0ba">is_purging_cc</a>(<a class="el" href="classtinfo__t.html#a586079fc1f3d50d584b17b87cf5a34be" title="BT_FUNC or BT_PTR BT_FUNC: Get calling convention ">get_cc()</a>) <br /></td></tr>
<tr class="separator:af6e5dbb432df770f1b4ec27025c93635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12770f9e906a90edfa10a13d99f59e77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12770f9e906a90edfa10a13d99f59e77"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a12770f9e906a90edfa10a13d99f59e77">calc_purged_bytes</a> (void) const </td></tr>
<tr class="memdesc:a12770f9e906a90edfa10a13d99f59e77"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__tf__func.html#ga7b7fee21f21237beb6d91e854410e0fa" title="function. ">BT_FUNC</a>: Calculate number of purged bytes <br /></td></tr>
<tr class="separator:a12770f9e906a90edfa10a13d99f59e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f53a7ce844dd534f9b2909a5f9b596"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7f53a7ce844dd534f9b2909a5f9b596"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#af7f53a7ce844dd534f9b2909a5f9b596">is_high_func</a> (void) const </td></tr>
<tr class="memdesc:af7f53a7ce844dd534f9b2909a5f9b596"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__tf__func.html#ga7b7fee21f21237beb6d91e854410e0fa" title="function. ">BT_FUNC</a>: Is high level type? <br /></td></tr>
<tr class="separator:af7f53a7ce844dd534f9b2909a5f9b596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5afe40415029bbab65ab468ed294d8de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a5afe40415029bbab65ab468ed294d8de">find_udt_member</a> (int strmem_flags, struct <a class="el" href="structudt__member__t.html">udt_member_t</a> *udm) const </td></tr>
<tr class="memdesc:a5afe40415029bbab65ab468ed294d8de"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__tf__shortcuts.html#ga861f45bbf58b9d699897e234b0905009" title="struct ">BTF_STRUCT</a>,<a class="el" href="group__tf__shortcuts.html#ga0a5536b8782826bb2b925fc65c49788c" title="union ">BTF_UNION</a>: Find a udt member.  <a href="#a5afe40415029bbab65ab468ed294d8de">More...</a><br /></td></tr>
<tr class="separator:a5afe40415029bbab65ab468ed294d8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453b7189c545cd74ec9531da85f1fa3e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a453b7189c545cd74ec9531da85f1fa3e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a453b7189c545cd74ec9531da85f1fa3e">get_udt_nmembers</a> (void) const </td></tr>
<tr class="memdesc:a453b7189c545cd74ec9531da85f1fa3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of udt members. -1-error. <br /></td></tr>
<tr class="separator:a453b7189c545cd74ec9531da85f1fa3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5711106d2e8fea693ca609496134a609"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5711106d2e8fea693ca609496134a609"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a5711106d2e8fea693ca609496134a609">is_empty_udt</a> (void) const </td></tr>
<tr class="memdesc:a5711106d2e8fea693ca609496134a609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is an empty struct/union? (has no fields) <br /></td></tr>
<tr class="separator:a5711106d2e8fea693ca609496134a609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2392dd9608e30ef0c6794b3a6da7a32c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2392dd9608e30ef0c6794b3a6da7a32c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a2392dd9608e30ef0c6794b3a6da7a32c">is_small_udt</a> (void) const </td></tr>
<tr class="memdesc:a2392dd9608e30ef0c6794b3a6da7a32c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a small udt? (can fit a register or a pair of registers) <br /></td></tr>
<tr class="separator:a2392dd9608e30ef0c6794b3a6da7a32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d305e2e58f7f9091cdfbfa84a5052a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d305e2e58f7f9091cdfbfa84a5052a5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a5d305e2e58f7f9091cdfbfa84a5052a5">is_one_fpval</a> (void) const </td></tr>
<tr class="memdesc:a5d305e2e58f7f9091cdfbfa84a5052a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Floating value or an object consisting of one floating member entirely. <br /></td></tr>
<tr class="separator:a5d305e2e58f7f9091cdfbfa84a5052a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4501111816ea4b0926722624113cb7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4501111816ea4b0926722624113cb7b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#ae4501111816ea4b0926722624113cb7b">is_sse_type</a> (void) const </td></tr>
<tr class="memdesc:ae4501111816ea4b0926722624113cb7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a SSE vector type? <br /></td></tr>
<tr class="separator:ae4501111816ea4b0926722624113cb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0713634d4617d614740a5bb7e9876d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0713634d4617d614740a5bb7e9876d8"></a>
<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#ae0713634d4617d614740a5bb7e9876d8">get_enum_base_type</a> (void) const </td></tr>
<tr class="memdesc:ae0713634d4617d614740a5bb7e9876d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get enum base type (convert enum to integer type) Returns <a class="el" href="group__tf__unk.html#ga9c2f460ca1ce121f26cf35a2fd56435c" title="unknown ">BT_UNK</a> if failed to convert. <br /></td></tr>
<tr class="separator:ae0713634d4617d614740a5bb7e9876d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0c3d9348fe217e6d818d9b0a6a14ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d0c3d9348fe217e6d818d9b0a6a14ee"></a>
<a class="el" href="classtinfo__t.html">tinfo_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a8d0c3d9348fe217e6d818d9b0a6a14ee">get_onemember_type</a> (void) const </td></tr>
<tr class="memdesc:a8d0c3d9348fe217e6d818d9b0a6a14ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">For objects consisting of one member entirely: return type of the member. <br /></td></tr>
<tr class="separator:a8d0c3d9348fe217e6d818d9b0a6a14ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd70e435ae61cf1c03a736003f7c090"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2cd70e435ae61cf1c03a736003f7c090"></a>
<a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a2cd70e435ae61cf1c03a736003f7c090">calc_score</a> (void) const </td></tr>
<tr class="memdesc:a2cd70e435ae61cf1c03a736003f7c090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the type score (the higher - the nicer is the type) <br /></td></tr>
<tr class="separator:a2cd70e435ae61cf1c03a736003f7c090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe81613422e2358a5dcc637075e99327"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#abe81613422e2358a5dcc637075e99327">print</a> (<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *out, const char *name=NULL, int prtype_flags=<a class="el" href="group___p_r_t_y_p_e__.html#gab3719af59224847206f30d143bc0decb">PRTYPE_1LINE</a>, int indent=0, int cmtindent=0, const char *prefix=NULL, const char *cmt=NULL) const </td></tr>
<tr class="memdesc:abe81613422e2358a5dcc637075e99327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a C-like string representation of the type.  <a href="#abe81613422e2358a5dcc637075e99327">More...</a><br /></td></tr>
<tr class="separator:abe81613422e2358a5dcc637075e99327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109f2054ce8e945fc904dda5ce844e78"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a109f2054ce8e945fc904dda5ce844e78"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a109f2054ce8e945fc904dda5ce844e78">dstr</a> (void) const </td></tr>
<tr class="memdesc:a109f2054ce8e945fc904dda5ce844e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to facilitate debugging. <br /></td></tr>
<tr class="separator:a109f2054ce8e945fc904dda5ce844e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6ec535bd029828307a11a4d6b1b23b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac6ec535bd029828307a11a4d6b1b23b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#aac6ec535bd029828307a11a4d6b1b23b">get_attrs</a> (<a class="el" href="group__tattr__ext.html#ga59ddf13221681bc7444911f100dc5f5b">type_attrs_t</a> *tav, bool all_attrs=false) const </td></tr>
<tr class="memdesc:aac6ec535bd029828307a11a4d6b1b23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get type attributes (all_attrs: include attributes of referenced types, if any) <br /></td></tr>
<tr class="separator:aac6ec535bd029828307a11a4d6b1b23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add919d2b661153cb6bd8eba1f0d3f856"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add919d2b661153cb6bd8eba1f0d3f856"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#add919d2b661153cb6bd8eba1f0d3f856">get_attr</a> (const <a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> &amp;key, <a class="el" href="classbytevec__t.html">bytevec_t</a> *bv, bool all_attrs=true) const </td></tr>
<tr class="memdesc:add919d2b661153cb6bd8eba1f0d3f856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a type attribute. <br /></td></tr>
<tr class="separator:add919d2b661153cb6bd8eba1f0d3f856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106c7cff2f3378b063d22ecf8bf4c21f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a106c7cff2f3378b063d22ecf8bf4c21f">set_attrs</a> (<a class="el" href="group__tattr__ext.html#ga59ddf13221681bc7444911f100dc5f5b">type_attrs_t</a> *tav)</td></tr>
<tr class="memdesc:a106c7cff2f3378b063d22ecf8bf4c21f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set type attributes.  <a href="#a106c7cff2f3378b063d22ecf8bf4c21f">More...</a><br /></td></tr>
<tr class="separator:a106c7cff2f3378b063d22ecf8bf4c21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad597870648531d77456f6eb0ba6fa898"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad597870648531d77456f6eb0ba6fa898"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#ad597870648531d77456f6eb0ba6fa898">set_attr</a> (const <a class="el" href="structtype__attr__t.html">type_attr_t</a> &amp;ta, bool may_overwrite=true)</td></tr>
<tr class="memdesc:ad597870648531d77456f6eb0ba6fa898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a type attribute. If necessary, a new typid will be created. <br /></td></tr>
<tr class="separator:ad597870648531d77456f6eb0ba6fa898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff7a84e3cd0e2314a5217d8c7f7d414"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acff7a84e3cd0e2314a5217d8c7f7d414"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#acff7a84e3cd0e2314a5217d8c7f7d414">del_attrs</a> (void)</td></tr>
<tr class="memdesc:acff7a84e3cd0e2314a5217d8c7f7d414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Del all type attributes. typerefs can not be modified by this function. <br /></td></tr>
<tr class="separator:acff7a84e3cd0e2314a5217d8c7f7d414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb00dd5186e339bb905197566c3f3f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fb00dd5186e339bb905197566c3f3f5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a8fb00dd5186e339bb905197566c3f3f5">del_attr</a> (const <a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> &amp;key)</td></tr>
<tr class="memdesc:a8fb00dd5186e339bb905197566c3f3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Del a type attribute. typerefs can not be modified by this function. <br /></td></tr>
<tr class="separator:a8fb00dd5186e339bb905197566c3f3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c39ded1425fd684bbd10aadadecbf3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c39ded1425fd684bbd10aadadecbf3c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>create_simple_type</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> decl_type)</td></tr>
<tr class="separator:a3c39ded1425fd684bbd10aadadecbf3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94fdaa43690220455bf8c66d509901d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94fdaa43690220455bf8c66d509901d9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>create_ptr</b> (const <a class="el" href="structptr__type__data__t.html">ptr_type_data_t</a> &amp;p, <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> decl_type=<a class="el" href="group__tf__ptr.html#ga1ea9ae22535f9fb09b2c74f6e7526d4e">BT_PTR</a>)</td></tr>
<tr class="separator:a94fdaa43690220455bf8c66d509901d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06f1d06145f4511e0b55c41721b8b95"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa06f1d06145f4511e0b55c41721b8b95"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>create_array</b> (const <a class="el" href="structarray__type__data__t.html">array_type_data_t</a> &amp;p, <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> decl_type=<a class="el" href="group__tf__array.html#ga8c17124d38e796e7cd8804808e4bb5b3">BT_ARRAY</a>)</td></tr>
<tr class="separator:aa06f1d06145f4511e0b55c41721b8b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891a1ec386b75abc4b1f61003f14d1cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a891a1ec386b75abc4b1f61003f14d1cc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>create_bitfield</b> (const <a class="el" href="structbitfield__type__data__t.html">bitfield_type_data_t</a> &amp;p, <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> decl_type=<a class="el" href="group__tf__complex.html#ga0d1af452c81ac917f9eab9d456f52454">BT_BITFIELD</a>)</td></tr>
<tr class="separator:a891a1ec386b75abc4b1f61003f14d1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7c405d071d6cfdb016b6add0519af0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b7c405d071d6cfdb016b6add0519af0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>create_typedef</b> (const <a class="el" href="structtypedef__type__data__t.html">typedef_type_data_t</a> &amp;p, <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> decl_type=<a class="el" href="group__tf__shortcuts.html#ga64e49eed2f4e754689e7bcc7f6efdd74">BTF_TYPEDEF</a>, bool try_ordinal=true)</td></tr>
<tr class="separator:a0b7c405d071d6cfdb016b6add0519af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb7d81ecc87f345a91d97e82b206ba5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a5cb7d81ecc87f345a91d97e82b206ba5">create_forward_decl</a> (<a class="el" href="structtil__t.html">til_t</a> *til, <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> decl_type, const char *name, int ntf_flags=0)</td></tr>
<tr class="memdesc:a5cb7d81ecc87f345a91d97e82b206ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a forward declaration.  <a href="#a5cb7d81ecc87f345a91d97e82b206ba5">More...</a><br /></td></tr>
<tr class="separator:a5cb7d81ecc87f345a91d97e82b206ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc16bd8b4daae27c4c22d61c8a45d152"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#adc16bd8b4daae27c4c22d61c8a45d152">convert_array_to_ptr</a> (void)</td></tr>
<tr class="memdesc:adc16bd8b4daae27c4c22d61c8a45d152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an array into a pointer.  <a href="#adc16bd8b4daae27c4c22d61c8a45d152">More...</a><br /></td></tr>
<tr class="separator:adc16bd8b4daae27c4c22d61c8a45d152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb42b27e21d234c407f95dd27165e89"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a3cb42b27e21d234c407f95dd27165e89">remove_ptr_or_array</a> (void)</td></tr>
<tr class="memdesc:a3cb42b27e21d234c407f95dd27165e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the current type with the ptr obj or array element.  <a href="#a3cb42b27e21d234c407f95dd27165e89">More...</a><br /></td></tr>
<tr class="separator:a3cb42b27e21d234c407f95dd27165e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8418938eb1d54a8c1e9616e7171727b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8418938eb1d54a8c1e9616e7171727b3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a8418938eb1d54a8c1e9616e7171727b3">change_sign</a> (<a class="el" href="group__tattr__ext.html#ga91970b0d779fe968b3b22572526048a0">type_sign_t</a> sign)</td></tr>
<tr class="memdesc:a8418938eb1d54a8c1e9616e7171727b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the type sign. Works only for the types that may have sign. <br /></td></tr>
<tr class="separator:a8418938eb1d54a8c1e9616e7171727b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404a4599458c447010359561654c6374"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a404a4599458c447010359561654c6374"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a404a4599458c447010359561654c6374">calc_udt_aligns</a> (int sudt_flags=<a class="el" href="group___s_u_d_t__.html#gac25d2bd3d8185187ceae4cc16f4cc3dc">SUDT_GAPS</a>)</td></tr>
<tr class="memdesc:a404a4599458c447010359561654c6374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the udt alignments using the field offsets/sizes and the total udt size This function does not work on typerefs. <br /></td></tr>
<tr class="separator:a404a4599458c447010359561654c6374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2c31527ec118b88c3868ab81eb895f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d2c31527ec118b88c3868ab81eb895f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a4d2c31527ec118b88c3868ab81eb895f">compare_with</a> (const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;r, int tcflags=0) const </td></tr>
<tr class="memdesc:a4d2c31527ec118b88c3868ab81eb895f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two types, based on given flags (see <a class="el" href="group___t_c_m_p__.html">tinfo_t comparison flags</a>) <br /></td></tr>
<tr class="separator:a4d2c31527ec118b88c3868ab81eb895f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae42f64ff82b2837d864c8fb6b0ad63d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae42f64ff82b2837d864c8fb6b0ad63d9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>equals_to</b> (const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;r) const </td></tr>
<tr class="separator:ae42f64ff82b2837d864c8fb6b0ad63d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67e22a20db73a94d0aa1974f67277e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac67e22a20db73a94d0aa1974f67277e3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_castable_to</b> (const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;target) const </td></tr>
<tr class="separator:ac67e22a20db73a94d0aa1974f67277e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8adfbd2e60ba08b214177033098413d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8adfbd2e60ba08b214177033098413d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_manually_castable_to</b> (const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;target) const </td></tr>
<tr class="separator:af8adfbd2e60ba08b214177033098413d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Convenience functions</div></td></tr>
<tr class="memitem:aa72f7a017b31ff59075fc783c0762534"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa72f7a017b31ff59075fc783c0762534"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>create_ptr</b> (const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;tif, <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> bps=0, <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> decl_type=<a class="el" href="group__tf__ptr.html#ga1ea9ae22535f9fb09b2c74f6e7526d4e">BT_PTR</a>)</td></tr>
<tr class="separator:aa72f7a017b31ff59075fc783c0762534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8a38b2aed3d5725621cd4107e1cc87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa8a38b2aed3d5725621cd4107e1cc87"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>create_array</b> (const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;tif, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> nelems=0, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> base=0, <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> decl_type=<a class="el" href="group__tf__array.html#ga8c17124d38e796e7cd8804808e4bb5b3">BT_ARRAY</a>)</td></tr>
<tr class="separator:afa8a38b2aed3d5725621cd4107e1cc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79838704f9bd2dedb07727e2bdbed0ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79838704f9bd2dedb07727e2bdbed0ce"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>create_typedef</b> (const <a class="el" href="structtil__t.html">til_t</a> *til, const char *name, <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> decl_type=<a class="el" href="group__tf__shortcuts.html#ga64e49eed2f4e754689e7bcc7f6efdd74">BTF_TYPEDEF</a>, bool try_ordinal=true)</td></tr>
<tr class="separator:a79838704f9bd2dedb07727e2bdbed0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4284469cc80e2dd267f2736fc900e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a4284469cc80e2dd267f2736fc900e2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>create_typedef</b> (const <a class="el" href="structtil__t.html">til_t</a> *til, <a class="el" href="pro_8h.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> ord, <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> decl_type=<a class="el" href="group__tf__shortcuts.html#ga64e49eed2f4e754689e7bcc7f6efdd74">BTF_TYPEDEF</a>)</td></tr>
<tr class="separator:a0a4284469cc80e2dd267f2736fc900e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c67e6873c0d3225fc57a1114a893dd3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c67e6873c0d3225fc57a1114a893dd3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>create_bitfield</b> (<a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> nbytes, <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> width, bool <a class="el" href="classtinfo__t.html#a79c7daf8522e6e695734036ca056ac7f">is_unsigned</a>=false, <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> decl_type=<a class="el" href="group__tf__complex.html#ga0d1af452c81ac917f9eab9d456f52454">BT_BITFIELD</a>)</td></tr>
<tr class="separator:a0c67e6873c0d3225fc57a1114a893dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Warning</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions consume 'p' (make it empty) </p>
</div></td></tr>
<tr class="memitem:a820e592715ad2c100174bb5164273485"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a820e592715ad2c100174bb5164273485"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>create_udt</b> (<a class="el" href="structudt__type__data__t.html">udt_type_data_t</a> &amp;p, <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> decl_type)</td></tr>
<tr class="separator:a820e592715ad2c100174bb5164273485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1038754a7d0ae27c9733cf3be27d4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c1038754a7d0ae27c9733cf3be27d4a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>create_enum</b> (<a class="el" href="structenum__type__data__t.html">enum_type_data_t</a> &amp;p, <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> decl_type=<a class="el" href="group__tf__shortcuts.html#ga5eee5573060ab34fdee9230f37d8369f">BTF_ENUM</a>)</td></tr>
<tr class="separator:a5c1038754a7d0ae27c9733cf3be27d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb43d328a2b75f030f95cda543580f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bb43d328a2b75f030f95cda543580f3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>create_func</b> (<a class="el" href="structfunc__type__data__t.html">func_type_data_t</a> &amp;p, <a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> decl_type=<a class="el" href="group__tf__func.html#ga7b7fee21f21237beb6d91e854410e0fa">BT_FUNC</a>)</td></tr>
<tr class="separator:a7bb43d328a2b75f030f95cda543580f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Store type</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Store the type info in the type library as a named or numbered type.</p>
<p>The <a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information. ">tinfo_t</a> object will be replaced by a reference to the created type. Allowed bits for ntf_flags: <a class="el" href="group___n_t_f__.html#ga59f1cf2eee24fa287b41be608cd5c82e" title="don&#39;t inspect base tils (for get_named_type) ">NTF_NOBASE</a>, <a class="el" href="group___n_t_f__.html#ga99d425180386ad9f256f191e88ff1ffe" title="replace original type (for set_named_type) ">NTF_REPLACE</a> </p>
</div></td></tr>
<tr class="memitem:a0f3f0f6661b62e761a527a28ab479f15"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f3f0f6661b62e761a527a28ab479f15"></a>
<a class="el" href="typeinf_8hpp.html#a4b2c98771820db5f78f2e754c97c0aaa">tinfo_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>set_named_type</b> (<a class="el" href="structtil__t.html">til_t</a> *til, const char *name, int ntf_flags=0)</td></tr>
<tr class="separator:a0f3f0f6661b62e761a527a28ab479f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e91dbe8b03015175516ad0c3462a0cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e91dbe8b03015175516ad0c3462a0cc"></a>
<a class="el" href="typeinf_8hpp.html#a4b2c98771820db5f78f2e754c97c0aaa">tinfo_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>set_numbered_type</b> (<a class="el" href="structtil__t.html">til_t</a> *til, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> ord, int ntf_flags=0, const char *name=NULL)</td></tr>
<tr class="separator:a8e91dbe8b03015175516ad0c3462a0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Bitfields</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Helper functions to store/extract bitfield values </p>
</div></td></tr>
<tr class="memitem:ab1342067025184aa78323236808ff57f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1342067025184aa78323236808ff57f"></a>
<a class="el" href="pro_8h.html#a2f5563986d7f95e4fad5876c17d9cdda">uint64</a>&#160;</td><td class="memItemRight" valign="bottom"><b>read_bitfield_value</b> (<a class="el" href="pro_8h.html#a2f5563986d7f95e4fad5876c17d9cdda">uint64</a> v, int bitoff) const </td></tr>
<tr class="separator:ab1342067025184aa78323236808ff57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16bda400e6056e25cb5eb4bd16295ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac16bda400e6056e25cb5eb4bd16295ab"></a>
<a class="el" href="pro_8h.html#a2f5563986d7f95e4fad5876c17d9cdda">uint64</a>&#160;</td><td class="memItemRight" valign="bottom"><b>write_bitfield_value</b> (<a class="el" href="pro_8h.html#a2f5563986d7f95e4fad5876c17d9cdda">uint64</a> dst, <a class="el" href="pro_8h.html#a2f5563986d7f95e4fad5876c17d9cdda">uint64</a> v, int bitoff) const </td></tr>
<tr class="separator:ac16bda400e6056e25cb5eb4bd16295ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modifiers</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Work with type modifiers: const and volatile </p>
</div></td></tr>
<tr class="memitem:a5a10e970d2d758f72bc246b24cecd964"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a10e970d2d758f72bc246b24cecd964"></a>
<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_modifiers</b> (void) const </td></tr>
<tr class="separator:a5a10e970d2d758f72bc246b24cecd964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d32224716addb74e18f826fd39582d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d32224716addb74e18f826fd39582d9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_modifiers</b> (<a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> mod)</td></tr>
<tr class="separator:a1d32224716addb74e18f826fd39582d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b99a37eae3326ee35428b8d9e177ad9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b99a37eae3326ee35428b8d9e177ad9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_const</b> (void)</td></tr>
<tr class="separator:a4b99a37eae3326ee35428b8d9e177ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c02cc5ea5cf634be45d88e12ae70ab7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c02cc5ea5cf634be45d88e12ae70ab7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_volatile</b> (void)</td></tr>
<tr class="separator:a5c02cc5ea5cf634be45d88e12ae70ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56b7d0fe4ea528ac2eb1a66a95d1837"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af56b7d0fe4ea528ac2eb1a66a95d1837"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clr_const</b> (void)</td></tr>
<tr class="separator:af56b7d0fe4ea528ac2eb1a66a95d1837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2560bc846f1796718f4658fb96c1b7d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2560bc846f1796718f4658fb96c1b7d6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clr_volatile</b> (void)</td></tr>
<tr class="separator:a2560bc846f1796718f4658fb96c1b7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c21a7505878b59404ad216cef4600e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6c21a7505878b59404ad216cef4600e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clr_const_volatile</b> (void)</td></tr>
<tr class="separator:ad6c21a7505878b59404ad216cef4600e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1d2ed4241b0ee9fa2d8c5b7269cad74d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtinfo__t.html">tinfo_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a1d2ed4241b0ee9fa2d8c5b7269cad74d">get_stock</a> (<a class="el" href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211">stock_type_id_t</a> id)</td></tr>
<tr class="memdesc:a1d2ed4241b0ee9fa2d8c5b7269cad74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get stock type information.  <a href="#a1d2ed4241b0ee9fa2d8c5b7269cad74d">More...</a><br /></td></tr>
<tr class="separator:a1d2ed4241b0ee9fa2d8c5b7269cad74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a4c01dbfdf500bee5e04900a0faba7ae8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c01dbfdf500bee5e04900a0faba7ae8"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>type_detail_t</b></td></tr>
<tr class="separator:a4c01dbfdf500bee5e04900a0faba7ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a197fc9ead77f71f0286b2be85e29fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtinfo__t.html">tinfo_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtinfo__t.html#a4a197fc9ead77f71f0286b2be85e29fa">remove_pointer</a> (const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;tif)</td></tr>
<tr class="memdesc:a4a197fc9ead77f71f0286b2be85e29fa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__tf__ptr.html#ga1ea9ae22535f9fb09b2c74f6e7526d4e" title="pointer. ">BT_PTR</a>: If the current type is a pointer, return the pointed object.  <a href="#a4a197fc9ead77f71f0286b2be85e29fa">More...</a><br /></td></tr>
<tr class="separator:a4a197fc9ead77f71f0286b2be85e29fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8d412272832b545ffdf4019e736ff7b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tinfo_t::get_named_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>til</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td>
          <td class="paramname"><em>decl_type</em> = <code><a class="el" href="group__tf__shortcuts.html#ga64e49eed2f4e754689e7bcc7f6efdd74">BTF_TYPEDEF</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resolve</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>try_ordinal</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information. ">tinfo_t</a> object for an existing named type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">til</td><td>type library to use </td></tr>
    <tr><td class="paramname">name</td><td>name of the type to link to </td></tr>
    <tr><td class="paramname">decl_type</td><td>if the reference was explicitly specified with the type tag <br />
 (<a class="el" href="group__tf__shortcuts.html#ga861f45bbf58b9d699897e234b0905009" title="struct ">BTF_STRUCT</a>/<a class="el" href="group__tf__shortcuts.html#ga0a5536b8782826bb2b925fc65c49788c" title="union ">BTF_UNION</a>/<a class="el" href="group__tf__shortcuts.html#ga5eee5573060ab34fdee9230f37d8369f" title="enum ">BTF_ENUM</a>) you may specify it. <br />
 the kernel will accept only the specified tag after resolving <br />
 the type. If the resolved type does not correspond to the <br />
 explicitly specified tag, the type will be considered as undefined <br />
</td></tr>
    <tr><td class="paramname">resolve</td><td>true: immediately resolve the type and return success code. false: return true but do not immediately resolve the type </td></tr>
    <tr><td class="paramname">try_ordinal</td><td>true: try to replace name reference by an ordinal reference </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a86a0edf6c7baed76c657aee40e431572"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tinfo_t::get_numbered_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>til</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td>
          <td class="paramname"><em>ordinal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td>
          <td class="paramname"><em>decl_type</em> = <code><a class="el" href="group__tf__shortcuts.html#ga64e49eed2f4e754689e7bcc7f6efdd74">BTF_TYPEDEF</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>resolve</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information. ">tinfo_t</a> object for an existing ordinal type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">til</td><td>type library to use </td></tr>
    <tr><td class="paramname">ordinal</td><td>number of the type to link to </td></tr>
    <tr><td class="paramname">decl_type</td><td>if the reference was explicitly specified with the type tag (BTF_STRUCT/BTF_UNION/BTF_ENUM) you may specify it. the kernel will accept only the specified tag after resolving the type. If the resolved type does not correspond to the explicitly specified tag, the type will be considered as undefined </td></tr>
    <tr><td class="paramname">resolve</td><td>true: immediately resolve the type and return success code false: return true but do not immediately resolve the type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0bc913b2fce03d59b0ce3e1a2dfa07ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tinfo_t::deserialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>til</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="pro_8h.html#a7fad0f3973de5825c480e27517e159f3">qtype</a> *&#160;</td>
          <td class="paramname"><em>ptype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="pro_8h.html#a7fad0f3973de5825c480e27517e159f3">qtype</a> *&#160;</td>
          <td class="paramname"><em>pfields</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="pro_8h.html#a7fad0f3973de5825c480e27517e159f3">qtype</a> *&#160;</td>
          <td class="paramname"><em>pfldcmts</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialize a type string into a <a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information. ">tinfo_t</a> object. </p>

</div>
</div>
<a class="anchor" id="a560fccc25a67c150bddbb99013f4a847"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tinfo_t::is_correct </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the type object correct?. </p>
<p>It is possible to create incorrect types. For example, we can define a function that returns a enum and then delete the enum type. If this function returns false, the type should not be used in disassembly. Please note that this function does not verify all involved types: for example, pointers to undefined types are permitted. </p>

</div>
</div>
<a class="anchor" id="aec6b9b21fce581447232d0ca3bae4feb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> tinfo_t::get_realtype </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the resolved base type. </p>
<p>Deserialization options:</p><ul>
<li>if full=true, the referenced type will be deserialized fully, this may not always be desirable (slows down things)</li>
<li>if full=false, we just return the base type, the referenced type will be resolved again later if necessary (this may lead to multiple resolvings of the same type) imho full=false is a better approach because it does not perform unnecessary actions just in case. however, in some cases the caller knows that it is very likely that full type info will be required. in those cases full=true makes sense </li>
</ul>

</div>
</div>
<a class="anchor" id="ad49b27cb43a61932bf83045dbf0e8e20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a> tinfo_t::get_decltype </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get declared type (without resolving type references; they are returned as is). </p>
<p>Obviously this is a very fast function and should be used instead of <a class="el" href="classtinfo__t.html#aec6b9b21fce581447232d0ca3bae4feb" title="Get the resolved base type. ">get_realtype()</a> if possible. </p>

</div>
</div>
<a class="anchor" id="a85e028c207d564e387d233fc79195f9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t tinfo_t::get_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> *&#160;</td>
          <td class="paramname"><em>p_effalign</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gts_code</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the type size in bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_effalign</td><td>buffer for the alignment value </td></tr>
    <tr><td class="paramname">gts_code</td><td>combination of GTS_... constants </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="typeinf_8hpp.html#a8dfbf55f283e8e1deaf195dc2576f63d" title="bad type size ">BADSIZE</a> in case of problems </dd></dl>

</div>
</div>
<a class="anchor" id="a8b41d32a72cf765b8745500391100fad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t tinfo_t::get_unpadded_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the type size in bytes without the final padding. </p>
<p>For some UDTs <a class="el" href="classtinfo__t.html#a8b41d32a72cf765b8745500391100fad" title="Get the type size in bytes without the final padding. ">get_unpadded_size()</a> != <a class="el" href="classtinfo__t.html#a85e028c207d564e387d233fc79195f9a" title="Get the type size in bytes. ">get_size()</a> </p>

</div>
</div>
<a class="anchor" id="aaf258b6e0e8103697118b762fa6fd1ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tinfo_t::is_typeref </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this type a type reference?. </p>
<p>Type references can not be modified. Once created, they do not change. Because of this, the set_... functions applied to typerefs create a new type id. Other types are modified directly. </p>

</div>
</div>
<a class="anchor" id="a84af273ca27a03a5b81e09fe5d56f2cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tinfo_t::get_type_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does a type refer to a name?. </p>
<p>If yes, fill the provided buffer with the type name and return true. Names are returned for numbered types too: either a user-defined nice name or, if a user-provided name does not exist, an ordinal name (like #xx, see <a class="el" href="group__numbered__types.html#ga8241f6b00091189e73e14f67b662071b" title="Create anonymous name for numbered type. ">create_numbered_type_name()</a>). </p>

</div>
</div>
<a class="anchor" id="ae09bac545345c06dbf4d29c966e5523c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tinfo_t::get_final_type_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use in the case of typedef chain (TYPE1 -&gt; TYPE2 -&gt; TYPE3...TYPEn). </p>
<dl class="section return"><dt>Returns</dt><dd>the name of the last type in the chain (TYPEn). if there is no chain, returns TYPE1 </dd></dl>

</div>
</div>
<a class="anchor" id="a516a0d94c0ebd7d036bff3be7fcda383"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tinfo_t::get_next_type_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use In the case of typedef chain (TYPE1 -&gt; TYPE2 -&gt; TYPE3...TYPEn). </p>
<dl class="section return"><dt>Returns</dt><dd>the name of the next type in the chain (TYPE2). if there is no chain, returns failure </dd></dl>

</div>
</div>
<a class="anchor" id="a6c0e0873c6fae468e9928e1fb2739c9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tinfo_t::is_from_subtil </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Was the named type found in some base type library (not the top level type library)?. </p>
<p>If yes, it usually means that the type comes from some loaded type library, not the local type library for the database </p>

</div>
</div>
<a class="anchor" id="a72fa94c7b1b58690b38010d8115d8c43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tinfo_t::is_forward_decl </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this a forward declaration?. </p>
<p>Forward declarations are placeholders: the type definition does not exist </p>

</div>
</div>
<a class="anchor" id="af95a2d0673d45449c180b37054cdcd44"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtinfo__t.html">tinfo_t</a> tinfo_t::get_ptrarr_object </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="group__tf__ptr.html#ga1ea9ae22535f9fb09b2c74f6e7526d4e" title="pointer. ">BT_PTR</a> &amp; <a class="el" href="group__tf__array.html#ga8c17124d38e796e7cd8804808e4bb5b3" title="array ">BT_ARRAY</a>: get the pointed object or array element. </p>
<p>If the current type is not a pointer or array, return empty type info. </p>

</div>
</div>
<a class="anchor" id="ab572c0ccd60df3f5414c133859f7c98a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtinfo__t.html">tinfo_t</a> tinfo_t::get_pointed_object </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="group__tf__ptr.html#ga1ea9ae22535f9fb09b2c74f6e7526d4e" title="pointer. ">BT_PTR</a>: get type of pointed object. </p>
<p>If the current type is not a pointer, return empty type info. See also <a class="el" href="classtinfo__t.html#af95a2d0673d45449c180b37054cdcd44" title="BT_PTR & BT_ARRAY: get the pointed object or array element. ">get_ptrarr_object()</a> and <a class="el" href="classtinfo__t.html#a4a197fc9ead77f71f0286b2be85e29fa" title="BT_PTR: If the current type is a pointer, return the pointed object. ">remove_pointer()</a> </p>

</div>
</div>
<a class="anchor" id="a5afe40415029bbab65ab468ed294d8de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int tinfo_t::find_udt_member </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>strmem_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structudt__member__t.html">udt_member_t</a> *&#160;</td>
          <td class="paramname"><em>udm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="group__tf__shortcuts.html#ga861f45bbf58b9d699897e234b0905009" title="struct ">BTF_STRUCT</a>,<a class="el" href="group__tf__shortcuts.html#ga0a5536b8782826bb2b925fc65c49788c" title="union ">BTF_UNION</a>: Find a udt member. </p>
<ul>
<li>at the specified offset (<a class="el" href="group___s_t_r_m_e_m__.html#gafc7e55c621c65b2a81792e39a67d75b2" title="get member by offset ">STRMEM_OFFSET</a>)</li>
<li>with the specified index (<a class="el" href="group___s_t_r_m_e_m__.html#gaad91f2151cfd8e41e7f937287bf18f56" title="get member by number ">STRMEM_INDEX</a>)</li>
<li>with the specified type (<a class="el" href="group___s_t_r_m_e_m__.html#ga62e2d52ab4b1acb0ed5571b7135ee6dd" title="get member by type. ">STRMEM_TYPE</a>)</li>
<li>with the specified name (<a class="el" href="group___s_t_r_m_e_m__.html#ga8c04aa29f158d3544957d5bf9513115a" title="get member by name ">STRMEM_NAME</a>) <dl class="section return"><dt>Returns</dt><dd>the index of the found member or -1 </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="abe81613422e2358a5dcc637075e99327"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tinfo_t::print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prtype_flags</em> = <code><a class="el" href="group___p_r_t_y_p_e__.html#gab3719af59224847206f30d143bc0decb">PRTYPE_1LINE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cmtindent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cmt</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a C-like string representation of the type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>output string </td></tr>
    <tr><td class="paramname">name</td><td>name of type </td></tr>
    <tr><td class="paramname">prtype_flags</td><td><a class="el" href="group___p_r_t_y_p_e__.html">Type printing flags</a> </td></tr>
    <tr><td class="paramname">indent</td><td>structure level indent </td></tr>
    <tr><td class="paramname">cmtindent</td><td>comment indent </td></tr>
    <tr><td class="paramname">prefix</td><td>string prepended to each line </td></tr>
    <tr><td class="paramname">cmt</td><td>comment text </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a class="anchor" id="a106c7cff2f3378b063d22ecf8bf4c21f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tinfo_t::set_attrs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__tattr__ext.html#ga59ddf13221681bc7444911f100dc5f5b">type_attrs_t</a> *&#160;</td>
          <td class="paramname"><em>tav</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set type attributes. </p>
<p>If necessary, a new typid will be created. this function modifies tav! (returns old attributes, if any) </p><dl class="section return"><dt>Returns</dt><dd>false: bad attributes </dd></dl>

</div>
</div>
<a class="anchor" id="a5cb7d81ecc87f345a91d97e82b206ba5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tinfo_t::create_forward_decl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtil__t.html">til_t</a> *&#160;</td>
          <td class="paramname"><em>til</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="typeinf_8hpp.html#a7a9c029b924959e0fe4f14b3531fb733">type_t</a>&#160;</td>
          <td class="paramname"><em>decl_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ntf_flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a forward declaration. </p>
<p>decl_type: <a class="el" href="group__tf__shortcuts.html#ga861f45bbf58b9d699897e234b0905009" title="struct ">BTF_STRUCT</a>, <a class="el" href="group__tf__shortcuts.html#ga0a5536b8782826bb2b925fc65c49788c" title="union ">BTF_UNION</a>, or <a class="el" href="group__tf__shortcuts.html#ga5eee5573060ab34fdee9230f37d8369f" title="enum ">BTF_ENUM</a> </p>

</div>
</div>
<a class="anchor" id="a1d2ed4241b0ee9fa2d8c5b7269cad74d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtinfo__t.html">tinfo_t</a> tinfo_t::get_stock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="typeinf_8hpp.html#a3d5cba82dd91a1d49c2e0cdd8f5d5211">stock_type_id_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get stock type information. </p>
<p>This function can be used to get <a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information. ">tinfo_t</a> for some common types. The same <a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information. ">tinfo_t</a> will be returned for the same id, thus saving memory and increasing the speed </p>

</div>
</div>
<a class="anchor" id="adc16bd8b4daae27c4c22d61c8a45d152"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tinfo_t::convert_array_to_ptr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an array into a pointer. </p>
<p>type[] =&gt; type * </p>

</div>
</div>
<a class="anchor" id="a3cb42b27e21d234c407f95dd27165e89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tinfo_t::remove_ptr_or_array </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the current type with the ptr obj or array element. </p>
<p>This function performs one of the following conversions:</p><ul>
<li>type[] =&gt; type</li>
<li>type* =&gt; type If the conversion is performed successfully, return true </li>
</ul>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a4a197fc9ead77f71f0286b2be85e29fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtinfo__t.html">tinfo_t</a> remove_pointer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtinfo__t.html">tinfo_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tif</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="group__tf__ptr.html#ga1ea9ae22535f9fb09b2c74f6e7526d4e" title="pointer. ">BT_PTR</a>: If the current type is a pointer, return the pointed object. </p>
<p>If the current type is not a pointer, return the current type. See also <a class="el" href="classtinfo__t.html#af95a2d0673d45449c180b37054cdcd44" title="BT_PTR & BT_ARRAY: get the pointed object or array element. ">get_ptrarr_object()</a> and <a class="el" href="classtinfo__t.html#ab572c0ccd60df3f5414c133859f7c98a" title="BT_PTR: get type of pointed object. ">get_pointed_object()</a> </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="typeinf_8hpp.html">typeinf.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
