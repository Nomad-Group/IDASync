<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>IDA SDK: debugger_t Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">IDA SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="files.html"><span>Header&#160;Files</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structdebugger__t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">debugger_t Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This structure describes a debugger API module. </p>
<p>(functions needed to debug a process on a specific operating system).</p>
<p>The address of this structure must be put into the <a class="el" href="dbg_8hpp.html#a04f2054203bde05f4392b3f135a29fe3" title="This structure contains information about the current debugger. ">dbg</a> variable by the <a class="el" href="classplugin__t.html#a583b4679c40451252da5825d61ea9053" title="Initialize plugin - returns Plugin initialization codes. ">plugin_t::init()</a> function of the debugger plugin. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a05e031b463d8a3221537053bbcae1e7c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05e031b463d8a3221537053bbcae1e7c"></a>
<a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a05e031b463d8a3221537053bbcae1e7c">version</a></td></tr>
<tr class="memdesc:a05e031b463d8a3221537053bbcae1e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected kernel version, should be <a class="el" href="idd_8hpp.html#a5b46b2a423380b8fa861267e47e50875" title="The IDD interface version number. ">IDD_INTERFACE_VERSION</a>. <br /></td></tr>
<tr class="separator:a05e031b463d8a3221537053bbcae1e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fec9ee5e7dd559705c330d5e827ae1d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0fec9ee5e7dd559705c330d5e827ae1d"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a0fec9ee5e7dd559705c330d5e827ae1d">name</a></td></tr>
<tr class="memdesc:a0fec9ee5e7dd559705c330d5e827ae1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short debugger name like win32 or linux. <br /></td></tr>
<tr class="separator:a0fec9ee5e7dd559705c330d5e827ae1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5fd5700a3daf0ff646a542f87a9f0c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5fd5700a3daf0ff646a542f87a9f0c6"></a>
<a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#af5fd5700a3daf0ff646a542f87a9f0c6">id</a></td></tr>
<tr class="memdesc:af5fd5700a3daf0ff646a542f87a9f0c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">one of <a class="el" href="group___d_e_b_u_g_g_e_r___i_d__.html">Debugger API module id</a> <br /></td></tr>
<tr class="separator:af5fd5700a3daf0ff646a542f87a9f0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ad9af89799075474d046a22b511161"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a20ad9af89799075474d046a22b511161">processor</a></td></tr>
<tr class="memdesc:a20ad9af89799075474d046a22b511161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Required processor name.  <a href="#a20ad9af89799075474d046a22b511161">More...</a><br /></td></tr>
<tr class="separator:a20ad9af89799075474d046a22b511161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e27b9a06eb3abe8cfb1f681c0476f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48e27b9a06eb3abe8cfb1f681c0476f1"></a>
<a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a48e27b9a06eb3abe8cfb1f681c0476f1">flags</a></td></tr>
<tr class="memdesc:a48e27b9a06eb3abe8cfb1f681c0476f1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group___d_b_g___f_l_a_g__.html">Debugger module features</a> <br /></td></tr>
<tr class="separator:a48e27b9a06eb3abe8cfb1f681c0476f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc871213d6687057fa15d90f5498f94"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5dc871213d6687057fa15d90f5498f94"></a>
const char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a5dc871213d6687057fa15d90f5498f94">register_classes</a></td></tr>
<tr class="memdesc:a5dc871213d6687057fa15d90f5498f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of register class names. <br /></td></tr>
<tr class="separator:a5dc871213d6687057fa15d90f5498f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34956103719e1aeb80a21d1dc95151bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34956103719e1aeb80a21d1dc95151bf"></a>
<a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a34956103719e1aeb80a21d1dc95151bf">register_classes_default</a></td></tr>
<tr class="memdesc:a34956103719e1aeb80a21d1dc95151bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask of default printed register classes. <br /></td></tr>
<tr class="separator:a34956103719e1aeb80a21d1dc95151bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaafc2c07811c032051b4bfe5a892532"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acaafc2c07811c032051b4bfe5a892532"></a>
<a class="el" href="structregister__info__t.html">register_info_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#acaafc2c07811c032051b4bfe5a892532">_registers</a></td></tr>
<tr class="memdesc:acaafc2c07811c032051b4bfe5a892532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of registers. Use registers() to access it. <br /></td></tr>
<tr class="separator:acaafc2c07811c032051b4bfe5a892532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ccb54d0434ab7c6c9d1137d7773c08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38ccb54d0434ab7c6c9d1137d7773c08"></a>
<a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a38ccb54d0434ab7c6c9d1137d7773c08">registers_size</a></td></tr>
<tr class="memdesc:a38ccb54d0434ab7c6c9d1137d7773c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of registers. <br /></td></tr>
<tr class="separator:a38ccb54d0434ab7c6c9d1137d7773c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e6a92cc94a7bc3fc231e91392af589"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06e6a92cc94a7bc3fc231e91392af589"></a>
<a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a06e6a92cc94a7bc3fc231e91392af589">memory_page_size</a></td></tr>
<tr class="memdesc:a06e6a92cc94a7bc3fc231e91392af589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of a memory page. <br /></td></tr>
<tr class="separator:a06e6a92cc94a7bc3fc231e91392af589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafda41b65555061dd5a7708c6e6db45e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aafda41b65555061dd5a7708c6e6db45e"></a>
const <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#aafda41b65555061dd5a7708c6e6db45e">bpt_bytes</a></td></tr>
<tr class="memdesc:aafda41b65555061dd5a7708c6e6db45e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of bytes for a breakpoint instruction. <br /></td></tr>
<tr class="separator:aafda41b65555061dd5a7708c6e6db45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adefd175bea42a81893bad4685247daa4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adefd175bea42a81893bad4685247daa4"></a>
<a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#adefd175bea42a81893bad4685247daa4">bpt_size</a></td></tr>
<tr class="memdesc:adefd175bea42a81893bad4685247daa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of this array. <br /></td></tr>
<tr class="separator:adefd175bea42a81893bad4685247daa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8448b3972217ed077b77b362ccc69c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d8448b3972217ed077b77b362ccc69c"></a>
<a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a0d8448b3972217ed077b77b362ccc69c">filetype</a></td></tr>
<tr class="memdesc:a0d8448b3972217ed077b77b362ccc69c"><td class="mdescLeft">&#160;</td><td class="mdescRight">for miniidbs: use this value for the file type after attaching to a new process <br /></td></tr>
<tr class="separator:a0d8448b3972217ed077b77b362ccc69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ed80f2b468eb868a4c1cfcbe1d7493"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71ed80f2b468eb868a4c1cfcbe1d7493"></a>
<a class="el" href="pro_8h.html#ab95f123a6c9bcfee6a343170ef8c5f69">ushort</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a71ed80f2b468eb868a4c1cfcbe1d7493">resume_modes</a></td></tr>
<tr class="memdesc:a71ed80f2b468eb868a4c1cfcbe1d7493"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group___d_b_g___r_e_s_m_o_d__.html">Resume modes</a> <br /></td></tr>
<tr class="separator:a71ed80f2b468eb868a4c1cfcbe1d7493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75c4677f9d5a1540b56933aef5893b0"><td class="memItemLeft" align="right" valign="top">bool(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#ad75c4677f9d5a1540b56933aef5893b0">init_debugger</a> )(const char *hostname, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> portnum, const char *password)</td></tr>
<tr class="memdesc:ad75c4677f9d5a1540b56933aef5893b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize debugger.  <a href="#ad75c4677f9d5a1540b56933aef5893b0">More...</a><br /></td></tr>
<tr class="separator:ad75c4677f9d5a1540b56933aef5893b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1547d388962b406d12b28cbbbe118e13"><td class="memItemLeft" align="right" valign="top">bool(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a1547d388962b406d12b28cbbbe118e13">term_debugger</a> )(void)</td></tr>
<tr class="memdesc:a1547d388962b406d12b28cbbbe118e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminate debugger.  <a href="#a1547d388962b406d12b28cbbbe118e13">More...</a><br /></td></tr>
<tr class="separator:a1547d388962b406d12b28cbbbe118e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc188888169461c60e668bd7a3079aab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#abc188888169461c60e668bd7a3079aab">process_get_info</a> )(<a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> n, <a class="el" href="structprocess__info__t.html">process_info_t</a> *<a class="el" href="kernwin_8hpp.html#a513ff6f132e1b8ad086f0f4e69c1d612">info</a>)</td></tr>
<tr class="memdesc:abc188888169461c60e668bd7a3079aab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return information about the n-th "compatible" running process.  <a href="#abc188888169461c60e668bd7a3079aab">More...</a><br /></td></tr>
<tr class="separator:abc188888169461c60e668bd7a3079aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad769e0328d77bf1186f4d2a657f9cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a4ad769e0328d77bf1186f4d2a657f9cf">start_process</a> )(const char *path, const char *args, const char *startdir, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> dbg_proc_flags, const char *input_path, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> input_file_crc32)</td></tr>
<tr class="memdesc:a4ad769e0328d77bf1186f4d2a657f9cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an executable to debug.  <a href="#a4ad769e0328d77bf1186f4d2a657f9cf">More...</a><br /></td></tr>
<tr class="separator:a4ad769e0328d77bf1186f4d2a657f9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcad9ca300d8d0a43be31a58b438033f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#afcad9ca300d8d0a43be31a58b438033f">attach_process</a> )(<a class="el" href="idd_8hpp.html#a288e13e815d43b06e75819f8939524df">pid_t</a> pid, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> event_id)</td></tr>
<tr class="memdesc:afcad9ca300d8d0a43be31a58b438033f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach to an existing running process.  <a href="#afcad9ca300d8d0a43be31a58b438033f">More...</a><br /></td></tr>
<tr class="separator:afcad9ca300d8d0a43be31a58b438033f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b1e4207c87760a097839db870f48b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#af2b1e4207c87760a097839db870f48b1">detach_process</a> )(void)</td></tr>
<tr class="memdesc:af2b1e4207c87760a097839db870f48b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach from the debugged process.  <a href="#af2b1e4207c87760a097839db870f48b1">More...</a><br /></td></tr>
<tr class="separator:af2b1e4207c87760a097839db870f48b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478632b0fe1f5697d27bc6eaf906fdec"><td class="memItemLeft" align="right" valign="top">void(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a478632b0fe1f5697d27bc6eaf906fdec">rebase_if_required_to</a> )(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> new_base)</td></tr>
<tr class="memdesc:a478632b0fe1f5697d27bc6eaf906fdec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebase database if the debugged program has been rebased by the system.  <a href="#a478632b0fe1f5697d27bc6eaf906fdec">More...</a><br /></td></tr>
<tr class="separator:a478632b0fe1f5697d27bc6eaf906fdec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58cd395a242ca96d59d269fca7386ac1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a58cd395a242ca96d59d269fca7386ac1">prepare_to_pause_process</a> )(void)</td></tr>
<tr class="memdesc:a58cd395a242ca96d59d269fca7386ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare to pause the process.  <a href="#a58cd395a242ca96d59d269fca7386ac1">More...</a><br /></td></tr>
<tr class="separator:a58cd395a242ca96d59d269fca7386ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584eefc7c095f3d859d07e878f47f13a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a584eefc7c095f3d859d07e878f47f13a">exit_process</a> )(void)</td></tr>
<tr class="memdesc:a584eefc7c095f3d859d07e878f47f13a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the process.  <a href="#a584eefc7c095f3d859d07e878f47f13a">More...</a><br /></td></tr>
<tr class="separator:a584eefc7c095f3d859d07e878f47f13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886303ae0e83f986e6a0af637166be08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="idd_8hpp.html#a76833d18d68fb2c7408eee02d8e8464e">gdecode_t</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a886303ae0e83f986e6a0af637166be08">get_debug_event</a> )(<a class="el" href="structdebug__event__t.html">debug_event_t</a> *event, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> timeout_ms)</td></tr>
<tr class="memdesc:a886303ae0e83f986e6a0af637166be08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pending debug event and suspend the process.  <a href="#a886303ae0e83f986e6a0af637166be08">More...</a><br /></td></tr>
<tr class="separator:a886303ae0e83f986e6a0af637166be08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40af9f2cedd61e557b7ea751e35ad7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#ab40af9f2cedd61e557b7ea751e35ad7c">continue_after_event</a> )(const <a class="el" href="structdebug__event__t.html">debug_event_t</a> *event)</td></tr>
<tr class="memdesc:ab40af9f2cedd61e557b7ea751e35ad7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Continue after handling the event.  <a href="#ab40af9f2cedd61e557b7ea751e35ad7c">More...</a><br /></td></tr>
<tr class="separator:ab40af9f2cedd61e557b7ea751e35ad7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c2f88408c7749ee35b5bf4fbe6b7d6"><td class="memItemLeft" align="right" valign="top">void(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a98c2f88408c7749ee35b5bf4fbe6b7d6">set_exception_info</a> )(const <a class="el" href="structexception__info__t.html">exception_info_t</a> *<a class="el" href="kernwin_8hpp.html#a513ff6f132e1b8ad086f0f4e69c1d612">info</a>, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> qty)</td></tr>
<tr class="memdesc:a98c2f88408c7749ee35b5bf4fbe6b7d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set exception handling.  <a href="#a98c2f88408c7749ee35b5bf4fbe6b7d6">More...</a><br /></td></tr>
<tr class="separator:a98c2f88408c7749ee35b5bf4fbe6b7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41231884fc842f592dc06f4f1e6e841c"><td class="memItemLeft" align="right" valign="top">void(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a41231884fc842f592dc06f4f1e6e841c">stopped_at_debug_event</a> )(bool dlls_added)</td></tr>
<tr class="memdesc:a41231884fc842f592dc06f4f1e6e841c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will be called by the kernel each time it has stopped the debugger process and refreshed the database.  <a href="#a41231884fc842f592dc06f4f1e6e841c">More...</a><br /></td></tr>
<tr class="separator:a41231884fc842f592dc06f4f1e6e841c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65508db1c4f23fd1f67ff5aa9d73a262"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a65508db1c4f23fd1f67ff5aa9d73a262">read_registers</a> )(<a class="el" href="idd_8hpp.html#a479b4266d280e0d77b7ca914dec19122">thid_t</a> tid, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> clsmask, <a class="el" href="structregval__t.html">regval_t</a> *values)</td></tr>
<tr class="memdesc:a65508db1c4f23fd1f67ff5aa9d73a262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read thread registers.  <a href="#a65508db1c4f23fd1f67ff5aa9d73a262">More...</a><br /></td></tr>
<tr class="separator:a65508db1c4f23fd1f67ff5aa9d73a262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba570fb74d78de99434cfac9b3520ff0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#aba570fb74d78de99434cfac9b3520ff0">write_register</a> )(<a class="el" href="idd_8hpp.html#a479b4266d280e0d77b7ca914dec19122">thid_t</a> tid, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> regidx, const <a class="el" href="structregval__t.html">regval_t</a> *value)</td></tr>
<tr class="memdesc:aba570fb74d78de99434cfac9b3520ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write one thread register.  <a href="#aba570fb74d78de99434cfac9b3520ff0">More...</a><br /></td></tr>
<tr class="separator:aba570fb74d78de99434cfac9b3520ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4180c81014ac7a170a8a2f1fdc4b41b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a4180c81014ac7a170a8a2f1fdc4b41b1">thread_get_sreg_base</a> )(<a class="el" href="idd_8hpp.html#a479b4266d280e0d77b7ca914dec19122">thid_t</a> tid, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> sreg_value, <a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> *answer)</td></tr>
<tr class="memdesc:a4180c81014ac7a170a8a2f1fdc4b41b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information about the base of a segment register.  <a href="#a4180c81014ac7a170a8a2f1fdc4b41b1">More...</a><br /></td></tr>
<tr class="separator:a4180c81014ac7a170a8a2f1fdc4b41b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9622df1e8936202d9204bc44dc8d0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#abc9622df1e8936202d9204bc44dc8d0d">is_ok_bpt</a> )(<a class="el" href="idd_8hpp.html#a773a43fff5c9bacc9f28d203baec542d">bpttype_t</a> type, <a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ea, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> len)</td></tr>
<tr class="memdesc:abc9622df1e8936202d9204bc44dc8d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is it possible to set breakpoint?.  <a href="#abc9622df1e8936202d9204bc44dc8d0d">More...</a><br /></td></tr>
<tr class="separator:abc9622df1e8936202d9204bc44dc8d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5672d4377caebeb5022eba32e9f020fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a5672d4377caebeb5022eba32e9f020fd">update_bpts</a> )(<a class="el" href="structupdate__bpt__info__t.html">update_bpt_info_t</a> *bpts, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> nadd, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> ndel)</td></tr>
<tr class="memdesc:a5672d4377caebeb5022eba32e9f020fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add/del breakpoints.  <a href="#a5672d4377caebeb5022eba32e9f020fd">More...</a><br /></td></tr>
<tr class="separator:a5672d4377caebeb5022eba32e9f020fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487811d045a362c9d2352c7be182c0e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a487811d045a362c9d2352c7be182c0e5">update_lowcnds</a> )(const <a class="el" href="structlowcnd__t.html">lowcnd_t</a> *lowcnds, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> nlowcnds)</td></tr>
<tr class="memdesc:a487811d045a362c9d2352c7be182c0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update low-level (server side) breakpoint conditions.  <a href="#a487811d045a362c9d2352c7be182c0e5">More...</a><br /></td></tr>
<tr class="separator:a487811d045a362c9d2352c7be182c0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967b7d807da83a2fff3f18498bcc91f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a967b7d807da83a2fff3f18498bcc91f3">map_address</a> )(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> off, const <a class="el" href="structregval__t.html">regval_t</a> *regs, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> regnum)</td></tr>
<tr class="memdesc:a967b7d807da83a2fff3f18498bcc91f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map process address.  <a href="#a967b7d807da83a2fff3f18498bcc91f3">More...</a><br /></td></tr>
<tr class="separator:a967b7d807da83a2fff3f18498bcc91f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496e34891b936f74ad690f0bd299d613"><td class="memItemLeft" align="right" valign="top">const char *(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a496e34891b936f74ad690f0bd299d613">set_dbg_options</a> )(const char *keyword, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> pri, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> value_type, const void *value)</td></tr>
<tr class="memdesc:a496e34891b936f74ad690f0bd299d613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set debugger options (parameters that are specific to the debugger module).  <a href="#a496e34891b936f74ad690f0bd299d613">More...</a><br /></td></tr>
<tr class="separator:a496e34891b936f74ad690f0bd299d613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e49d0b15a386987888faf5b09918d2"><td class="memItemLeft" align="right" valign="top">const void *(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a08e49d0b15a386987888faf5b09918d2">get_debmod_extensions</a> )(void)</td></tr>
<tr class="memdesc:a08e49d0b15a386987888faf5b09918d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to debugger specific functions.  <a href="#a08e49d0b15a386987888faf5b09918d2">More...</a><br /></td></tr>
<tr class="separator:a08e49d0b15a386987888faf5b09918d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1c518900a2ec7dcb701b5f7498b164"><td class="memItemLeft" align="right" valign="top">bool(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a3d1c518900a2ec7dcb701b5f7498b164">update_call_stack</a> )(<a class="el" href="idd_8hpp.html#a479b4266d280e0d77b7ca914dec19122">thid_t</a> tid, <a class="el" href="structcall__stack__t.html">call_stack_t</a> *trace)</td></tr>
<tr class="memdesc:a3d1c518900a2ec7dcb701b5f7498b164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the call stack trace.  <a href="#a3d1c518900a2ec7dcb701b5f7498b164">More...</a><br /></td></tr>
<tr class="separator:a3d1c518900a2ec7dcb701b5f7498b164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab565473c6a71a8c7c87f810b7fcad2c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#ab565473c6a71a8c7c87f810b7fcad2c5">appcall</a> )(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> func_ea, <a class="el" href="idd_8hpp.html#a479b4266d280e0d77b7ca914dec19122">thid_t</a> tid, const struct <a class="el" href="structfunc__type__data__t.html">func_type_data_t</a> *fti, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> nargs, const struct <a class="el" href="structregobjs__t.html">regobjs_t</a> *regargs, struct <a class="el" href="structrelobj__t.html">relobj_t</a> *stkargs, struct <a class="el" href="structregobjs__t.html">regobjs_t</a> *retregs, <a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *errbuf, <a class="el" href="structdebug__event__t.html">debug_event_t</a> *event, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> options)</td></tr>
<tr class="memdesc:ab565473c6a71a8c7c87f810b7fcad2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call application function.  <a href="#ab565473c6a71a8c7c87f810b7fcad2c5">More...</a><br /></td></tr>
<tr class="separator:ab565473c6a71a8c7c87f810b7fcad2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacebfa522779a5acc3558d28eeaffc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#adacebfa522779a5acc3558d28eeaffc1">cleanup_appcall</a> )(<a class="el" href="idd_8hpp.html#a479b4266d280e0d77b7ca914dec19122">thid_t</a> tid)</td></tr>
<tr class="memdesc:adacebfa522779a5acc3558d28eeaffc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup after <a class="el" href="structdebugger__t.html#ab565473c6a71a8c7c87f810b7fcad2c5" title="Call application function. ">appcall()</a>.  <a href="#adacebfa522779a5acc3558d28eeaffc1">More...</a><br /></td></tr>
<tr class="separator:adacebfa522779a5acc3558d28eeaffc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28dfff5fc535e509d56f512bbe4ad3f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a28dfff5fc535e509d56f512bbe4ad3f7">eval_lowcnd</a> )(<a class="el" href="idd_8hpp.html#a479b4266d280e0d77b7ca914dec19122">thid_t</a> tid, <a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ea)</td></tr>
<tr class="memdesc:a28dfff5fc535e509d56f512bbe4ad3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a low level breakpoint condition at 'ea'.  <a href="#a28dfff5fc535e509d56f512bbe4ad3f7">More...</a><br /></td></tr>
<tr class="separator:a28dfff5fc535e509d56f512bbe4ad3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add850647fe7ae8e10824e532ee79c850"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add850647fe7ae8e10824e532ee79c850"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#add850647fe7ae8e10824e532ee79c850">write_file</a> )(<a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> fn, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> off, const void *buf, size_t size)</td></tr>
<tr class="memdesc:add850647fe7ae8e10824e532ee79c850"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called from main thread. <br /></td></tr>
<tr class="separator:add850647fe7ae8e10824e532ee79c850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e962aef99d543d82971af7d1a6cd521"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a8e962aef99d543d82971af7d1a6cd521">send_ioctl</a> )(<a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> fn, const void *buf, size_t size, void **poutbuf, <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> *poutsize)</td></tr>
<tr class="memdesc:a8e962aef99d543d82971af7d1a6cd521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a debugger-specific function.  <a href="#a8e962aef99d543d82971af7d1a6cd521">More...</a><br /></td></tr>
<tr class="separator:a8e962aef99d543d82971af7d1a6cd521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f00d1ed5f8e42625c9759daa853ac6d"><td class="memItemLeft" align="right" valign="top">bool(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a1f00d1ed5f8e42625c9759daa853ac6d">dbg_enable_trace</a> )(<a class="el" href="idd_8hpp.html#a479b4266d280e0d77b7ca914dec19122">thid_t</a> tid, bool enable, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> trace_flags)</td></tr>
<tr class="memdesc:a1f00d1ed5f8e42625c9759daa853ac6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/Disable tracing.  <a href="#a1f00d1ed5f8e42625c9759daa853ac6d">More...</a><br /></td></tr>
<tr class="separator:a1f00d1ed5f8e42625c9759daa853ac6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5044b08ed89c06d4c0a9a9c526f2c927"><td class="memItemLeft" align="right" valign="top">bool(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a5044b08ed89c06d4c0a9a9c526f2c927">is_tracing_enabled</a> )(<a class="el" href="idd_8hpp.html#a479b4266d280e0d77b7ca914dec19122">thid_t</a> tid, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> tracebit)</td></tr>
<tr class="memdesc:a5044b08ed89c06d4c0a9a9c526f2c927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is tracing enabled? ONLY used for tracers.  <a href="#a5044b08ed89c06d4c0a9a9c526f2c927">More...</a><br /></td></tr>
<tr class="separator:a5044b08ed89c06d4c0a9a9c526f2c927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98afbe60e4bfb9cc19336c7c386ee813"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a98afbe60e4bfb9cc19336c7c386ee813">rexec</a> )(const char *cmdline)</td></tr>
<tr class="memdesc:a98afbe60e4bfb9cc19336c7c386ee813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a command on the remote computer.  <a href="#a98afbe60e4bfb9cc19336c7c386ee813">More...</a><br /></td></tr>
<tr class="separator:a98afbe60e4bfb9cc19336c7c386ee813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1945045d3c65919cff04c77982e6c8ab"><td class="memItemLeft" align="right" valign="top">void(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a1945045d3c65919cff04c77982e6c8ab">get_debapp_attrs</a> )(<a class="el" href="structdebapp__attrs__t.html">debapp_attrs_t</a> *out_pattrs)</td></tr>
<tr class="memdesc:a1945045d3c65919cff04c77982e6c8ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get (store to out_pattrs) process/debugger-specific runtime attributes.  <a href="#a1945045d3c65919cff04c77982e6c8ab">More...</a><br /></td></tr>
<tr class="separator:a1945045d3c65919cff04c77982e6c8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Memory manipulation</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The following functions manipulate bytes in the memory.</p>
</div></td></tr>
<tr class="memitem:a879889751d0dbdac1933b42295563cff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a879889751d0dbdac1933b42295563cff">get_memory_info</a> )(<a class="el" href="idd_8hpp.html#ab53dc5825c9fb9e10963d2f321721169">meminfo_vec_t</a> &amp;areas)</td></tr>
<tr class="memdesc:a879889751d0dbdac1933b42295563cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information on the memory areas.  <a href="#a879889751d0dbdac1933b42295563cff">More...</a><br /></td></tr>
<tr class="separator:a879889751d0dbdac1933b42295563cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42df4d99dc09905e11a4032db9a58d5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a42df4d99dc09905e11a4032db9a58d5c">read_memory</a> )(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ea, void *buffer, size_t size)</td></tr>
<tr class="memdesc:a42df4d99dc09905e11a4032db9a58d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read process memory.  <a href="#a42df4d99dc09905e11a4032db9a58d5c">More...</a><br /></td></tr>
<tr class="separator:a42df4d99dc09905e11a4032db9a58d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5321ca40e282211fb52524eafff3ddb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#aa5321ca40e282211fb52524eafff3ddb">write_memory</a> )(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ea, const void *buffer, size_t size)</td></tr>
<tr class="memdesc:aa5321ca40e282211fb52524eafff3ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write process memory.  <a href="#aa5321ca40e282211fb52524eafff3ddb">More...</a><br /></td></tr>
<tr class="separator:aa5321ca40e282211fb52524eafff3ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Remote file</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Open/close/read a remote file.</p>
<p>These functions are called from the main thread </p>
</div></td></tr>
<tr class="memitem:a121ef5f1ff26ad0e122910fddb7e9224"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a121ef5f1ff26ad0e122910fddb7e9224"></a>
<a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>open_file</b> )(const char *file, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> *fsize, bool readonly)</td></tr>
<tr class="separator:a121ef5f1ff26ad0e122910fddb7e9224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c15ceb24a556a66ebee8fb5b9fbd1c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05c15ceb24a556a66ebee8fb5b9fbd1c"></a>
void(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>close_file</b> )(<a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> fn)</td></tr>
<tr class="separator:a05c15ceb24a556a66ebee8fb5b9fbd1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c261fb48e840a66d05cce7571dfe5d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2c261fb48e840a66d05cce7571dfe5d"></a>
<a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>read_file</b> )(<a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> fn, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> off, void *buf, size_t size)</td></tr>
<tr class="separator:aa2c261fb48e840a66d05cce7571dfe5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac171fa628ada98e8ec0351b7b7d74ecf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac171fa628ada98e8ec0351b7b7d74ecf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_remote</b> (void) const </td></tr>
<tr class="separator:ac171fa628ada98e8ec0351b7b7d74ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6e4a1663b00ecd1c269fe9d31243be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d6e4a1663b00ecd1c269fe9d31243be"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>must_have_hostname</b> (void) const </td></tr>
<tr class="separator:a1d6e4a1663b00ecd1c269fe9d31243be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa194dee8fc4649ecb7d79c84ea379bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa194dee8fc4649ecb7d79c84ea379bd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>can_continue_from_bpt</b> (void) const </td></tr>
<tr class="separator:afa194dee8fc4649ecb7d79c84ea379bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac461368be5204207208ecd41a7fffe73"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac461368be5204207208ecd41a7fffe73"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>may_disturb</b> (void) const </td></tr>
<tr class="separator:ac461368be5204207208ecd41a7fffe73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d9b8b236e5051b3d1d91343387b380"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3d9b8b236e5051b3d1d91343387b380"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_safe</b> (void) const </td></tr>
<tr class="separator:ad3d9b8b236e5051b3d1d91343387b380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae927f5e4ff1285dd6e33e8eaee8183"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ae927f5e4ff1285dd6e33e8eaee8183"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>use_sregs</b> (void) const </td></tr>
<tr class="separator:a0ae927f5e4ff1285dd6e33e8eaee8183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f54264466ee7665469e7af7f573e634"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f54264466ee7665469e7af7f573e634"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>cache_block_size</b> (void) const </td></tr>
<tr class="separator:a1f54264466ee7665469e7af7f573e634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b3799d95480b120c67c275e9298687"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9b3799d95480b120c67c275e9298687"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>use_memregs</b> (void) const </td></tr>
<tr class="separator:aa9b3799d95480b120c67c275e9298687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eaceb628664a06e1f33d6d8f0384e25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2eaceb628664a06e1f33d6d8f0384e25"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>may_take_exit_snapshot</b> (void) const </td></tr>
<tr class="separator:a2eaceb628664a06e1f33d6d8f0384e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ab3df73221996a59d16ff0823853dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0ab3df73221996a59d16ff0823853dc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>virtual_threads</b> (void) const </td></tr>
<tr class="separator:ad0ab3df73221996a59d16ff0823853dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9e9596d5a5bd7dd3796b711a99a4d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a9e9596d5a5bd7dd3796b711a99a4d8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>supports_lowcnds</b> (void) const </td></tr>
<tr class="separator:a2a9e9596d5a5bd7dd3796b711a99a4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b98630b78011ff4beec0fdace67934"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17b98630b78011ff4beec0fdace67934"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>supports_debthread</b> (void) const </td></tr>
<tr class="separator:a17b98630b78011ff4beec0fdace67934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5580f49766afe6ce7897556725db3e65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5580f49766afe6ce7897556725db3e65"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>can_debug_standalone_dlls</b> (void) const </td></tr>
<tr class="separator:a5580f49766afe6ce7897556725db3e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2197df475874e9345cb128757fe650"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa2197df475874e9345cb128757fe650"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>fake_memory</b> (void) const </td></tr>
<tr class="separator:afa2197df475874e9345cb128757fe650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a4fde8d109b755a061a06afc209fd18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a4fde8d109b755a061a06afc209fd18"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_resmod_avail</b> (<a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> resmod) const </td></tr>
<tr class="separator:a8a4fde8d109b755a061a06afc209fd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af326cc137d88c42e8b6f7cdddb8e9875"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af326cc137d88c42e8b6f7cdddb8e9875"></a>
<a class="el" href="structregister__info__t.html">register_info_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>registers</b> (<a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> idx)</td></tr>
<tr class="separator:af326cc137d88c42e8b6f7cdddb8e9875"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Threads</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp03bfaee27b3b5cfb28deef84a0f416e5"></a>The following functions manipulate threads.</p>
<p>These functions are called from debthread. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>failed </td></tr>
    <tr><td class="paramname">-1</td><td>network error </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr class="memitem:af0c966367dbca83be77b27195ca13164"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0c966367dbca83be77b27195ca13164"></a>
<a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#af0c966367dbca83be77b27195ca13164">thread_continue</a> )(<a class="el" href="idd_8hpp.html#a479b4266d280e0d77b7ca914dec19122">thid_t</a> tid)</td></tr>
<tr class="memdesc:af0c966367dbca83be77b27195ca13164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume a suspended thread. <br /></td></tr>
<tr class="separator:af0c966367dbca83be77b27195ca13164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea844e9f4788146b16c271116482b2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ea844e9f4788146b16c271116482b2c"></a>
<a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a7ea844e9f4788146b16c271116482b2c">set_resume_mode</a> )(<a class="el" href="idd_8hpp.html#a479b4266d280e0d77b7ca914dec19122">thid_t</a> tid, <a class="el" href="idd_8hpp.html#a22acbc39891c15a300bd1ddf85edafae">resume_mode_t</a> resmod)</td></tr>
<tr class="memdesc:a7ea844e9f4788146b16c271116482b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify resume action. <br /></td></tr>
<tr class="separator:a7ea844e9f4788146b16c271116482b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067bbe0d9c9b881766d4a5007dcab1af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a067bbe0d9c9b881766d4a5007dcab1af"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> (<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *thread_suspend)(<a class="el" href="idd_8hpp.html#a479b4266d280e0d77b7ca914dec19122">thid_t</a> tid)</td></tr>
<tr class="memdesc:a067bbe0d9c9b881766d4a5007dcab1af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend a running thread. <br /></td></tr>
<tr class="separator:a067bbe0d9c9b881766d4a5007dcab1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a20ad9af89799075474d046a22b511161"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* debugger_t::processor</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Required processor name. </p>
<p>Used for instant debugging to load the correct processor module </p>

</div>
</div>
<a class="anchor" id="ad75c4677f9d5a1540b56933aef5893b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * debugger_t::init_debugger) (const char *hostname, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> portnum, const char *password)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize debugger. </p>
<p>This function is called from the main thread. </p><dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a class="anchor" id="a1547d388962b406d12b28cbbbe118e13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * debugger_t::term_debugger) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Terminate debugger. </p>
<p>This function is called from the main thread. </p><dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a class="anchor" id="abc188888169461c60e668bd7a3079aab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * debugger_t::process_get_info) (<a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> n, <a class="el" href="structprocess__info__t.html">process_info_t</a> *<a class="el" href="kernwin_8hpp.html#a513ff6f132e1b8ad086f0f4e69c1d612">info</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return information about the n-th "compatible" running process. </p>
<p>If n is 0, the processes list is reinitialized. This function is called from the main thread. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>failed </td></tr>
    <tr><td class="paramname">-1</td><td>network error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4ad769e0328d77bf1186f4d2a657f9cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * debugger_t::start_process) (const char *path, const char *args, const char *startdir, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> dbg_proc_flags, const char *input_path, <a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a> input_file_crc32)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an executable to debug. </p>
<p>This function is called from debthread. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>path to executable </td></tr>
    <tr><td class="paramname">args</td><td>arguments to pass to executable </td></tr>
    <tr><td class="paramname">startdir</td><td>current directory of new process </td></tr>
    <tr><td class="paramname">dbg_proc_flags</td><td><a class="el" href="group___d_b_g___p_r_o_c__.html">Debug process flags</a> </td></tr>
    <tr><td class="paramname">input_path</td><td>path to database input file. (not always the same as 'path' - e.g. if you're analyzing a dll and want to launch an executable that loads it) </td></tr>
    <tr><td class="paramname">input_file_crc32</td><td>CRC value for 'input_path' </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>failed </td></tr>
    <tr><td class="paramname">-2</td><td>file not found (ask for process options) </td></tr>
    <tr><td class="paramname">1</td><td>| <a class="el" href="idd_8hpp.html#a4c2512682435d1442a29b172e66f72a3" title="crc32 mismatch bit (see return values for debugger_t::start_process) ">CRC32_MISMATCH</a> ok, but the input file crc does not match </td></tr>
    <tr><td class="paramname">-1</td><td>network error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afcad9ca300d8d0a43be31a58b438033f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * debugger_t::attach_process) (<a class="el" href="idd_8hpp.html#a288e13e815d43b06e75819f8939524df">pid_t</a> pid, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> event_id)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach to an existing running process. </p>
<p>event_id should be equal to -1 if not attaching to a crashed process. This function is called from debthread. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>failed </td></tr>
    <tr><td class="paramname">-1</td><td>network error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af2b1e4207c87760a097839db870f48b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * debugger_t::detach_process) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach from the debugged process. </p>
<p>May be called while the process is running or suspended. Must detach from the process in any case. The kernel will repeatedly call <a class="el" href="structdebugger__t.html#a886303ae0e83f986e6a0af637166be08" title="Get a pending debug event and suspend the process. ">get_debug_event()</a> and until <a class="el" href="idd_8hpp.html#a0e4c82840d549d876223416d8ae11356a3eafec622dfbcccd6ce7f8b4fc616f80" title="Successfully detached from process. ">PROCESS_DETACH</a>. In this mode, all other events will be automatically handled and process will be resumed. This function is called from debthread. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>failed </td></tr>
    <tr><td class="paramname">-1</td><td>network error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a478632b0fe1f5697d27bc6eaf906fdec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * debugger_t::rebase_if_required_to) (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> new_base)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rebase database if the debugged program has been rebased by the system. </p>
<p>This function is called from the main thread. </p>

</div>
</div>
<a class="anchor" id="a58cd395a242ca96d59d269fca7386ac1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * debugger_t::prepare_to_pause_process) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare to pause the process. </p>
<p>Normally the next <a class="el" href="structdebugger__t.html#a886303ae0e83f986e6a0af637166be08" title="Get a pending debug event and suspend the process. ">get_debug_event()</a> will pause the process If the process is sleeping then the pause will not occur until the process wakes up. The interface should take care of this situation. If this function is absent, then it won't be possible to pause the program. This function is called from debthread. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>failed </td></tr>
    <tr><td class="paramname">-1</td><td>network error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a584eefc7c095f3d859d07e878f47f13a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * debugger_t::exit_process) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop the process. </p>
<p>May be called while the process is running or suspended. Must terminate the process in any case. The kernel will repeatedly call <a class="el" href="structdebugger__t.html#a886303ae0e83f986e6a0af637166be08" title="Get a pending debug event and suspend the process. ">get_debug_event()</a> and until <a class="el" href="idd_8hpp.html#a0e4c82840d549d876223416d8ae11356afb460266f74f4f915ba76e22a62c621c" title="Process has been stopped. ">PROCESS_EXIT</a>. In this mode, all other events will be automatically handled and process will be resumed. This function is called from debthread. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>failed </td></tr>
    <tr><td class="paramname">-1</td><td>network error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a886303ae0e83f986e6a0af637166be08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="idd_8hpp.html#a76833d18d68fb2c7408eee02d8e8464e">gdecode_t</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * debugger_t::get_debug_event) (<a class="el" href="structdebug__event__t.html">debug_event_t</a> *event, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> timeout_ms)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pending debug event and suspend the process. </p>
<p>This function will be called regularly by IDA. This function is called from debthread. IMPORTANT: commdbg does not expect immediately after a BPT-related event any other event with the same thread/IP - this can cause erroneous restoring of a breakpoint before resume (the bug was encountered 24.02.2015 in pc_linux_upx.elf) </p>

</div>
</div>
<a class="anchor" id="ab40af9f2cedd61e557b7ea751e35ad7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * debugger_t::continue_after_event) (const <a class="el" href="structdebug__event__t.html">debug_event_t</a> *event)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Continue after handling the event. </p>
<p>This function is called from debthread. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>failed </td></tr>
    <tr><td class="paramname">-1</td><td>network error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a98c2f88408c7749ee35b5bf4fbe6b7d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * debugger_t::set_exception_info) (const <a class="el" href="structexception__info__t.html">exception_info_t</a> *<a class="el" href="kernwin_8hpp.html#a513ff6f132e1b8ad086f0f4e69c1d612">info</a>, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> qty)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set exception handling. </p>
<p>This function is called from debthread or the main thread. </p>

</div>
</div>
<a class="anchor" id="a41231884fc842f592dc06f4f1e6e841c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * debugger_t::stopped_at_debug_event) (bool dlls_added)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will be called by the kernel each time it has stopped the debugger process and refreshed the database. </p>
<p>The debugger module may add information to the database if it wants.</p>
<p>The reason for introducing this function is that when an event line LOAD_DLL happens, the database does not reflect the memory state yet and therefore we can't add information about the dll into the database in the <a class="el" href="structdebugger__t.html#a886303ae0e83f986e6a0af637166be08" title="Get a pending debug event and suspend the process. ">get_debug_event()</a> function. Only when the kernel has adjusted the database we can do it. Example: for imported PE DLLs we will add the exported function names to the database.</p>
<p>This function pointer may be absent, i.e. NULL. This function is called from the main thread. </p>

</div>
</div>
<a class="anchor" id="a65508db1c4f23fd1f67ff5aa9d73a262"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * debugger_t::read_registers) (<a class="el" href="idd_8hpp.html#a479b4266d280e0d77b7ca914dec19122">thid_t</a> tid, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> clsmask, <a class="el" href="structregval__t.html">regval_t</a> *values)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read thread registers. </p>
<p>This function is called from debthread. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tid</td><td>thread id </td></tr>
    <tr><td class="paramname">clsmask</td><td>bitmask of register classes to read </td></tr>
    <tr><td class="paramname">regval</td><td>pointer to vector of regvals for all registers. regval is assumed to have <a class="el" href="structdebugger__t.html#a38ccb54d0434ab7c6c9d1137d7773c08" title="Number of registers. ">debugger_t::registers_size</a> elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>failed </td></tr>
    <tr><td class="paramname">-1</td><td>network error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aba570fb74d78de99434cfac9b3520ff0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * debugger_t::write_register) (<a class="el" href="idd_8hpp.html#a479b4266d280e0d77b7ca914dec19122">thid_t</a> tid, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> regidx, const <a class="el" href="structregval__t.html">regval_t</a> *value)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write one thread register. </p>
<p>This function is called from debthread. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tid</td><td>thread id </td></tr>
    <tr><td class="paramname">regidx</td><td>register index </td></tr>
    <tr><td class="paramname">regval</td><td>new value of the register </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>failed </td></tr>
    <tr><td class="paramname">-1</td><td>network error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4180c81014ac7a170a8a2f1fdc4b41b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * debugger_t::thread_get_sreg_base) (<a class="el" href="idd_8hpp.html#a479b4266d280e0d77b7ca914dec19122">thid_t</a> tid, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> sreg_value, <a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> *answer)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get information about the base of a segment register. </p>
<p>Currently used by the IBM PC module to resolve references like fs:0. This function is called from debthread. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tid</td><td>thread id </td></tr>
    <tr><td class="paramname">sreg_value</td><td>value of the segment register (returned by <a class="el" href="group__dbg__funcs__regs.html#gaac94fe8219194588151ff8c4ee9a6600" title="Read a register value from the current thread. ">get_reg_val()</a>) </td></tr>
    <tr><td class="paramname">answer</td><td>pointer to the answer. can't be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>failed </td></tr>
    <tr><td class="paramname">-1</td><td>network error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a879889751d0dbdac1933b42295563cff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * debugger_t::get_memory_info) (<a class="el" href="idd_8hpp.html#ab53dc5825c9fb9e10963d2f321721169">meminfo_vec_t</a> &amp;areas)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get information on the memory areas. </p>
<p>The debugger module fills 'areas'. The returned vector MUST be sorted. This function is called from debthread. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-3</td><td>use idb segmentation </td></tr>
    <tr><td class="paramname">-2</td><td>no changes </td></tr>
    <tr><td class="paramname">-1</td><td>the process does not exist anymore </td></tr>
    <tr><td class="paramname">0</td><td>failed </td></tr>
    <tr><td class="paramname">1</td><td>new memory layout is returned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a42df4d99dc09905e11a4032db9a58d5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * debugger_t::read_memory) (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ea, void *buffer, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read process memory. </p>
<p>Returns number of read bytes. This function is called from debthread. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>read error </td></tr>
    <tr><td class="paramname">-1</td><td>process does not exist anymore </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa5321ca40e282211fb52524eafff3ddb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * debugger_t::write_memory) (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ea, const void *buffer, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write process memory. </p>
<p>This function is called from debthread. </p><dl class="section return"><dt>Returns</dt><dd>number of written bytes, -1 if fatal error </dd></dl>

</div>
</div>
<a class="anchor" id="abc9622df1e8936202d9204bc44dc8d0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * debugger_t::is_ok_bpt) (<a class="el" href="idd_8hpp.html#a773a43fff5c9bacc9f28d203baec542d">bpttype_t</a> type, <a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ea, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> len)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is it possible to set breakpoint?. </p>
<p>This function is called from debthread or from the main thread if debthread is not running yet. It is called to verify hardware breakpoints. </p><dl class="section return"><dt>Returns</dt><dd>ref BPT_ </dd></dl>

</div>
</div>
<a class="anchor" id="a5672d4377caebeb5022eba32e9f020fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * debugger_t::update_bpts) (<a class="el" href="structupdate__bpt__info__t.html">update_bpt_info_t</a> *bpts, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> nadd, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> ndel)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add/del breakpoints. </p>
<p>bpts array contains nadd bpts to add, followed by ndel bpts to del. This function is called from debthread. </p><dl class="section return"><dt>Returns</dt><dd>number of successfully modified bpts, -1 if network error </dd></dl>

</div>
</div>
<a class="anchor" id="a487811d045a362c9d2352c7be182c0e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * debugger_t::update_lowcnds) (const <a class="el" href="structlowcnd__t.html">lowcnd_t</a> *lowcnds, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> nlowcnds)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update low-level (server side) breakpoint conditions. </p>
<p>This function is called from debthread. </p><dl class="section return"><dt>Returns</dt><dd>nlowcnds. -1-network error </dd></dl>

</div>
</div>
<a class="anchor" id="a967b7d807da83a2fff3f18498bcc91f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * debugger_t::map_address) (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> off, const <a class="el" href="structregval__t.html">regval_t</a> *regs, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> regnum)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map process address. </p>
<p>This function may be absent. This function is called from debthread. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">off</td><td>offset to map </td></tr>
    <tr><td class="paramname">regs</td><td>current register values. if regs == NULL, then perform global mapping, which is independent on used registers usually such a mapping is a trivial identity mapping </td></tr>
    <tr><td class="paramname">regnum</td><td>required mapping. maybe specified as a segment register number or a regular register number if the required mapping can be deduced from it. for example, esp implies that ss should be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mapped address or <a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39; ">BADADDR</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a496e34891b936f74ad690f0bd299d613"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char*(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * debugger_t::set_dbg_options) (const char *keyword, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> pri, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> value_type, const void *value)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set debugger options (parameters that are specific to the debugger module). </p>
<p>See the definition of <a class="el" href="idp_8hpp.html#ae0ba0c758e8a257327f5d9255d8a00f5" title="Callback - called when a config directive is processed in IDA. ">set_options_t</a> for arguments. See the convenience function in <a class="el" href="dbg_8hpp.html" title="Contains functions to control the debugging of a process. ">dbg.hpp</a> if you need to call it. The kernel will call this function after reading the debugger specific config file (arguments are: keyword="", type=<a class="el" href="group___i_d_p_o_p_t___t.html#gac216775cfbb5b80faebf141c232ca6e1" title="string constant (char *) ">IDPOPT_STR</a>, value="") This function is optional. This function is called from the main thread </p>

</div>
</div>
<a class="anchor" id="a08e49d0b15a386987888faf5b09918d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void*(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * debugger_t::get_debmod_extensions) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointer to debugger specific functions. </p>
<p>This function returns a pointer to a structure that holds pointers to debugger module specific functions. For information on the structure layout, please check the corresponding debugger module. Most debugger modules return NULL because they do not have any extensions. Available extensions may be called from plugins. This function is called from the main thread. </p>

</div>
</div>
<a class="anchor" id="a3d1c518900a2ec7dcb701b5f7498b164"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * debugger_t::update_call_stack) (<a class="el" href="idd_8hpp.html#a479b4266d280e0d77b7ca914dec19122">thid_t</a> tid, <a class="el" href="structcall__stack__t.html">call_stack_t</a> *trace)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the call stack trace. </p>
<p>This function is called when the process is suspended and should fill the 'trace' object with the information about the current call stack. If this function is missing or returns false, IDA will use the standard mechanism (based on the frame pointer chain) to calculate the stack trace This function is called from the main thread. </p><dl class="section return"><dt>Returns</dt><dd>success </dd></dl>

</div>
</div>
<a class="anchor" id="ab565473c6a71a8c7c87f810b7fcad2c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * debugger_t::appcall) (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> func_ea, <a class="el" href="idd_8hpp.html#a479b4266d280e0d77b7ca914dec19122">thid_t</a> tid, const struct <a class="el" href="structfunc__type__data__t.html">func_type_data_t</a> *fti, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> nargs, const struct <a class="el" href="structregobjs__t.html">regobjs_t</a> *regargs, struct <a class="el" href="structrelobj__t.html">relobj_t</a> *stkargs, struct <a class="el" href="structregobjs__t.html">regobjs_t</a> *retregs, <a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce">qstring</a> *errbuf, <a class="el" href="structdebug__event__t.html">debug_event_t</a> *event, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> options)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call application function. </p>
<p>This function calls a function from the debugged application. This function is called from debthread </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">func_ea</td><td>address to call </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tid</td><td>thread to use </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fti</td><td>type information for the called function </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nargs</td><td>number of actual arguments </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">regargs</td><td>information about register arguments </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">stkargs</td><td>memory blob to pass as stack arguments (usually contains pointed data) it must be relocated by the callback but not changed otherwise </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">retregs</td><td>function return registers. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errbuf</td><td>the error message. if empty on failure, see 'event'. should not be filled if an appcall exception happened but <a class="el" href="group___a_p_p_c_a_l_l__.html#ga805adda8d1138c0d1d40ee53c7b2b1e7" title="Return debug event information. ">APPCALL_DEBEV</a> is set </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">event</td><td>the last debug event that occurred during appcall execution filled only if the appcall execution fails and <a class="el" href="group___a_p_p_c_a_l_l__.html#ga805adda8d1138c0d1d40ee53c7b2b1e7" title="Return debug event information. ">APPCALL_DEBEV</a> is set </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>appcall options, usually taken from <a class="el" href="structidainfo.html#af28b643c416bbf3871f5dd2c856889e5" title="appcall options, see idd.hpp ">idainfo::appcall_options</a>. possible values: combination of <a class="el" href="group___a_p_p_c_a_l_l__.html">Appcall options</a> or 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ea of stkargs blob, <a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39; ">BADADDR</a> if failed and errbuf is filled </dd></dl>

</div>
</div>
<a class="anchor" id="adacebfa522779a5acc3558d28eeaffc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * debugger_t::cleanup_appcall) (<a class="el" href="idd_8hpp.html#a479b4266d280e0d77b7ca914dec19122">thid_t</a> tid)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cleanup after <a class="el" href="structdebugger__t.html#ab565473c6a71a8c7c87f810b7fcad2c5" title="Call application function. ">appcall()</a>. </p>
<p>The debugger module must keep the stack blob in the memory until this function is called. It will be called by the kernel for each successful <a class="el" href="structdebugger__t.html#ab565473c6a71a8c7c87f810b7fcad2c5" title="Call application function. ">appcall()</a>. There is an exception: if <a class="el" href="group___a_p_p_c_a_l_l__.html#gaa1a104a113d31a3d4167791663d617af" title="Only set up the appcall, do not run. ">APPCALL_MANUAL</a>, IDA may not call cleanup_appcall. If the user selects to terminate a manual appcall, then cleanup_appcall will be called. Otherwise, the debugger module should terminate the appcall when the called function returns. This function is called from debthread. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">2</td><td>ok, there are pending events </td></tr>
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>failed </td></tr>
    <tr><td class="paramname">-1</td><td>network error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a28dfff5fc535e509d56f512bbe4ad3f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * debugger_t::eval_lowcnd) (<a class="el" href="idd_8hpp.html#a479b4266d280e0d77b7ca914dec19122">thid_t</a> tid, <a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ea)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a low level breakpoint condition at 'ea'. </p>
<p>Other evaluation errors are displayed in a dialog box. This call is rarely used by IDA when the process has already been suspended for some reason and it has to decide whether the process should be resumed or definitely suspended because of a breakpoint with a low level condition. This function is called from debthread. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>condition is satisfied </td></tr>
    <tr><td class="paramname">0</td><td>not satisfied </td></tr>
    <tr><td class="paramname">-1</td><td>network error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8e962aef99d543d82971af7d1a6cd521"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * debugger_t::send_ioctl) (<a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> fn, const void *buf, size_t size, void **poutbuf, <a class="el" href="pro_8h.html#ab65ed42d67e6c517c746ff2a6a187016">ssize_t</a> *poutsize)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a debugger-specific function. </p>
<p>This function is called from debthread </p>

</div>
</div>
<a class="anchor" id="a1f00d1ed5f8e42625c9759daa853ac6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * debugger_t::dbg_enable_trace) (<a class="el" href="idd_8hpp.html#a479b4266d280e0d77b7ca914dec19122">thid_t</a> tid, bool enable, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> trace_flags)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/Disable tracing. </p>
<p>"trace_flags" can be a set of STEP_TRACE, INSN_TRACE, BBLK_TRACE or FUNC_TRACE. See thread_t::trace_mode in debugger.h. This function is called from the main thread. </p>

</div>
</div>
<a class="anchor" id="a5044b08ed89c06d4c0a9a9c526f2c927"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * debugger_t::is_tracing_enabled) (<a class="el" href="idd_8hpp.html#a479b4266d280e0d77b7ca914dec19122">thid_t</a> tid, <a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a> tracebit)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is tracing enabled? ONLY used for tracers. </p>
<p>"trace_bit" can be one of the following: STEP_TRACE, INSN_TRACE, BBLK_TRACE or FUNC_TRACE </p>

</div>
</div>
<a class="anchor" id="a98afbe60e4bfb9cc19336c7c386ee813"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdebugger__t.html#a067bbe0d9c9b881766d4a5007dcab1af">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * debugger_t::rexec) (const char *cmdline)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a command on the remote computer. </p>
<dl class="section return"><dt>Returns</dt><dd>exit code </dd></dl>

</div>
</div>
<a class="anchor" id="a1945045d3c65919cff04c77982e6c8ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * debugger_t::get_debapp_attrs) (<a class="el" href="structdebapp__attrs__t.html">debapp_attrs_t</a> *out_pattrs)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get (store to out_pattrs) process/debugger-specific runtime attributes. </p>
<p>This function is called from main thread. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="idd_8hpp.html">idd.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
