<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>IDA SDK: processor_t Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">IDA SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="files.html"><span>Header&#160;Files</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="structprocessor__t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">processor_t Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Describes a processor module (IDP). </p>
<p>An IDP file may have only one such structure called LPH. The kernel will copy it to <a class="el" href="idp_8hpp.html#a1b22cd8cccc4c04160172a9fdc95626b" title="current processor ">ph</a> structure and use <a class="el" href="idp_8hpp.html#a1b22cd8cccc4c04160172a9fdc95626b" title="current processor ">ph</a>. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a93370ea7d8c0a41bf91c43b460972805"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93370ea7d8c0a41bf91c43b460972805"></a>
<a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a93370ea7d8c0a41bf91c43b460972805">version</a></td></tr>
<tr class="memdesc:a93370ea7d8c0a41bf91c43b460972805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected kernel version, should be <a class="el" href="idp_8hpp.html#af4b4e4966302754b758c8cc16f964a15" title="The interface version number. ">IDP_INTERFACE_VERSION</a>. <br /></td></tr>
<tr class="separator:a93370ea7d8c0a41bf91c43b460972805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c5d128eb5e1f6846375aa04c6d1766"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85c5d128eb5e1f6846375aa04c6d1766"></a>
<a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a85c5d128eb5e1f6846375aa04c6d1766">id</a></td></tr>
<tr class="memdesc:a85c5d128eb5e1f6846375aa04c6d1766"><td class="mdescLeft">&#160;</td><td class="mdescRight">one of <a class="el" href="group___p_l_f_m__.html">Processor IDs</a> <br /></td></tr>
<tr class="separator:a85c5d128eb5e1f6846375aa04c6d1766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6542af67172bea21cda8b81c6671d775"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6542af67172bea21cda8b81c6671d775"></a>
<a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a6542af67172bea21cda8b81c6671d775">flag</a></td></tr>
<tr class="memdesc:a6542af67172bea21cda8b81c6671d775"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group___p_r__.html">Processor feature bits</a> <br /></td></tr>
<tr class="separator:a6542af67172bea21cda8b81c6671d775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f886dfe71be841774fbf924efd71882"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a3f886dfe71be841774fbf924efd71882">cnbits</a></td></tr>
<tr class="memdesc:a3f886dfe71be841774fbf924efd71882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bits in a byte for code segments (usually 8).  <a href="#a3f886dfe71be841774fbf924efd71882">More...</a><br /></td></tr>
<tr class="separator:a3f886dfe71be841774fbf924efd71882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af359c0e9205f527f4eff43d505d91ca4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#af359c0e9205f527f4eff43d505d91ca4">dnbits</a></td></tr>
<tr class="memdesc:af359c0e9205f527f4eff43d505d91ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bits in a byte for non-code segments (usually 8).  <a href="#af359c0e9205f527f4eff43d505d91ca4">More...</a><br /></td></tr>
<tr class="separator:af359c0e9205f527f4eff43d505d91ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13faa23b7174cbdbae5da42c71602d24"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structasm__t.html">asm_t</a> *const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a13faa23b7174cbdbae5da42c71602d24">assemblers</a></td></tr>
<tr class="memdesc:a13faa23b7174cbdbae5da42c71602d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to array of target assembler definitions.  <a href="#a13faa23b7174cbdbae5da42c71602d24">More...</a><br /></td></tr>
<tr class="separator:a13faa23b7174cbdbae5da42c71602d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d7131aaf457b74265eeeb999652579"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0d7131aaf457b74265eeeb999652579"></a>
<a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#ab0d7131aaf457b74265eeeb999652579">notify</a> )(<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984e">idp_notify</a> msgid,...)</td></tr>
<tr class="memdesc:ab0d7131aaf457b74265eeeb999652579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Various notifications for the idp. <br /></td></tr>
<tr class="separator:ab0d7131aaf457b74265eeeb999652579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921744ebeca4dda235ecd140559b96ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structprocessor__t.html#abb16014fd9a56ce9cdd3bf1b7965f205">bool</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a921744ebeca4dda235ecd140559b96ab">cmp_opnd</a> )(const <a class="el" href="classop__t.html">op_t</a> &amp;op1, const <a class="el" href="classop__t.html">op_t</a> &amp;op2)</td></tr>
<tr class="memdesc:a921744ebeca4dda235ecd140559b96ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare instruction operands.  <a href="#a921744ebeca4dda235ecd140559b96ab">More...</a><br /></td></tr>
<tr class="separator:a921744ebeca4dda235ecd140559b96ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab842d78138df775d7afa6b6c4eb4d6f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structprocessor__t.html#abb16014fd9a56ce9cdd3bf1b7965f205">bool</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#ab842d78138df775d7afa6b6c4eb4d6f8">can_have_type</a> )(<a class="el" href="classop__t.html">op_t</a> &amp;op)</td></tr>
<tr class="memdesc:ab842d78138df775d7afa6b6c4eb4d6f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can the operand have a type as offset, segment, decimal, etc.  <a href="#ab842d78138df775d7afa6b6c4eb4d6f8">More...</a><br /></td></tr>
<tr class="separator:ab842d78138df775d7afa6b6c4eb4d6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574fc214c55ff0991e3672068a7d7142"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a574fc214c55ff0991e3672068a7d7142"></a>
<a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a574fc214c55ff0991e3672068a7d7142">regsNum</a></td></tr>
<tr class="memdesc:a574fc214c55ff0991e3672068a7d7142"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of registers <br /></td></tr>
<tr class="separator:a574fc214c55ff0991e3672068a7d7142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470124dabad8e9351e326f399e68672a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a470124dabad8e9351e326f399e68672a"></a>
const char *const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a470124dabad8e9351e326f399e68672a">regNames</a></td></tr>
<tr class="memdesc:a470124dabad8e9351e326f399e68672a"><td class="mdescLeft">&#160;</td><td class="mdescRight">array of register names <br /></td></tr>
<tr class="separator:a470124dabad8e9351e326f399e68672a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a59ce127cc7b2f14da61fa5ace5c97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a08a59ce127cc7b2f14da61fa5ace5c97">is_far_jump</a> )(<a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a> icode)</td></tr>
<tr class="memdesc:a08a59ce127cc7b2f14da61fa5ace5c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">is indirect far jump or call instruction?.  <a href="#a08a59ce127cc7b2f14da61fa5ace5c97">More...</a><br /></td></tr>
<tr class="separator:a08a59ce127cc7b2f14da61fa5ace5c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca9e1d2690d7b744c8355f8fbdae4df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#aaca9e1d2690d7b744c8355f8fbdae4df">translate</a> )(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> base, <a class="el" href="pro_8h.html#ac29a387cc69c0d1abb2f2ef05dad1a6f">adiff_t</a> offset)</td></tr>
<tr class="memdesc:aaca9e1d2690d7b744c8355f8fbdae4df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translation function for offsets.  <a href="#aaca9e1d2690d7b744c8355f8fbdae4df">More...</a><br /></td></tr>
<tr class="separator:aaca9e1d2690d7b744c8355f8fbdae4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1ea672e493ec9b59b6d3d8e09d69e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a1ea672e493ec9b59b6d3d8e09d69e1"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a7a1ea672e493ec9b59b6d3d8e09d69e1">tbyte_size</a></td></tr>
<tr class="memdesc:a7a1ea672e493ec9b59b6d3d8e09d69e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of long double (tbyte) for this processor (meaningful only if <a class="el" href="structasm__t.html#a8bb6b6dcd51fbc50cc03fa5feeff39aa" title="long double; NULL if not allowed ">asm_t::a_tbyte</a> != NULL) <br /></td></tr>
<tr class="separator:a7a1ea672e493ec9b59b6d3d8e09d69e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e58bd16cec88d15eaf406db8960c7a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a6e58bd16cec88d15eaf406db8960c7a2">realcvt</a> )(<a class="el" href="structprocessor__t.html#acbe4f7fded38c0295e5773fd603489a2">void</a> *m, <a class="el" href="pro_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> *e, <a class="el" href="pro_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> swt)</td></tr>
<tr class="memdesc:a6e58bd16cec88d15eaf406db8960c7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Floating point -&gt; IEEE conversion function.  <a href="#a6e58bd16cec88d15eaf406db8960c7a2">More...</a><br /></td></tr>
<tr class="separator:a6e58bd16cec88d15eaf406db8960c7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ed6541f40864dcf175219db42afa90"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#ab1ed6541f40864dcf175219db42afa90">real_width</a> [4]</td></tr>
<tr class="memdesc:ab1ed6541f40864dcf175219db42afa90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of digits in floating numbers after the decimal point.  <a href="#ab1ed6541f40864dcf175219db42afa90">More...</a><br /></td></tr>
<tr class="separator:ab1ed6541f40864dcf175219db42afa90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada062ecba745d093044e3615928cc7ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structprocessor__t.html#abb16014fd9a56ce9cdd3bf1b7965f205">bool</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#ada062ecba745d093044e3615928cc7ad">is_switch</a> )(<a class="el" href="structswitch__info__ex__t.html">switch_info_ex_t</a> *si)</td></tr>
<tr class="memdesc:ada062ecba745d093044e3615928cc7ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find 'switch' idiom.  <a href="#ada062ecba745d093044e3615928cc7ad">More...</a><br /></td></tr>
<tr class="separator:ada062ecba745d093044e3615928cc7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312349eb79dc25a38366381a27204969"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a312349eb79dc25a38366381a27204969">gen_map_file</a> )(FILE *fp)</td></tr>
<tr class="memdesc:a312349eb79dc25a38366381a27204969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate map file.  <a href="#a312349eb79dc25a38366381a27204969">More...</a><br /></td></tr>
<tr class="separator:a312349eb79dc25a38366381a27204969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66833283dbe0f3d424a4d25fb2c141aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a66833283dbe0f3d424a4d25fb2c141aa">extract_address</a> )(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ea, const char *string, <a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a> x)</td></tr>
<tr class="memdesc:a66833283dbe0f3d424a4d25fb2c141aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract address from a string.  <a href="#a66833283dbe0f3d424a4d25fb2c141aa">More...</a><br /></td></tr>
<tr class="separator:a66833283dbe0f3d424a4d25fb2c141aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7322d29966e3324423d7c2a058b9836d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a7322d29966e3324423d7c2a058b9836d">is_sp_based</a> )(const <a class="el" href="classop__t.html">op_t</a> &amp;x)</td></tr>
<tr class="memdesc:a7322d29966e3324423d7c2a058b9836d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the operand is relative to stack pointer or frame pointer.  <a href="#a7322d29966e3324423d7c2a058b9836d">More...</a><br /></td></tr>
<tr class="separator:a7322d29966e3324423d7c2a058b9836d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade063932531b3f164998382458a7085f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structprocessor__t.html#abb16014fd9a56ce9cdd3bf1b7965f205">bool</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#ade063932531b3f164998382458a7085f">create_func_frame</a> )(<a class="el" href="classfunc__t.html">func_t</a> *pfn)</td></tr>
<tr class="memdesc:ade063932531b3f164998382458a7085f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a function frame for a newly created function.  <a href="#ade063932531b3f164998382458a7085f">More...</a><br /></td></tr>
<tr class="separator:ade063932531b3f164998382458a7085f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3860f5f4ceb9f973ec9b8f776783bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a9f3860f5f4ceb9f973ec9b8f776783bd">get_frame_retsize</a> )(<a class="el" href="classfunc__t.html">func_t</a> *pfn)</td></tr>
<tr class="memdesc:a9f3860f5f4ceb9f973ec9b8f776783bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get size of function return address in bytes.  <a href="#a9f3860f5f4ceb9f973ec9b8f776783bd">More...</a><br /></td></tr>
<tr class="separator:a9f3860f5f4ceb9f973ec9b8f776783bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f801f1af90421acc3ebcc11644bfcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structprocessor__t.html#acbe4f7fded38c0295e5773fd603489a2">void</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#ad8f801f1af90421acc3ebcc11644bfcd">gen_stkvar_def</a> )(char *buf, size_t bufsize, const class <a class="el" href="classmember__t.html">member_t</a> *mptr, <a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a> v)</td></tr>
<tr class="memdesc:ad8f801f1af90421acc3ebcc11644bfcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate stack variable definition line.  <a href="#ad8f801f1af90421acc3ebcc11644bfcd">More...</a><br /></td></tr>
<tr class="separator:ad8f801f1af90421acc3ebcc11644bfcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947330e23b5dd5ea1c268bc54f2e67bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structprocessor__t.html#abb16014fd9a56ce9cdd3bf1b7965f205">bool</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a947330e23b5dd5ea1c268bc54f2e67bb">u_outspec</a> )(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ea, <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> <a class="el" href="group__seg__type.html#ga67eaaed66c079e1ac389902d19046d20">segtype</a>)</td></tr>
<tr class="memdesc:a947330e23b5dd5ea1c268bc54f2e67bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate text representation of an item in a special segment.  <a href="#a947330e23b5dd5ea1c268bc54f2e67bb">More...</a><br /></td></tr>
<tr class="separator:a947330e23b5dd5ea1c268bc54f2e67bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed29febd928f4514056055e40d1bc8c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ed29febd928f4514056055e40d1bc8c"></a>
<a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a8ed29febd928f4514056055e40d1bc8c">icode_return</a></td></tr>
<tr class="memdesc:a8ed29febd928f4514056055e40d1bc8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Icode of return instruction. It is ok to give any of possible return instructions. <br /></td></tr>
<tr class="separator:a8ed29febd928f4514056055e40d1bc8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42eb748228de530b17f57976740eceaf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42eb748228de530b17f57976740eceaf"></a>
<a class="el" href="idp_8hpp.html#ae0ba0c758e8a257327f5d9255d8a00f5">set_options_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a42eb748228de530b17f57976740eceaf">set_idp_options</a></td></tr>
<tr class="memdesc:a42eb748228de530b17f57976740eceaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set IDP-specific option. <br /></td></tr>
<tr class="separator:a42eb748228de530b17f57976740eceaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4768056360229a11cc1f272a4ade04c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#ac4768056360229a11cc1f272a4ade04c">is_align_insn</a> )(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ea)</td></tr>
<tr class="memdesc:ac4768056360229a11cc1f272a4ade04c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the instruction created only for alignment purposes?.  <a href="#ac4768056360229a11cc1f272a4ade04c">More...</a><br /></td></tr>
<tr class="separator:ac4768056360229a11cc1f272a4ade04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62aee2fa2fba2d3a642f730ff0e0c3e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62aee2fa2fba2d3a642f730ff0e0c3e8"></a>
<a class="el" href="structprocessor__t.html#acbe4f7fded38c0295e5773fd603489a2">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a62aee2fa2fba2d3a642f730ff0e0c3e8">unused_slot</a></td></tr>
<tr class="memdesc:a62aee2fa2fba2d3a642f730ff0e0c3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserved, currently equals to NULL. <br /></td></tr>
<tr class="separator:a62aee2fa2fba2d3a642f730ff0e0c3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a5bba6ff0c8bf77b55d615f785b21a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#ab3a5bba6ff0c8bf77b55d615f785b21a">high_fixup_bits</a></td></tr>
<tr class="memdesc:ab3a5bba6ff0c8bf77b55d615f785b21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the <a class="el" href="group___f_i_x_u_p__.html#ga7a5bc27151e5973fd7ba3a6f77d4f2c4" title="high processor_t::high_fixup_bits of 32bit offset ">FIXUP_VHIGH</a> and <a class="el" href="group___f_i_x_u_p__.html#ga68e1431db78df74c0ee73b87b9038d19" title="low processor_t::high_fixup_bits of 32bit offset ">FIXUP_VLOW</a> fixup types are supported then the number of bits in the HIGH part.  <a href="#ab3a5bba6ff0c8bf77b55d615f785b21a">More...</a><br /></td></tr>
<tr class="separator:ab3a5bba6ff0c8bf77b55d615f785b21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Names</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>IDP module may support several compatible processors.</p>
<p>The following arrays define processor names: </p>
</div></td></tr>
<tr class="memitem:a7f36c9be272d994bc341b3fcb78726f6"><td class="memItemLeft" align="right" valign="top">const char *const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a7f36c9be272d994bc341b3fcb78726f6">psnames</a></td></tr>
<tr class="memdesc:a7f36c9be272d994bc341b3fcb78726f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">short processor names (NULL terminated).  <a href="#a7f36c9be272d994bc341b3fcb78726f6">More...</a><br /></td></tr>
<tr class="separator:a7f36c9be272d994bc341b3fcb78726f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb54cc1d2faab6891ad190e2e5b7bf08"><td class="memItemLeft" align="right" valign="top">const char *const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#adb54cc1d2faab6891ad190e2e5b7bf08">plnames</a></td></tr>
<tr class="memdesc:adb54cc1d2faab6891ad190e2e5b7bf08"><td class="mdescLeft">&#160;</td><td class="mdescRight">long processor names (NULL terminated).  <a href="#adb54cc1d2faab6891ad190e2e5b7bf08">More...</a><br /></td></tr>
<tr class="separator:adb54cc1d2faab6891ad190e2e5b7bf08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Warning</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The following pointers should be NULL: </p>
</div></td></tr>
<tr class="memitem:a27bbc4b0f0236c146329cdeec2a24d56"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_abstract_register.html">AbstractRegister</a> *(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a27bbc4b0f0236c146329cdeec2a24d56">getreg</a> )(<a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a> regnum)</td></tr>
<tr class="memdesc:a27bbc4b0f0236c146329cdeec2a24d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get register value.  <a href="#a27bbc4b0f0236c146329cdeec2a24d56">More...</a><br /></td></tr>
<tr class="separator:a27bbc4b0f0236c146329cdeec2a24d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d7de35097b642f4b5c64138dc7e147"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51d7de35097b642f4b5c64138dc7e147"></a>
<a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a51d7de35097b642f4b5c64138dc7e147">rFiles</a></td></tr>
<tr class="memdesc:a51d7de35097b642f4b5c64138dc7e147"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of register files <br /></td></tr>
<tr class="separator:a51d7de35097b642f4b5c64138dc7e147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf921b680a22ebb77b31a1fe587205a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf921b680a22ebb77b31a1fe587205a1"></a>
const char *const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#aaf921b680a22ebb77b31a1fe587205a1">rFnames</a></td></tr>
<tr class="memdesc:aaf921b680a22ebb77b31a1fe587205a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">register names for files <br /></td></tr>
<tr class="separator:aaf921b680a22ebb77b31a1fe587205a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c24481bbbc314a1caea4a82f157c32f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c24481bbbc314a1caea4a82f157c32f"></a>
const <a class="el" href="structrginfo.html">rginfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a4c24481bbbc314a1caea4a82f157c32f">rFdescs</a></td></tr>
<tr class="memdesc:a4c24481bbbc314a1caea4a82f157c32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">description of registers <br /></td></tr>
<tr class="separator:a4c24481bbbc314a1caea4a82f157c32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903e0ce4b6f6a58b60a4847d306a99fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a903e0ce4b6f6a58b60a4847d306a99fd"></a>
const class WorkReg *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a903e0ce4b6f6a58b60a4847d306a99fd">CPUregs</a></td></tr>
<tr class="memdesc:a903e0ce4b6f6a58b60a4847d306a99fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to CPU registers <br /></td></tr>
<tr class="separator:a903e0ce4b6f6a58b60a4847d306a99fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Segment registers</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Segment register information (use virtual CS and DS registers if your processor doesn't have segment registers): </p>
</div></td></tr>
<tr class="memitem:ac11259e7820fb9c01c200c3f94b71222"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac11259e7820fb9c01c200c3f94b71222"></a>
<a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#ac11259e7820fb9c01c200c3f94b71222">regFirstSreg</a></td></tr>
<tr class="memdesc:ac11259e7820fb9c01c200c3f94b71222"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of first segment register <br /></td></tr>
<tr class="separator:ac11259e7820fb9c01c200c3f94b71222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693ae7a0e93d356bc328b498736119cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a693ae7a0e93d356bc328b498736119cd"></a>
<a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a693ae7a0e93d356bc328b498736119cd">regLastSreg</a></td></tr>
<tr class="memdesc:a693ae7a0e93d356bc328b498736119cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of last segment register <br /></td></tr>
<tr class="separator:a693ae7a0e93d356bc328b498736119cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51ad805ffa7682a17705988d3484f3b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae51ad805ffa7682a17705988d3484f3b"></a>
<a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#ae51ad805ffa7682a17705988d3484f3b">segreg_size</a></td></tr>
<tr class="memdesc:ae51ad805ffa7682a17705988d3484f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">size of a segment register in bytes <br /></td></tr>
<tr class="separator:ae51ad805ffa7682a17705988d3484f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Virtual segment registers</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>If your processor doesn't have segment registers, you should define 2 virtual segment registers for CS and DS.</p>
<p>Let's call them rVcs and rVds. </p>
</div></td></tr>
<tr class="memitem:a922a1f328e0a270111d97ee85954b05d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a922a1f328e0a270111d97ee85954b05d"></a>
<a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a922a1f328e0a270111d97ee85954b05d">regCodeSreg</a></td></tr>
<tr class="memdesc:a922a1f328e0a270111d97ee85954b05d"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of CS register <br /></td></tr>
<tr class="separator:a922a1f328e0a270111d97ee85954b05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1762d922d2def5d3c44c397cf6db1105"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1762d922d2def5d3c44c397cf6db1105"></a>
<a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a1762d922d2def5d3c44c397cf6db1105">regDataSreg</a></td></tr>
<tr class="memdesc:a1762d922d2def5d3c44c397cf6db1105"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of DS register <br /></td></tr>
<tr class="separator:a1762d922d2def5d3c44c397cf6db1105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Empirics</div></td></tr>
<tr class="memitem:a9414a4e585ab47514144871a585cc120"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structbytes__t.html">bytes_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a9414a4e585ab47514144871a585cc120">codestart</a></td></tr>
<tr class="memdesc:a9414a4e585ab47514144871a585cc120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of typical code start sequences.  <a href="#a9414a4e585ab47514144871a585cc120">More...</a><br /></td></tr>
<tr class="separator:a9414a4e585ab47514144871a585cc120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3849caf742c36dc743f0aa88267221a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structbytes__t.html">bytes_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#ab3849caf742c36dc743f0aa88267221a">retcodes</a></td></tr>
<tr class="memdesc:ab3849caf742c36dc743f0aa88267221a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of 'return' instruction opcodes.  <a href="#ab3849caf742c36dc743f0aa88267221a">More...</a><br /></td></tr>
<tr class="separator:ab3849caf742c36dc743f0aa88267221a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a17805487554d99d5854c1cb9f616b34f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17805487554d99d5854c1cb9f616b34f"></a>
<a class="el" href="structprocessor__t.html#abb16014fd9a56ce9cdd3bf1b7965f205">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a17805487554d99d5854c1cb9f616b34f">has_segregs</a> (<a class="el" href="structprocessor__t.html#acbe4f7fded38c0295e5773fd603489a2">void</a>) const </td></tr>
<tr class="memdesc:a17805487554d99d5854c1cb9f616b34f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group___p_r__.html#gaa5d76a1fe1338a80404a0ca7a7ced6d0" title="has segment registers? ">PR_SEGS</a> <br /></td></tr>
<tr class="separator:a17805487554d99d5854c1cb9f616b34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908e565269807e52ddf5d960510f3d29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a908e565269807e52ddf5d960510f3d29"></a>
<a class="el" href="structprocessor__t.html#abb16014fd9a56ce9cdd3bf1b7965f205">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a908e565269807e52ddf5d960510f3d29">use32</a> (<a class="el" href="structprocessor__t.html#acbe4f7fded38c0295e5773fd603489a2">void</a>) const </td></tr>
<tr class="memdesc:a908e565269807e52ddf5d960510f3d29"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group___p_r__.html#ga4641211435ce736ed30c9ff0a558cf01" title="supports 64-bit addressing? ">PR_USE64</a> or <a class="el" href="group___p_r__.html#gab86fc012cafb2de8b39fefc055941d17" title="supports 32-bit addressing? ">PR_USE32</a> <br /></td></tr>
<tr class="separator:a908e565269807e52ddf5d960510f3d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231aa855508509abc1bb228ad245f5ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a231aa855508509abc1bb228ad245f5ce"></a>
<a class="el" href="structprocessor__t.html#abb16014fd9a56ce9cdd3bf1b7965f205">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a231aa855508509abc1bb228ad245f5ce">use64</a> (<a class="el" href="structprocessor__t.html#acbe4f7fded38c0295e5773fd603489a2">void</a>) const </td></tr>
<tr class="memdesc:a231aa855508509abc1bb228ad245f5ce"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group___p_r__.html#ga4641211435ce736ed30c9ff0a558cf01" title="supports 64-bit addressing? ">PR_USE64</a> <br /></td></tr>
<tr class="separator:a231aa855508509abc1bb228ad245f5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb3f1e991fb7ba81b066557108a2436"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecb3f1e991fb7ba81b066557108a2436"></a>
<a class="el" href="structprocessor__t.html#abb16014fd9a56ce9cdd3bf1b7965f205">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#aecb3f1e991fb7ba81b066557108a2436">ti</a> (<a class="el" href="structprocessor__t.html#acbe4f7fded38c0295e5773fd603489a2">void</a>) const </td></tr>
<tr class="memdesc:aecb3f1e991fb7ba81b066557108a2436"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group___p_r__.html#ga257f9d36eb8bf8c36a28e014f3deedc5" title="the processor module supports type information callbacks ">PR_TYPEINFO</a> <br /></td></tr>
<tr class="separator:aecb3f1e991fb7ba81b066557108a2436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac4f88e3d7b0500cc1fb05031d07624d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac4f88e3d7b0500cc1fb05031d07624d"></a>
<a class="el" href="structprocessor__t.html#abb16014fd9a56ce9cdd3bf1b7965f205">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#aac4f88e3d7b0500cc1fb05031d07624d">ti2</a> (<a class="el" href="structprocessor__t.html#acbe4f7fded38c0295e5773fd603489a2">void</a>) const </td></tr>
<tr class="memdesc:aac4f88e3d7b0500cc1fb05031d07624d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group___p_r__.html#gab8b1f08d470b9273bfe2e4f7007ae14b" title="has support for tinfo_t ">PR_TINFO</a> <br /></td></tr>
<tr class="separator:aac4f88e3d7b0500cc1fb05031d07624d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ab83b3afef793c8097a50d498045f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12ab83b3afef793c8097a50d498045f4"></a>
<a class="el" href="structprocessor__t.html#abb16014fd9a56ce9cdd3bf1b7965f205">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a12ab83b3afef793c8097a50d498045f4">stkup</a> (<a class="el" href="structprocessor__t.html#acbe4f7fded38c0295e5773fd603489a2">void</a>) const </td></tr>
<tr class="memdesc:a12ab83b3afef793c8097a50d498045f4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group___p_r__.html#ga6bd7458e91aaf2970f7e6e82b87b0c67" title="the stack grows up ">PR_STACK_UP</a> <br /></td></tr>
<tr class="separator:a12ab83b3afef793c8097a50d498045f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24de6bbf100bfb38ed2765066ddd7221"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24de6bbf100bfb38ed2765066ddd7221"></a>
<a class="el" href="structprocessor__t.html#abb16014fd9a56ce9cdd3bf1b7965f205">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a24de6bbf100bfb38ed2765066ddd7221">use_tbyte</a> (<a class="el" href="structprocessor__t.html#acbe4f7fded38c0295e5773fd603489a2">void</a>) const </td></tr>
<tr class="memdesc:a24de6bbf100bfb38ed2765066ddd7221"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group___p_r__.html#ga196de44585ee70b23e01cb9266aff600" title="BTMT_SPECFLT means _TBYTE type ">PR_USE_TBYTE</a> <br /></td></tr>
<tr class="separator:a24de6bbf100bfb38ed2765066ddd7221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e0b7613ad405cf7b165b59c9ba02c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#ac1e0b7613ad405cf7b165b59c9ba02c0">get_segm_bitness</a> (<a class="el" href="structprocessor__t.html#acbe4f7fded38c0295e5773fd603489a2">void</a>) const </td></tr>
<tr class="memdesc:ac1e0b7613ad405cf7b165b59c9ba02c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get segment bitness.  <a href="#ac1e0b7613ad405cf7b165b59c9ba02c0">More...</a><br /></td></tr>
<tr class="separator:ac1e0b7613ad405cf7b165b59c9ba02c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe691f9f3c80817bd9d1e19e8ee5f926"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#abe691f9f3c80817bd9d1e19e8ee5f926">get_stkvar_scale</a> (<a class="el" href="structprocessor__t.html#acbe4f7fded38c0295e5773fd603489a2">void</a>)</td></tr>
<tr class="memdesc:abe691f9f3c80817bd9d1e19e8ee5f926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stack variable scaling factor.  <a href="#abe691f9f3c80817bd9d1e19e8ee5f926">More...</a><br /></td></tr>
<tr class="separator:abe691f9f3c80817bd9d1e19e8ee5f926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46368eb35efba22852d976cee36f1b5d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a> (<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *u_ana)(<a class="el" href="structprocessor__t.html#acbe4f7fded38c0295e5773fd603489a2">void</a>)</td></tr>
<tr class="memdesc:a46368eb35efba22852d976cee36f1b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze one instruction and fill 'cmd' structure.  <a href="#a46368eb35efba22852d976cee36f1b5d">More...</a><br /></td></tr>
<tr class="separator:a46368eb35efba22852d976cee36f1b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9738a5b48962cd3d2f90960bae0903e6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a9738a5b48962cd3d2f90960bae0903e6">int</a> (<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *u_emu)(<a class="el" href="structprocessor__t.html#acbe4f7fded38c0295e5773fd603489a2">void</a>)</td></tr>
<tr class="memdesc:a9738a5b48962cd3d2f90960bae0903e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emulate instruction, create cross-references, plan to analyze subsequent instructions, modify flags etc.  <a href="#a9738a5b48962cd3d2f90960bae0903e6">More...</a><br /></td></tr>
<tr class="separator:a9738a5b48962cd3d2f90960bae0903e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228e2d885b84e4dfafb0718e9119074d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a228e2d885b84e4dfafb0718e9119074d">void</a> (<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *u_out)(void)</td></tr>
<tr class="memdesc:a228e2d885b84e4dfafb0718e9119074d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate text representation of an instruction in <a class="el" href="ua_8hpp.html#a9171b306fa900f4c70a03c024e6e1127" title="Structure holding information about the current instruction. ">cmd</a> structure.  <a href="#a228e2d885b84e4dfafb0718e9119074d">More...</a><br /></td></tr>
<tr class="separator:a228e2d885b84e4dfafb0718e9119074d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb16014fd9a56ce9cdd3bf1b7965f205"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#abb16014fd9a56ce9cdd3bf1b7965f205">bool</a> (<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *u_outop)(<a class="el" href="classop__t.html">op_t</a> &amp;op)</td></tr>
<tr class="memdesc:abb16014fd9a56ce9cdd3bf1b7965f205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate text representation of an instruction operand.  <a href="#abb16014fd9a56ce9cdd3bf1b7965f205">More...</a><br /></td></tr>
<tr class="separator:abb16014fd9a56ce9cdd3bf1b7965f205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ea92530299ebf826ac2ed110c92f99"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a18ea92530299ebf826ac2ed110c92f99">void</a> (<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *d_out)(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ea)</td></tr>
<tr class="memdesc:a18ea92530299ebf826ac2ed110c92f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate text representation of data items.  <a href="#a18ea92530299ebf826ac2ed110c92f99">More...</a><br /></td></tr>
<tr class="separator:a18ea92530299ebf826ac2ed110c92f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Byte size</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Number of 8bit bytes required to hold one byte of the target processor.</p>
</div></td></tr>
<tr class="memitem:a33f991813d3e0cc28375d5330dd246f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33f991813d3e0cc28375d5330dd246f3"></a>
<a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a33f991813d3e0cc28375d5330dd246f3">cbsize</a> (<a class="el" href="structprocessor__t.html#acbe4f7fded38c0295e5773fd603489a2">void</a>)</td></tr>
<tr class="memdesc:a33f991813d3e0cc28375d5330dd246f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">for code segments <br /></td></tr>
<tr class="separator:a33f991813d3e0cc28375d5330dd246f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d79d528bb32036ab8d76d102ee0037f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d79d528bb32036ab8d76d102ee0037f"></a>
<a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a3d79d528bb32036ab8d76d102ee0037f">dbsize</a> (<a class="el" href="structprocessor__t.html#acbe4f7fded38c0295e5773fd603489a2">void</a>)</td></tr>
<tr class="memdesc:a3d79d528bb32036ab8d76d102ee0037f"><td class="mdescLeft">&#160;</td><td class="mdescRight">for non-code segments <br /></td></tr>
<tr class="separator:a3d79d528bb32036ab8d76d102ee0037f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aedd76f79cf248c21d1d511be5a89984e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984e">idp_notify</a> { <br />
&#160;&#160;<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ead09d825e3a06a4da38d947c89f0dc7d6">init</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea0c4160d603e65c9ad9692d0894186dc5">term</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eaa0fccf088abc13eaf4b9504b2e935f40">newprc</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea5b22ecb69362bedcd41d2dd96f127825">newasm</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eafd5634739c83445ae49d2b6fbcaa3156">newfile</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea5153b1da15819d7cfb50f0e6011cc68a">oldfile</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea3bd786d5abef2b89a49ec551c29923a6">newbinary</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea825557c3abb97464713ee3eb5481dec4">endbinary</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea9bb1076de51f827f89304770ae3bcc62">newseg</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea10401e960dc3e31f969d914b62212a27">assemble</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eac0ea1bd9a1ae7b45bd4e0593c3f6591d">obsolete_makemicro</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eae1fe2962023065b78448f9426f6d78ed">outlabel</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eadd2753541373f44f94f0dbe02a439997">rename</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea2fb632d6b27a885bed07ec866e6004ff">may_show_sreg</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea140eba234d9d2a1ae82caa2a6afe95b0">closebase</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eaa4df93acbd2f8bc65cc4e6dbc3720dd9">load_idasgn</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ead2c8a172783b101f8cbfbff105dfd6a0">coagulate</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eae8053ec77f80a3f6170a8b473d2ce43c">auto_empty</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea2b181a6daed389a5bfa396145125e308">auto_queue_empty</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ead9534f2f3faf04b965e48e3f17e3eee0">func_bounds</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eac179448b584b87ef75f50ee1150f8e9f">may_be_func</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea4e75b2f381ae281148c4de8cf9433a81">is_sane_insn</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea6b5e3ebb93f94069cffca47acdbcdad2">is_jump_func</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea67e8bbd84c6eb2eaf761dbcfbfdf904a">gen_regvar_def</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea61b1515d5f7ee035cccb73b691c26d0a">setsgr</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea40e8e0b01f3a0ae8469d9991375267ff">set_compiler</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea8de1a3c439f77048c7a8bc469270a02a">is_basic_block_end</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea22ce5f8bacca5ca9d5319da573ecc3ce">reglink</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eaddd275da7b22b2a505f94f0af8dfd906">get_vxd_name</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eacd9aaeda1dcf6d0b0e2227eccb9a271c">custom_ana</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea8d35299db7e653f07c8c90bbfe855a5c">custom_out</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eac8469b7c1fd671cb9187c3286d9b5f3b">custom_emu</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eac24d2626111b4e099057b36616871ca7">custom_outop</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eae27c30a93a2dfe66e2b70320a19866d8">custom_mnem</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eaf6307dde082a4bd62900e45fef338501">undefine</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea9f78e1fd9e45d1521dfc56b229342e12">make_code</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eacb90b54e835485520ac181185574fda6">make_data</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea37e657783ac29653476f0c0721bd6c81">moving_segm</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea7cea65c257bea65100954da55ad28980">move_segm</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eaa3c0c097ced9b892f0f90d165ee10d69">is_call_insn</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eafe60282cb0f6faae0d06ed53e8ddaa81">is_ret_insn</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea2a50b8024949750e15f3778a78ac5a80">get_stkvar_scale_factor</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eab05b7200f3b9cda329e607777d27eb87">create_flat_group</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eacc5b8c110b44eb916e409fea3c158d73">kernel_config_loaded</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea4bd3328749918d8e1d199549b97801f8">might_change_sp</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea64d39146e66f04ae3b3c0cdd1fa576f0">is_alloca_probe</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eacc60edfaf70ff44f7b957b11d53490a6">out_3byte</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea5b097ae4d564a0a9176ac079b714fe1c">get_reg_name</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea2334cbb33bfe0e02cab279b29ec70418">savebase</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea3523e55c8e78641dc348395ef1ec4aaf">gen_asm_or_lst</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eaa235dd1d72a74c8308cf03c794bb1fff">out_src_file_lnnum</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ead52219552296246c6331d81a30453a30">get_autocmt</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eaa23cf0295698d2f63e1c20bcebeb73d7">is_insn_table_jump</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea5dcd61fc8d775da4487c89926bf1c6e5">auto_empty_finally</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea210f9b85ea9f40c7ccdfa78a9de5e2c8">loader_finished</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea774fc18de802150f174a196843239b99">loader_elf_machine</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea6f234203b93c1589b8059874f2910580">is_indirect_jump</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea5ff7d1d93c57b88ad49b5a19ec13ed1e">verify_noreturn</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea17f02eea78c6c2d18fa553263e593395">verify_sp</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea29bb76dc87630c4ed16786f6207362c3">renamed</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea8fc071cf6a534417335a0e6052b1aec1">add_func</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea118e3487cf39cc227a1d5f3ef3523a71">del_func</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eafc94b992ac2d6bad58eda74fc9a47081">set_func_start</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eacb3d6e97908921fe067383de341ea5ae">set_func_end</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea26cbd9ec4ffdeab5db6d57649dbec56b">treat_hindering_item</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea7641afcb07036d80aee1ad1bf0ef51c4">str2reg</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea87a6e4deacb25e4773abc0d93b88e786">create_switch_xrefs</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea2da4bf6d48c8a6f37e70d6465c352869">calc_switch_cases</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea476d572d630603d5710db684c22fc7a2">determined_main</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eacdfa46e9950f38783fee593a3a369ccc">preprocess_chart</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea88ff49f5cf097b20a4458ab0862c41f9">get_bg_color</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ead1acdf5c83b42ce3f84d4547e6f9b16d">validate_flirt_func</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eacedfaf92b57b33de650c90876a084e83">get_operand_string</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eac9fd0d5b690e1da30b9cd3a64e563419">add_cref</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eafd39f9ed2a4e4ea13e03a2ca9b1b1594">add_dref</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea5e0b078bd13402ea94ad4e1d10abfeed">del_cref</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea8af3f04d6e33df25a9f20e90756cbf1f">del_dref</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea013ece0fe46a10706a1015ca8d36d793">coagulate_dref</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea5f7b735fc0b049ec62508819a86c02df">register_custom_fixup</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ead3935b2d84480fc4c075c0f5c0435d94">custom_refinfo</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea693ef952813662dcf9a84e0037c1bd84">set_proc_options</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ead644b0baf59f1567abcbcb5739dae790">adjust_libfunc_ea</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea72dbff4503d6bf55c29cc730b88c2fec">extlang_changed</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea0237604331ac3319d7fe88b02b47d188">last_cb_before_debugger</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eabb61e6916d6ee57323b77a4a0cc350a5">obsolete_get_operand_info</a> = 100, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea35b1f583a42e152f0e06ab6995b7de5a">next_exec_insn</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea3422ea57c2feda4b6fb4e59f87d68e11">calc_step_over</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eaa223dab5c41c3917e60ca2379c64d543">get_macro_insn_head</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea53ee27b3f50560b5d41ea8091c273c38">get_dbr_opnum</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eaee38edc59c772e872c8c3f7462f73580">insn_reads_tbit</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea3c474aeefb0082f3046ed37c4a53227b">get_operand_info</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea9e4b3b916acbc04b242b198e0108ea23">calc_next_eas</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea83c7b24e22b7d8e81be84e892f545551">clean_tbit</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea9c56a4426a67497592f6107890c5213d">get_reg_info2</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eac3d3a2df33af113b3319cce93353d15e">setup_til</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea1cb36be1ae9bf4cdbd9ba4df0a0b8203">based_ptr</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea3bfa3be2f6e625d3306e75a9225ba315">max_ptr_size</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea6f8cc9547653ad01ca7b065d50dfd3bd">get_default_enum_size</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eaad326c3589035cdce293a6a645a821cb">calc_cdecl_purged_bytes2</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea4fd473a3014b81fb1c97cf797e7dbb86">get_stkarg_offset2</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eaaea5993fa21996059b962cdd376346c6">til_for_file</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea7af5797fbb1fa57d6d92e76e99b93c67">equal_reglocs</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea27d4c19be54512c14f613fe9bce82915">decorate_name3</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea4f4955d8d640ed12b13ded86d1c22317">calc_retloc3</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eaec8ff17b6d580d79f60f8397671bebc7">calc_varglocs3</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea1958d45eea679d42701b739c7becb915">calc_arglocs3</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea0f02557a3e296491ae7c182ae8ff6534">use_stkarg_type3</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea2a8b28dcd4e5ad63784ae609dc20a63d">use_regarg_type3</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea1480ed6b5161c51a9f63172024b80cf3">use_arg_types3</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea5044da7bebdd164b8b1ba788d9452e01">calc_purged_bytes3</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea5f6b0fc3daca67c9f92b3d57da775bdc">shadow_args_size</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea439dec44180c98957182e8a96ffeb003">get_varcall_regs3</a>, 
<br />
&#160;&#160;<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eaedebf14590250f5902778b65efc70600">get_fastcall_regs3</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea778866fd62f1a5c4881d491ae0fc9e53">get_thiscall_regs3</a>, 
<a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eab5b95fa3c04172f8e18730196fd93c2e">loader</a> =1000
<br />
 }</td></tr>
<tr class="memdesc:aedd76f79cf248c21d1d511be5a89984e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback notification codes.  <a href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984e">More...</a><br /></td></tr>
<tr class="separator:aedd76f79cf248c21d1d511be5a89984e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Disassembly sections</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpbf1000e9910a4a5f380843988347bb6e"></a>The following functions generate portions of the disassembled text.</p>
</td></tr>
<tr class="memitem:ae1defa8c97b614caa33ec4904e81ffc4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1defa8c97b614caa33ec4904e81ffc4"></a>
<a class="el" href="structprocessor__t.html#acbe4f7fded38c0295e5773fd603489a2">void</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#ae1defa8c97b614caa33ec4904e81ffc4">header</a> )(<a class="el" href="structprocessor__t.html#acbe4f7fded38c0295e5773fd603489a2">void</a>)</td></tr>
<tr class="memdesc:ae1defa8c97b614caa33ec4904e81ffc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to produce start of disassembled text. <br /></td></tr>
<tr class="separator:ae1defa8c97b614caa33ec4904e81ffc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6adf89d95027c8cfe068e8e2067408eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6adf89d95027c8cfe068e8e2067408eb"></a>
<a class="el" href="structprocessor__t.html#acbe4f7fded38c0295e5773fd603489a2">void</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a6adf89d95027c8cfe068e8e2067408eb">footer</a> )(<a class="el" href="structprocessor__t.html#acbe4f7fded38c0295e5773fd603489a2">void</a>)</td></tr>
<tr class="memdesc:a6adf89d95027c8cfe068e8e2067408eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to produce end of disassembled text. <br /></td></tr>
<tr class="separator:a6adf89d95027c8cfe068e8e2067408eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221c6e163bf88a5389b568b8b58fb50b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a221c6e163bf88a5389b568b8b58fb50b"></a>
<a class="el" href="structprocessor__t.html#acbe4f7fded38c0295e5773fd603489a2">void</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a221c6e163bf88a5389b568b8b58fb50b">segstart</a> )(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ea)</td></tr>
<tr class="memdesc:a221c6e163bf88a5389b568b8b58fb50b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to produce start of segment. <br /></td></tr>
<tr class="separator:a221c6e163bf88a5389b568b8b58fb50b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe4f7fded38c0295e5773fd603489a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acbe4f7fded38c0295e5773fd603489a2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#acbe4f7fded38c0295e5773fd603489a2">void</a> (<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *segend)(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ea)</td></tr>
<tr class="memdesc:acbe4f7fded38c0295e5773fd603489a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to produce end of segment. <br /></td></tr>
<tr class="separator:acbe4f7fded38c0295e5773fd603489a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ea0a33706e0ee35eaab7da7a69afb8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a10ea0a33706e0ee35eaab7da7a69afb8">void</a> (<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *assumes)(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ea)</td></tr>
<tr class="memdesc:a10ea0a33706e0ee35eaab7da7a69afb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to produce assume directives when segment register value changes.  <a href="#a10ea0a33706e0ee35eaab7da7a69afb8">More...</a><br /></td></tr>
<tr class="separator:a10ea0a33706e0ee35eaab7da7a69afb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Instruction set</h2></td></tr>
<tr class="memitem:a7a59ab3d03679871b5384d9bca5dfcf3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a59ab3d03679871b5384d9bca5dfcf3"></a>
<a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a7a59ab3d03679871b5384d9bca5dfcf3">instruc_start</a></td></tr>
<tr class="memdesc:a7a59ab3d03679871b5384d9bca5dfcf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">icode of the first instruction <br /></td></tr>
<tr class="separator:a7a59ab3d03679871b5384d9bca5dfcf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c65c0c97da5e3c8a4b1876eb313e3e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72c65c0c97da5e3c8a4b1876eb313e3e"></a>
<a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a72c65c0c97da5e3c8a4b1876eb313e3e">instruc_end</a></td></tr>
<tr class="memdesc:a72c65c0c97da5e3c8a4b1876eb313e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">icode of the last instruction + 1 <br /></td></tr>
<tr class="separator:a72c65c0c97da5e3c8a4b1876eb313e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb7cfbf39771b646cfc5e5d43259175"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fb7cfbf39771b646cfc5e5d43259175"></a>
const <a class="el" href="structinstruc__t.html">instruc_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#a6fb7cfbf39771b646cfc5e5d43259175">instruc</a></td></tr>
<tr class="memdesc:a6fb7cfbf39771b646cfc5e5d43259175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of instructions. <br /></td></tr>
<tr class="separator:a6fb7cfbf39771b646cfc5e5d43259175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58c2a400e68a56e9299338aab2b2029"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structprocessor__t.html#abb16014fd9a56ce9cdd3bf1b7965f205">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structprocessor__t.html#ad58c2a400e68a56e9299338aab2b2029">is_canon_insn</a> (<a class="el" href="pro_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> itype) const </td></tr>
<tr class="memdesc:ad58c2a400e68a56e9299338aab2b2029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the given value specify a valid instruction for this instruction set?.  <a href="#ad58c2a400e68a56e9299338aab2b2029">More...</a><br /></td></tr>
<tr class="separator:ad58c2a400e68a56e9299338aab2b2029"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="aedd76f79cf248c21d1d511be5a89984e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984e">processor_t::idp_notify</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback notification codes. </p>
<p>These are passed to <a class="el" href="structprocessor__t.html#ab0d7131aaf457b74265eeeb999652579" title="Various notifications for the idp. ">notify()</a> when certain events occur in the kernel, allowing the processor module to take appropriate action.</p>
<p>If you are not developing a processor module, many of these codes already have a corresponding function to use instead ( <a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eaa3c0c097ced9b892f0f90d165ee10d69">is_call_insn</a> vs <a class="el" href="idp_8hpp.html#a1f16313c928c4a05ed84fe9320f92df1" title="Is the instruction at the specified address a &quot;call&quot;? ">is_call_insn(ea_t)</a>, for example).</p>
<p>If you are developing a processor module, your <a class="el" href="structprocessor__t.html#ab0d7131aaf457b74265eeeb999652579" title="Various notifications for the idp. ">notify()</a> function must implement the desired behavior when called with a given code. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ead09d825e3a06a4da38d947c89f0dc7d6"></a>init&#160;</td><td class="fielddoc">
<p>The IDP module is just loaded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idp_modname</td><td>(const char *) processor module name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on failure </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea0c4160d603e65c9ad9692d0894186dc5"></a>term&#160;</td><td class="fielddoc">
<p>The IDP module is being unloaded. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eaa0fccf088abc13eaf4b9504b2e935f40"></a>newprc&#160;</td><td class="fielddoc">
<p>Before changing processor type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pnum</td><td>(int) processor number in the array of processor names </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>prohibit </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea5b22ecb69362bedcd41d2dd96f127825"></a>newasm&#160;</td><td class="fielddoc">
<p>Before setting a new assembler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asmnum</td><td>(int) </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eafd5634739c83445ae49d2b6fbcaa3156"></a>newfile&#160;</td><td class="fielddoc">
<p>A new file is loaded (already). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>(char *) input file name </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea5153b1da15819d7cfb50f0e6011cc68a"></a>oldfile&#160;</td><td class="fielddoc">
<p>An old file is loaded (already). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>(char *) input file name </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea3bd786d5abef2b89a49ec551c29923a6"></a>newbinary&#160;</td><td class="fielddoc">
<p>Before loading a binary file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>(char *) binary file name </td></tr>
    <tr><td class="paramname">fileoff</td><td>(<a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e" title="unsigned 32 bit value ">uint32</a>) offset in the file </td></tr>
    <tr><td class="paramname">basepara</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) base loading paragraph </td></tr>
    <tr><td class="paramname">binoff</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) loader offset </td></tr>
    <tr><td class="paramname">nbytes</td><td>(<a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e" title="unsigned 32 bit value ">uint32</a>) number of bytes to load </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea825557c3abb97464713ee3eb5481dec4"></a>endbinary&#160;</td><td class="fielddoc">
<p>After loading a binary file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ok</td><td>(bool) file loaded successfully? </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea9bb1076de51f827f89304770ae3bcc62"></a>newseg&#160;</td><td class="fielddoc">
<p>A new segment is about to be created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seg</td><td>(<a class="el" href="classsegment__t.html" title="Describes a program segment. ">segment_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">&lt;=0</td><td>segment should not be created </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea10401e960dc3e31f969d914b62212a27"></a>assemble&#160;</td><td class="fielddoc">
<p>Assemble an instruction. </p>
<p>(display a warning if an error is found). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) linear address of instruction </td></tr>
    <tr><td class="paramname">cs</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) cs of instruction </td></tr>
    <tr><td class="paramname">ip</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) ip of instruction </td></tr>
    <tr><td class="paramname">use32</td><td>(bool) is 32bit segment? </td></tr>
    <tr><td class="paramname">line</td><td>(const char *) line to assemble </td></tr>
    <tr><td class="paramname">bin</td><td>(<a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc" title="unsigned 8 bit value ">uchar</a> *) pointer to output opcode buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of the instruction in bytes </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eac0ea1bd9a1ae7b45bd4e0593c3f6591d"></a>obsolete_makemicro&#160;</td><td class="fielddoc">
<p>Generate microcode for the instruction in 'cmd' structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>(mblock_t *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MICRO_... error codes </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eae1fe2962023065b78448f9426f6d78ed"></a>outlabel&#160;</td><td class="fielddoc">
<p>The kernel is going to generate an instruction label line or a function header. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">colored_name</td><td>(const char *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;=0 if the kernel should not generate the label </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eadd2753541373f44f94f0dbe02a439997"></a>rename&#160;</td><td class="fielddoc">
<p>The kernel is going to rename a byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">new_name</td><td>(const char *) </td></tr>
    <tr><td class="paramname">flags</td><td>(int) <a class="el" href="group___s_n__.html">Set name flags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;=0 if the kernel should not rename it. also see <a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea29bb76dc87630c4ed16786f6207362c3">renamed</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea2fb632d6b27a885bed07ec866e6004ff"></a>may_show_sreg&#160;</td><td class="fielddoc">
<p>The kernel wants to display the segment registers in the messages window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;=0 if the kernel should not show the segment registers. (assuming that the module has done it) </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea140eba234d9d2a1ae82caa2a6afe95b0"></a>closebase&#160;</td><td class="fielddoc">
<p>The database will be closed now. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eaa4df93acbd2f8bc65cc4e6dbc3720dd9"></a>load_idasgn&#160;</td><td class="fielddoc">
<p>FLIRT signature has been loaded for normal processing (not for recognition of startup sequences). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">short_sig_name</td><td>(const char *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ead2c8a172783b101f8cbfbff105dfd6a0"></a>coagulate&#160;</td><td class="fielddoc">
<p>Try to define some unexplored bytes. </p>
<p>This notification will be called if the kernel tried all possibilities and could not find anything more useful than to convert to array of bytes. The module can help the kernel and convert the bytes into something more useful. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of converted bytes + 1 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eae8053ec77f80a3f6170a8b473d2ce43c"></a>auto_empty&#160;</td><td class="fielddoc">
<p>Info: all analysis queues are empty. </p>
<p>This callback is called once when the initial analysis is finished. If the queue is not empty upon the return from this callback, it will be called later again. See also <a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea5dcd61fc8d775da4487c89926bf1c6e5">auto_empty_finally</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea2b181a6daed389a5bfa396145125e308"></a>auto_queue_empty&#160;</td><td class="fielddoc">
<p>One analysis queue is empty. </p>
<p>This callback can be called many times, so only the <a class="el" href="auto_8hpp.html#a54c02a779d81dc49068a6fe438794618" title="Put single address into a queue. Queues keep addresses sorted. ">autoMark()</a> functions can be used from it (other functions may work but it is not tested). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>(<a class="el" href="auto_8hpp.html#ae3fe1a7af243ca1880188111193297cf" title="identifies an autoanalysis queue - see Autoanalysis queues ">atype_t</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>yes, keep the queue empty </td></tr>
    <tr><td class="paramname">&lt;=0</td><td>no, the queue is not empty anymore </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ead9534f2f3faf04b965e48e3f17e3eee0"></a>func_bounds&#160;</td><td class="fielddoc">
<p><a class="el" href="funcs_8hpp.html#a060aa341534e4994eb7918dcd15e0506" title="Determine the boundaries of a new function. ">find_func_bounds()</a> finished its work. </p>
<p>The module may fine tune the function bounds </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">possible_return_code</td><td>(int *) </td></tr>
    <tr><td class="paramname">pfn</td><td>(<a class="el" href="classfunc__t.html" title="A function is a set of continuous ranges of addresses with characteristics. ">func_t</a> *) </td></tr>
    <tr><td class="paramname">max_func_end_ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) (from the kernel's point of view) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eac179448b584b87ef75f50ee1150f8e9f"></a>may_be_func&#160;</td><td class="fielddoc">
<p>Can a function start here?. </p>
<p>the instruction is in 'cmd', the idp module is allowed to modify 'cmd' </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>(int) autoanalysis phase<ul>
<li>0: creating functions</li>
<li>1: creating chunks </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>probability 0..100 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea4e75b2f381ae281148c4de8cf9433a81"></a>is_sane_insn&#160;</td><td class="fielddoc">
<p>Is the instruction sane for the current file type?. </p>
<p>The instruction is in 'cmd'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">no_crefs</td><td>(int)<ul>
<li>1: the instruction has no code refs to it. ida just tries to convert unexplored bytes to an instruction (but there is no other reason to convert them into an instruction)</li>
<li>0: the instruction is created because of some coderef, user request or another weighty reason. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">&lt;=0</td><td>no, the instruction isn't likely to appear in the program </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea6b5e3ebb93f94069cffca47acdbcdad2"></a>is_jump_func&#160;</td><td class="fielddoc">
<p>Is the function a trivial "jump" function?. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>(<a class="el" href="classfunc__t.html" title="A function is a set of continuous ranges of addresses with characteristics. ">func_t</a> *) </td></tr>
    <tr><td class="paramname">jump_target</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a> *) </td></tr>
    <tr><td class="paramname">func_pointer</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;=0</td><td>no </td></tr>
    <tr><td class="paramname">1</td><td>don't know </td></tr>
    <tr><td class="paramname">2</td><td>yes, see 'jump_target' and 'func_pointer' </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea67e8bbd84c6eb2eaf761dbcfbfdf904a"></a>gen_regvar_def&#160;</td><td class="fielddoc">
<p>Generate register variable definition line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>(<a class="el" href="structregvar__t.html" title="A register variable allows the user to rename a general processor register to a meaningful name...">regvar_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;=0</td><td>ok, generated the definition text </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea61b1515d5f7ee035cccb73b691c26d0a"></a>setsgr&#160;</td><td class="fielddoc">
<p>The kernel has changed a segment register value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startEA</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">endEA</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">regnum</td><td>(int) </td></tr>
    <tr><td class="paramname">value</td><td>(<a class="el" href="pro_8h.html#a633a07e2920351503da14c0adcd3edfd" title="segment selector ">sel_t</a>) </td></tr>
    <tr><td class="paramname">old_value</td><td>(<a class="el" href="pro_8h.html#a633a07e2920351503da14c0adcd3edfd" title="segment selector ">sel_t</a>) </td></tr>
    <tr><td class="paramname">tag</td><td>(<a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc" title="unsigned 8 bit value ">uchar</a>) <a class="el" href="group___s_r__.html">Segment register area tags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea40e8e0b01f3a0ae8469d9991375267ff"></a>set_compiler&#160;</td><td class="fielddoc">
<p>The kernel has changed the compiler information. </p>
<p>( <a class="el" href="structidainfo.html#afc34ca1c9144e25fd5be9ec6ec13a527" title="Target compiler. ">idainfo::cc</a> structure) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea8de1a3c439f77048c7a8bc469270a02a"></a>is_basic_block_end&#160;</td><td class="fielddoc">
<p>Is the current instruction end of a basic block?. </p>
<p>This function should be defined for processors with delayed jump slots. The current instruction is stored in <a class="el" href="ua_8hpp.html#a9171b306fa900f4c70a03c024e6e1127" title="Structure holding information about the current instruction. ">cmd</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">call_insn_stops_block</td><td>(bool) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>unknown </td></tr>
    <tr><td class="paramname">&lt;=0</td><td>no </td></tr>
    <tr><td class="paramname">2</td><td>yes </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea22ce5f8bacca5ca9d5319da573ecc3ce"></a>reglink&#160;</td><td class="fielddoc">
<p>IBM PC only, ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eaddd275da7b22b2a505f94f0af8dfd906"></a>get_vxd_name&#160;</td><td class="fielddoc">
<p>IBM PC only, ignore it. </p>
<p>Get Vxd function name </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vxdnum</td><td>(int) </td></tr>
    <tr><td class="paramname">funcnum</td><td>(int) </td></tr>
    <tr><td class="paramname">outbuf</td><td>(char *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eacd9aaeda1dcf6d0b0e2227eccb9a271c"></a>custom_ana&#160;</td><td class="fielddoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>the address to analyze is in <a class="el" href="classinsn__t.html#a68b331560b7f026c120373ca574c2889" title="Linear address of the instruction. ">insn_t::ea</a>.<ul>
<li><a class="el" href="classinsn__t.html#a9fbcacdc71b94dc291138591e317da01" title="Virtual address of the instruction (address within the segment). ">insn_t::ip</a> and <a class="el" href="classinsn__t.html#a44ca1931c490f50b866f38be884b7088" title="Current segment base paragraph. Initialized by the kernel. ">insn_t::cs</a> are initialized too</li>
<li><a class="el" href="classinsn__t.html#aad5d7fad54a9394febd8ed0cda1f85f0" title="Internal code of instruction (only for canonical insns - not user defined!). ">insn_t::itype</a> must be set &gt;= 0x8000</li>
<li><a class="el" href="classinsn__t.html#ac3c2b72b27e268eeb2d55bdcbcdbd2b9" title="Size of instruction in bytes. ">insn_t::size</a> must be set to the instruction length</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>(a good plugin would fill the whole <a class="el" href="ua_8hpp.html#a9171b306fa900f4c70a03c024e6e1127" title="Structure holding information about the current instruction. ">cmd</a> including the operand fields) in the case of error the cmd structure should be kept intact </p><dl class="section return"><dt>Returns</dt><dd>1 + <a class="el" href="classinsn__t.html#ac3c2b72b27e268eeb2d55bdcbcdbd2b9" title="Size of instruction in bytes. ">insn_t::size</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea8d35299db7e653f07c8c90bbfe855a5c"></a>custom_out&#160;</td><td class="fielddoc">
<p>Generate instruction text using the <a class="el" href="lines_8hpp.html#aa5b28d4694c22159f8936c2052dbb0b1" title="Generate ONE line of disassembled text. ">printf_line()</a> function. </p>
<p>Optional notification (depends on the processor module) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>(<a class="el" href="ua_8hpp.html#a9171b306fa900f4c70a03c024e6e1127" title="Structure holding information about the current instruction. ">cmd</a> structure contains information about the instruction) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>2 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eac8469b7c1fd671cb9187c3286d9b5f3b"></a>custom_emu&#160;</td><td class="fielddoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td>(cmd structure contains information about the instruction)</td></tr>
  </table>
  </dd>
</dl>
<p>Optional notification. if absent, the instruction is supposed to be an regular one the kernel will proceed to the analysis of the next instruction </p><dl class="section return"><dt>Returns</dt><dd>2 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eac24d2626111b4e099057b36616871ca7"></a>custom_outop&#160;</td><td class="fielddoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>(<a class="el" href="classop__t.html" title="Operand of an instruction. ">op_t</a> *)</td></tr>
  </table>
  </dd>
</dl>
<p>Optional notification to generate operand text. if absent, the standard operand output function will be called. the output buffer is inited with <a class="el" href="group__output__helpers.html#gaf1c2cd8c878bd3289a5b228c78ff1c1c" title="Initialize output buffer. ">init_output_buffer()</a> and this notification may use out_...() functions from <a class="el" href="ua_8hpp.html" title="Functions that deal with the disassembling of program instructions. ">ua.hpp</a> to form the operand text </p><dl class="section return"><dt>Returns</dt><dd>2 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eae27c30a93a2dfe66e2b70320a19866d8"></a>custom_mnem&#160;</td><td class="fielddoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outbuffer</td><td>(char *) </td></tr>
    <tr><td class="paramname">bufsize</td><td>(size_t)</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="ua_8hpp.html#a9171b306fa900f4c70a03c024e6e1127" title="Structure holding information about the current instruction. ">cmd</a> structure contains information about the instruction. Optional notification. if absent, the IDC function GetMnem() won't work. At least one of <a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea8d35299db7e653f07c8c90bbfe855a5c">custom_out</a> or <a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eae27c30a93a2dfe66e2b70320a19866d8">custom_mnem</a> should be implemented. <a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eacd9aaeda1dcf6d0b0e2227eccb9a271c">custom_ana</a> should always be implemented. These custom_... callbacks will be called for all instructions. It is the responsibility of the plugin to ignore the undesired callbacks </p><dl class="section return"><dt>Returns</dt><dd>2 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eaf6307dde082a4bd62900e45fef338501"></a>undefine&#160;</td><td class="fielddoc">
<p>An item in the database (insn or data) is being deleted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(ea_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;0-ok, &lt;=0-the kernel should stop. if the return value is positive:<ul>
<li>bit0 ignored</li>
<li>bit1 do not delete srareas at the item end </li>
</ul>
</dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea9f78e1fd9e45d1521dfc56b229342e12"></a>make_code&#160;</td><td class="fielddoc">
<p>An instruction is being created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">size</td><td>(<a class="el" href="pro_8h.html#adbc570541d9f9a0c4489f9f1fe5f5699" title="memory chunk size ">asize_t</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">&lt;=0</td><td>the kernel should stop </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eacb90b54e835485520ac181185574fda6"></a>make_data&#160;</td><td class="fielddoc">
<p>A data item is being created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">flags</td><td>(<a class="el" href="pro_8h.html#a55dd00e03168fb5180830e87ef0a2c57" title="32-bit flags for each address ">flags_t</a>) </td></tr>
    <tr><td class="paramname">tid</td><td>(<a class="el" href="pro_8h.html#ad8791d30d19843bc09b78bdf01a852ec" title="type id (for enums, structs, etc) ">tid_t</a>) </td></tr>
    <tr><td class="paramname">len</td><td>(<a class="el" href="pro_8h.html#adbc570541d9f9a0c4489f9f1fe5f5699" title="memory chunk size ">asize_t</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">&lt;=0</td><td>the kernel should stop </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea37e657783ac29653476f0c0721bd6c81"></a>moving_segm&#160;</td><td class="fielddoc">
<p>May the kernel move the segment? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seg</td><td>(<a class="el" href="classsegment__t.html" title="Describes a program segment. ">segment_t</a>) segment to move </td></tr>
    <tr><td class="paramname">to</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) new segment start address </td></tr>
    <tr><td class="paramname">flags</td><td>(int) combination of <a class="el" href="group___m_s_f__.html">Move segment flags</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>yes </td></tr>
    <tr><td class="paramname">&lt;=0</td><td>the kernel should stop </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea7cea65c257bea65100954da55ad28980"></a>move_segm&#160;</td><td class="fielddoc">
<p>A segment is moved. </p>
<p>Fix processor dependent address sensitive information </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) old segment address </td></tr>
    <tr><td class="paramname">seg</td><td>(<a class="el" href="classsegment__t.html" title="Describes a program segment. ">segment_t</a> *) moved segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eaa3c0c097ced9b892f0f90d165ee10d69"></a>is_call_insn&#160;</td><td class="fielddoc">
<p>Is the instruction a "call"? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) instruction address </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>unknown </td></tr>
    <tr><td class="paramname">&lt;=0</td><td>no </td></tr>
    <tr><td class="paramname">2</td><td>yes </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eafe60282cb0f6faae0d06ed53e8ddaa81"></a>is_ret_insn&#160;</td><td class="fielddoc">
<p>Is the instruction a "return"? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) instruction address </td></tr>
    <tr><td class="paramname">strict</td><td>(bool)<ul>
<li>1: report only ret instructions</li>
<li>0: include instructions like "leave" which begins the function epilog </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>unknown </td></tr>
    <tr><td class="paramname">&lt;=0</td><td>no </td></tr>
    <tr><td class="paramname">2</td><td>yes </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea2a50b8024949750e15f3778a78ac5a80"></a>get_stkvar_scale_factor&#160;</td><td class="fielddoc">
<p>Should stack variable references be multiplied by a coefficient before being used in the stack frame?. </p>
<p>Currently used by TMS320C55 because the references into the stack should be multiplied by 2 </p><dl class="section note"><dt>Note</dt><dd><a class="el" href="group___p_r__.html#gaf96c8c11c1d33bf6b8b45cd0c596b9a9" title="use processor_t::get_stkvar_scale callback ">PR_SCALE_STKVARS</a> should be set to use this callback </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>scaling factor </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eab05b7200f3b9cda329e607777d27eb87"></a>create_flat_group&#160;</td><td class="fielddoc">
<p>Create special segment representing the flat group. </p>
<p>(to use for PC mainly) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image_base</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">bitness</td><td>(int) </td></tr>
    <tr><td class="paramname">dataseg_sel</td><td>(<a class="el" href="pro_8h.html#a633a07e2920351503da14c0adcd3edfd" title="segment selector ">sel_t</a>) </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eacc5b8c110b44eb916e409fea3c158d73"></a>kernel_config_loaded&#160;</td><td class="fielddoc">
<p>This callback is called when ida.cfg is parsed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea4bd3328749918d8e1d199549b97801f8"></a>might_change_sp&#160;</td><td class="fielddoc">
<p>Does the instruction at 'ea' modify the stack pointer? (not used yet). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>yes </td></tr>
    <tr><td class="paramname">&lt;=0</td><td>no </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea64d39146e66f04ae3b3c0cdd1fa576f0"></a>is_alloca_probe&#160;</td><td class="fielddoc">
<p>Does the function at 'ea' behave as __alloca_probe? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">2</td><td>yes </td></tr>
    <tr><td class="paramname">1</td><td>no </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eacc60edfaf70ff44f7b957b11d53490a6"></a>out_3byte&#160;</td><td class="fielddoc">
<p>Generate text representation of 3byte data. </p>
<p><a class="el" href="group__output__helpers.html#gaf1c2cd8c878bd3289a5b228c78ff1c1c" title="Initialize output buffer. ">init_output_buffer()</a> is called before this function and all Out... function can be used. <a class="el" href="ua_8hpp.html#aad9bec33eb40ae858e2a708635673d61" title="Flags value for the byte at the start of the current instruction. ">uFlag</a> contains the flags. This callback might be implemented by the processor module to generate custom representation of 3byte data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) address of the data item </td></tr>
    <tr><td class="paramname">value</td><td>(<a class="el" href="pro_8h.html#a1134b580f8da4de94ca6b1de4d37975e" title="unsigned 32 bit value ">uint32</a>) value value to output </td></tr>
    <tr><td class="paramname">analyze_only</td><td>(bool) only create xrefs if necessary. do not generate text representation </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">2</td><td>success </td></tr>
    <tr><td class="paramname">1</td><td>failed </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea5b097ae4d564a0a9176ac079b714fe1c"></a>get_reg_name&#160;</td><td class="fielddoc">
<p>Generate text representation of a register. </p>
<p>Most processor modules do not need to implement this callback. It is useful only if <a class="el" href="structprocessor__t.html#a470124dabad8e9351e326f399e68672a" title="array of register names ">processor_t::regNames</a>[reg] does not provide the correct register name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>(int) internal register number as defined in the processor module </td></tr>
    <tr><td class="paramname">width</td><td>(size_t) register width in bytes </td></tr>
    <tr><td class="paramname">buf</td><td>(char *) output buffer </td></tr>
    <tr><td class="paramname">bufsize</td><td>(size_t) size of output buffer </td></tr>
    <tr><td class="paramname">reghi</td><td>(int) if not -1 then this function will return the register pair </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if error, strlen(buf)+2 otherwise </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea2334cbb33bfe0e02cab279b29ec70418"></a>savebase&#160;</td><td class="fielddoc">
<p>The database is being saved. </p>
<p>Processor module should save its local data </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea3523e55c8e78641dc348395ef1ec4aaf"></a>gen_asm_or_lst&#160;</td><td class="fielddoc">
<p>Callback: generating asm or lst file. </p>
<p>The kernel calls this callback twice, at the beginning and at the end of listing generation. The processor module can intercept this event and adjust its output </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">starting</td><td>(bool) beginning listing generation </td></tr>
    <tr><td class="paramname">fp</td><td>(FILE *) output file </td></tr>
    <tr><td class="paramname">is_asm</td><td>(bool) true:assembler, false:listing </td></tr>
    <tr><td class="paramname">flags</td><td>(int) flags passed to <a class="el" href="loader_8hpp.html#a777046093020c790ec43bd207166bf09" title="Generate an output file. ">gen_file()</a> </td></tr>
    <tr><td class="paramname">outline</td><td>(gen_outline_t **) ptr to ptr to outline callback. if this callback is defined for this code, it will be used by the kernel to output the generated lines </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eaa235dd1d72a74c8308cf03c794bb1fff"></a>out_src_file_lnnum&#160;</td><td class="fielddoc">
<p>Callback: generate analog of: </p>
<p>#line "file.c" 123</p>
<p>directive. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>(const char *) source file (may be NULL) </td></tr>
    <tr><td class="paramname">lnnum</td><td>(size_t) line number </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">2</td><td>directive has been generated </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ead52219552296246c6331d81a30453a30"></a>get_autocmt&#160;</td><td class="fielddoc">
<p>Callback: get dynamic auto comment. </p>
<p>Will be called if the autocomments are enabled and the comment retrieved from ida.int starts with '$!'. <a class="el" href="ua_8hpp.html#a9171b306fa900f4c70a03c024e6e1127" title="Structure holding information about the current instruction. ">cmd</a> contains valid info. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>(char *) output buffer </td></tr>
    <tr><td class="paramname">bufsize</td><td>(size_t) output buffer size </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">2</td><td>new comment has been generated </td></tr>
    <tr><td class="paramname">1</td><td>callback has not been handled. the buffer must not be changed in this case </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eaa23cf0295698d2f63e1c20bcebeb73d7"></a>is_insn_table_jump&#160;</td><td class="fielddoc">
<p>Callback: determine if instruction is a table jump or call. </p>
<p>If <a class="el" href="group___c_f__.html#gafd76ed40dfacb78082bc6f5683375379" title="The instruction passes execution using indirect. ">CF_JUMP</a> bit can not describe all kinds of table jumps, please define this callback. It will be called for insns with <a class="el" href="group___c_f__.html#gafd76ed40dfacb78082bc6f5683375379" title="The instruction passes execution using indirect. ">CF_JUMP</a> bit set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td><a class="el" href="ua_8hpp.html#a9171b306fa900f4c70a03c024e6e1127" title="Structure holding information about the current instruction. ">cmd</a> structure contains the current instruction </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>yes </td></tr>
    <tr><td class="paramname">&lt;=0</td><td>no </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea5dcd61fc8d775da4487c89926bf1c6e5"></a>auto_empty_finally&#160;</td><td class="fielddoc">
<p>Info: all analysis queues are empty definitively. </p>
<p>This callback is called only once. See also <a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eae8053ec77f80a3f6170a8b473d2ce43c">auto_empty</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea210f9b85ea9f40c7ccdfa78a9de5e2c8"></a>loader_finished&#160;</td><td class="fielddoc">
<p>Event: external file loader finished its work. </p>
<p>Use this event to augment the existing loader functionality. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">li</td><td>(linput_t *) </td></tr>
    <tr><td class="paramname">neflags</td><td>(<a class="el" href="pro_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e" title="unsigned 16 bit value ">uint16</a>) <a class="el" href="group___n_e_f__.html">Load file flags</a> </td></tr>
    <tr><td class="paramname">filetypename</td><td>(const char *) </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea774fc18de802150f174a196843239b99"></a>loader_elf_machine&#160;</td><td class="fielddoc">
<p>Event: ELF loader machine type checkpoint. </p>
<p>A plugin check of the 'machine_type'. If it is the desired one, the the plugin fills 'p_procname' with the processor name (one of the names present in <a class="el" href="structprocessor__t.html#a7f36c9be272d994bc341b3fcb78726f6" title="short processor names (NULL terminated). ">processor_t::psnames</a>). 'p_pd' is used to handle relocations, otherwise can be left untouched. 'set_reloc' can be later used by the plugin to specify relocations. This event occurs for each newly loaded ELF file </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">li</td><td>(linput_t *) </td></tr>
    <tr><td class="paramname">machine_type</td><td>(int) </td></tr>
    <tr><td class="paramname">p_procname</td><td>(const char **) </td></tr>
    <tr><td class="paramname">p_pd</td><td>(proc_def **) (see ldr\elf.h) </td></tr>
    <tr><td class="paramname">set_reloc</td><td>(set_elf_reloc_t *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>e_machine value (if it is different from the original e_machine value, procname and 'p_pd' will be ignored and the new value will be used) </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea6f234203b93c1589b8059874f2910580"></a>is_indirect_jump&#160;</td><td class="fielddoc">
<p>Callback: determine if instruction is an indirect jump. </p>
<p>If <a class="el" href="group___c_f__.html#gafd76ed40dfacb78082bc6f5683375379" title="The instruction passes execution using indirect. ">CF_JUMP</a> bit can not describe all jump types jumps, please define this callback. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td><a class="el" href="ua_8hpp.html#a9171b306fa900f4c70a03c024e6e1127" title="Structure holding information about the current instruction. ">cmd</a> structure contains the current instruction </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>use <a class="el" href="group___c_f__.html#gafd76ed40dfacb78082bc6f5683375379" title="The instruction passes execution using indirect. ">CF_JUMP</a> </td></tr>
    <tr><td class="paramname">2</td><td>no </td></tr>
    <tr><td class="paramname">3</td><td>yes </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea5ff7d1d93c57b88ad49b5a19ec13ed1e"></a>verify_noreturn&#160;</td><td class="fielddoc">
<p>The kernel wants to set 'noreturn' flags for a function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>(<a class="el" href="classfunc__t.html" title="A function is a set of continuous ranges of addresses with characteristics. ">func_t</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1: ok. any other value: do not set 'noreturn' flag </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea17f02eea78c6c2d18fa553263e593395"></a>verify_sp&#160;</td><td class="fielddoc">
<p>All function instructions have been analyzed. </p>
<p>Now the processor module can analyze the stack pointer for the whole function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>(<a class="el" href="classfunc__t.html" title="A function is a set of continuous ranges of addresses with characteristics. ">func_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">&lt;=0</td><td>bad stack pointer </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea29bb76dc87630c4ed16786f6207362c3"></a>renamed&#160;</td><td class="fielddoc">
<p>The kernel has renamed a byte. </p>
<p>See also the <a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eadd2753541373f44f94f0dbe02a439997">rename</a> event </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">new_name</td><td>(const char *) </td></tr>
    <tr><td class="paramname">local_name</td><td>(bool) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea8fc071cf6a534417335a0e6052b1aec1"></a>add_func&#160;</td><td class="fielddoc">
<p>The kernel has added a function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>(<a class="el" href="classfunc__t.html" title="A function is a set of continuous ranges of addresses with characteristics. ">func_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea118e3487cf39cc227a1d5f3ef3523a71"></a>del_func&#160;</td><td class="fielddoc">
<p>The kernel is about to delete a function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>(<a class="el" href="classfunc__t.html" title="A function is a set of continuous ranges of addresses with characteristics. ">func_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">&lt;=0</td><td>do not delete </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eafc94b992ac2d6bad58eda74fc9a47081"></a>set_func_start&#160;</td><td class="fielddoc">
<p>Function chunk start address will be changed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>(<a class="el" href="classfunc__t.html" title="A function is a set of continuous ranges of addresses with characteristics. ">func_t</a> *) </td></tr>
    <tr><td class="paramname">new_start</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">&lt;=0</td><td>do not change </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eacb3d6e97908921fe067383de341ea5ae"></a>set_func_end&#160;</td><td class="fielddoc">
<p>Function chunk end address will be changed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>(<a class="el" href="classfunc__t.html" title="A function is a set of continuous ranges of addresses with characteristics. ">func_t</a> *) </td></tr>
    <tr><td class="paramname">new_end</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">&lt;=0</td><td>do not change </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea26cbd9ec4ffdeab5db6d57649dbec56b"></a>treat_hindering_item&#160;</td><td class="fielddoc">
<p>An item hinders creation of another item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hindering_item_ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">new_item_flags</td><td>(<a class="el" href="pro_8h.html#a55dd00e03168fb5180830e87ef0a2c57" title="32-bit flags for each address ">flags_t</a>) (0 for code) </td></tr>
    <tr><td class="paramname">new_item_ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">new_item_length</td><td>(<a class="el" href="pro_8h.html#adbc570541d9f9a0c4489f9f1fe5f5699" title="memory chunk size ">asize_t</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>no reaction </td></tr>
    <tr><td class="paramname">&lt;=0</td><td>the kernel may delete the hindering item </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea7641afcb07036d80aee1ad1bf0ef51c4"></a>str2reg&#160;</td><td class="fielddoc">
<p>Convert a register name to a register number. </p>
<p>The register number is the register index in the <a class="el" href="structprocessor__t.html#a470124dabad8e9351e326f399e68672a" title="array of register names ">processor_t::regNames</a> array Most processor modules do not need to implement this callback It is useful only if <a class="el" href="structprocessor__t.html#a470124dabad8e9351e326f399e68672a" title="array of register names ">processor_t::regNames</a>[reg] does not provide the correct register names </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regname</td><td>(const char *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>register number + 2 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea87a6e4deacb25e4773abc0d93b88e786"></a>create_switch_xrefs&#160;</td><td class="fielddoc">
<p>Create xrefs for a custom jump table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jumpea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) address of the jump insn </td></tr>
    <tr><td class="paramname">si</td><td>(<a class="el" href="structswitch__info__ex__t.html" title="Extended information about a switch statement. ">switch_info_ex_t</a> *) switch information </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>must return 2 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea2da4bf6d48c8a6f37e70d6465c352869"></a>calc_switch_cases&#160;</td><td class="fielddoc">
<p>Calculate case values and targets for a custom jump table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">insn_ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) address of the 'indirect jump' instruction </td></tr>
    <tr><td class="paramname">si</td><td>(<a class="el" href="structswitch__info__ex__t.html" title="Extended information about a switch statement. ">switch_info_ex_t</a> *) switch information </td></tr>
    <tr><td class="paramname">casevec</td><td>(::casevec_t *) vector of case values (may be NULL) </td></tr>
    <tr><td class="paramname">targets</td><td>(<a class="el" href="pro_8h.html#a9f46d9d52bbfcc78bc1836f4f2683da4" title="vector of addresses ">eavec_t</a> *) corresponding target addresses (my be NULL) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">2</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>failed </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea476d572d630603d5710db684c22fc7a2"></a>determined_main&#160;</td><td class="fielddoc">
<p>The main() function has been determined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">main</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) address of the main() function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eacdfa46e9950f38783fee593a3a369ccc"></a>preprocess_chart&#160;</td><td class="fielddoc">
<p>Gui has retrieved a function flow chart. </p>
<p>Plugins may modify the flow chart in this callback. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fc</td><td>(qflow_chart_t *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea88ff49f5cf097b20a4458ab0862c41f9"></a>get_bg_color&#160;</td><td class="fielddoc">
<p>Get item background color. </p>
<p>Plugins can hook this callback to color disassembly lines dynamically </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">color</td><td>(<a class="el" href="pro_8h.html#a3df5040891132e50157aee66affdf1de" title="background color in RGB ">bgcolor_t</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>not implemented </td></tr>
    <tr><td class="paramname">2</td><td>color set </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ead1acdf5c83b42ce3f84d4547e6f9b16d"></a>validate_flirt_func&#160;</td><td class="fielddoc">
<p>Flirt has recognized a library function. </p>
<p>This callback can be used by a plugin or proc module to intercept it and validate such a function. The idp module is allowed to modify <a class="el" href="ua_8hpp.html#a9171b306fa900f4c70a03c024e6e1127" title="Structure holding information about the current instruction. ">cmd</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">funcname</td><td>(const char *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>do not create a function, </td></tr>
    <tr><td class="paramname">1</td><td>function is validated </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eacedfaf92b57b33de650c90876a084e83"></a>get_operand_string&#160;</td><td class="fielddoc">
<p>Request text string for operand (cli, java, ...). </p>
<p>(<a class="el" href="ua_8hpp.html#a9171b306fa900f4c70a03c024e6e1127" title="Structure holding information about the current instruction. ">cmd</a> structure must contain info for the desired insn) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opnum</td><td>(int) operand number, -1 means any string operand </td></tr>
    <tr><td class="paramname">buf</td><td>(char *) </td></tr>
    <tr><td class="paramname">buflen</td><td>(size_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 no string (or empty string) &gt;1 original string length with terminating zero </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eac9fd0d5b690e1da30b9cd3a64e563419"></a>add_cref&#160;</td><td class="fielddoc">
<p>A code reference is being created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">to</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">type</td><td>(<a class="el" href="group__xref__type.html#ga44e2b79869a9595bbe6265ff2026aa98" title="CODE xref types. ">cref_t</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt; 0 - cancel cref creation </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eafd39f9ed2a4e4ea13e03a2ca9b1b1594"></a>add_dref&#160;</td><td class="fielddoc">
<p>A data reference is being created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">to</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">type</td><td>(<a class="el" href="group__xref__type.html#ga78aab6d0d6bd9cb4904bbdbb5ac4fa71" title="DATA xref types. ">dref_t</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt; 0 - cancel dref creation </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea5e0b078bd13402ea94ad4e1d10abfeed"></a>del_cref&#160;</td><td class="fielddoc">
<p>A code reference is being deleted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">to</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">expand</td><td>(bool) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt; 0 - cancel cref deletion </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea8af3f04d6e33df25a9f20e90756cbf1f"></a>del_dref&#160;</td><td class="fielddoc">
<p>A data reference is being deleted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">to</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt; 0 - cancel dref deletion </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea013ece0fe46a10706a1015ca8d36d793"></a>coagulate_dref&#160;</td><td class="fielddoc">
<p>Data reference is being analyzed. </p>
<p>plugin may correct 'code_ea' (e.g. for thumb mode refs, we clear the last bit) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">to</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">may_define</td><td>(bool) </td></tr>
    <tr><td class="paramname">code_ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt; 0 - cancel dref analysis </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea5f7b735fc0b049ec62508819a86c02df"></a>register_custom_fixup&#160;</td><td class="fielddoc">
<p>Request to register a new custom fixup type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>(const char *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>fixup id + 1 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ead3935b2d84480fc4c075c0f5c0435d94"></a>custom_refinfo&#160;</td><td class="fielddoc">
<p>Called from get_offset_expr, when <a class="el" href="structrefinfo__t.html" title="Information about a reference. ">refinfo_t</a> contains flag <a class="el" href="group___r_e_f_i_n_f_o__.html#ga5513a95d893f73d5e0382c7375d09ef8" title="a custom reference ">REFINFO_CUSTOM</a>. </p>
<p>Normally this notification used in a combination with custom_fixup </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">numop</td><td>(int) </td></tr>
    <tr><td class="paramname">opval</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a> *) </td></tr>
    <tr><td class="paramname">ri</td><td>(const <a class="el" href="structrefinfo__t.html" title="Information about a reference. ">refinfo_t</a>*) </td></tr>
    <tr><td class="paramname">buf</td><td>(char *) </td></tr>
    <tr><td class="paramname">bufsize</td><td>(size_t) </td></tr>
    <tr><td class="paramname">target</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a> *) </td></tr>
    <tr><td class="paramname">fullvalue</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a> *) </td></tr>
    <tr><td class="paramname">from</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) </td></tr>
    <tr><td class="paramname">getn_flags</td><td>(int) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">2</td><td>buf filled as simple expression </td></tr>
    <tr><td class="paramname">3</td><td>buf filled as complex expression </td></tr>
    <tr><td class="paramname">4</td><td>apply standard processing (with possible changed values) </td></tr>
    <tr><td class="paramname">other</td><td>can't convert to offset expression </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea693ef952813662dcf9a84e0037c1bd84"></a>set_proc_options&#160;</td><td class="fielddoc">
<p>Called if the user specified an option string in the command line: -p&lt;processor name&gt;=""&gt;:&lt;options&gt;. </p>
<p>Can be used for setting a processor subtype. Also called if option string is passed to <a class="el" href="idp_8hpp.html#ae24b8e216e1810ebde46490719a24478" title="Set target processor type. ">set_processor_type()</a> and IDC's SetProcessorType(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>(const char *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt; 0 if bad option string </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ead644b0baf59f1567abcbcb5739dae790"></a>adjust_libfunc_ea&#160;</td><td class="fielddoc">
<p>Called when a signature module has been matched against bytes in the database. </p>
<p>This is used to compute the offset at which a particular module's libfunc should be applied. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>(const idasgn_t *) </td></tr>
    <tr><td class="paramname">libfun</td><td>(const libfunc_t *) </td></tr>
    <tr><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>'ea' initially contains the ea_t of the start of the pattern match </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">2</td><td>the ea_t pointed to by the third argument was modified. </td></tr>
    <tr><td class="paramname">other</td><td>not modified. use default algorithm. </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea72dbff4503d6bf55c29cc730b88c2fec"></a>extlang_changed&#160;</td><td class="fielddoc">
<p>The list of extlangs or the default extlang was changed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kind</td><td>(int)<ul>
<li>0: extlang installed</li>
<li>1: extlang removed</li>
<li>2: default extlang changed </li>
</ul>
</td></tr>
    <tr><td class="paramname">el</td><td>(const <a class="el" href="structextlang__t.html" title="External language (to support third party language interpreters) ">extlang_t</a> *) pointer to the extlang affected </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea0237604331ac3319d7fe88b02b47d188"></a>last_cb_before_debugger&#160;</td><td class="fielddoc">
<p>START OF DEBUGGER CALLBACKS. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eabb61e6916d6ee57323b77a4a0cc350a5"></a>obsolete_get_operand_info&#160;</td><td class="fielddoc">
<p>Get operand information. </p>
<p>same as <a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984ea3c474aeefb0082f3046ed37c4a53227b">get_operand_info</a> (below), but uses idd_opinfo_old_t* as the last argument (less info) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea35b1f583a42e152f0e06ab6995b7de5a"></a>next_exec_insn&#160;</td><td class="fielddoc">
<p>Get next address to be executed. </p>
<p>This function must return the next address to be executed. If the instruction following the current one is executed, then it must return <a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39; ">BADADDR</a> Usually the instructions to consider are: jumps, branches, calls, returns. This function is essential if the 'single step' is not supported in hardware. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) instruction address </td></tr>
    <tr><td class="paramname">tid</td><td>(int) current therad id </td></tr>
    <tr><td class="paramname">getreg</td><td>(const <a class="el" href="structregval__t.html" title="Structure to hold a register value. ">regval_t</a> &amp;(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133" title="specifies __stdcall calling convention ">idaapi</a> *)(const char *name, const <a class="el" href="structregval__t.html" title="Structure to hold a register value. ">regval_t</a> *regvalues)) function to get register values </td></tr>
    <tr><td class="paramname">regvalues</td><td>(const <a class="el" href="structregval__t.html" title="Structure to hold a register value. ">regval_t</a> *) register values array </td></tr>
    <tr><td class="paramname">target</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a> *) pointer to the answer </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>unimplemented </td></tr>
    <tr><td class="paramname">&lt;=0</td><td>implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea3422ea57c2feda4b6fb4e59f87d68e11"></a>calc_step_over&#160;</td><td class="fielddoc">
<p>Calculate the address of the instruction which will be executed after "step over". </p>
<p>The kernel will put a breakpoint there. If the step over is equal to step into or we can not calculate the address, return <a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39; ">BADADDR</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) instruction address </td></tr>
    <tr><td class="paramname">target</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a> *) pointer to the answer </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>unimplemented </td></tr>
    <tr><td class="paramname">&lt;=0</td><td>implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eaa223dab5c41c3917e60ca2379c64d543"></a>get_macro_insn_head&#160;</td><td class="fielddoc">
<p>Calculate the start of a macro instruction. </p>
<p>This notification is called if IP points to the middle of an instruction </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) instruction address </td></tr>
    <tr><td class="paramname">head</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a> *) answer, <a class="el" href="pro_8h.html#a63a7c1cde5fb0cf0d0023d55c742dd4f" title="this value is used for &#39;bad address&#39; ">BADADDR</a> means normal instruction </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>unimplemented </td></tr>
    <tr><td class="paramname">&lt;=0</td><td>implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea53ee27b3f50560b5d41ea8091c273c38"></a>get_dbr_opnum&#160;</td><td class="fielddoc">
<p>Get the number of the operand to be displayed in the debugger reference view (text mode). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) instruction address </td></tr>
    <tr><td class="paramname">opnum</td><td>(int *) operand number (out, -1 means no such operand) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>unimplemented </td></tr>
    <tr><td class="paramname">&lt;=0</td><td>implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eaee38edc59c772e872c8c3f7462f73580"></a>insn_reads_tbit&#160;</td><td class="fielddoc">
<p>Check if insn will read the TF bit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) instruction address </td></tr>
    <tr><td class="paramname">getreg</td><td>(const <a class="el" href="structregval__t.html" title="Structure to hold a register value. ">regval_t</a> &amp;(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133" title="specifies __stdcall calling convention ">idaapi</a> *)(const char *name, const <a class="el" href="structregval__t.html" title="Structure to hold a register value. ">regval_t</a> *regvalues)) function to get register values </td></tr>
    <tr><td class="paramname">regvalues</td><td>(const <a class="el" href="structregval__t.html" title="Structure to hold a register value. ">regval_t</a> *) register values array </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">3</td><td>yes, will generate 'step' exception </td></tr>
    <tr><td class="paramname">2</td><td>yes, will store the TF bit in memory </td></tr>
    <tr><td class="paramname">1</td><td>no </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea3c474aeefb0082f3046ed37c4a53227b"></a>get_operand_info&#160;</td><td class="fielddoc">
<p>Get operand information. </p>
<p>This callback is used to calculate the operand value for double clicking on it, hints, etc. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) instruction address </td></tr>
    <tr><td class="paramname">n</td><td>(int) operand number </td></tr>
    <tr><td class="paramname">thread_id</td><td>(int) current thread id </td></tr>
    <tr><td class="paramname">getreg</td><td>(const <a class="el" href="structregval__t.html" title="Structure to hold a register value. ">regval_t</a> &amp;(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133" title="specifies __stdcall calling convention ">idaapi</a> *)(const char *name, const <a class="el" href="structregval__t.html" title="Structure to hold a register value. ">regval_t</a> *regvalues)) function to get register values </td></tr>
    <tr><td class="paramname">regvalues</td><td>(const <a class="el" href="structregval__t.html" title="Structure to hold a register value. ">regval_t</a> *) register values array </td></tr>
    <tr><td class="paramname">opinf</td><td>(<a class="el" href="structidd__opinfo__t.html" title="Instruction operand information. ">idd_opinfo_t</a> *) the output buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;=0-ok, otherwise failed </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea9e4b3b916acbc04b242b198e0108ea23"></a>calc_next_eas&#160;</td><td class="fielddoc">
<p>Calculate list of addresses the instruction in <a class="el" href="ua_8hpp.html#a9171b306fa900f4c70a03c024e6e1127" title="Structure holding information about the current instruction. ">cmd</a> may pass control to. </p>
<p>This callback is required for source level debugging. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">over</td><td>(bool) calculate for step over (ignore call targets) </td></tr>
    <tr><td class="paramname">res</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a> *) array for the results. this array has <a class="el" href="idp_8hpp.html#ac34f5f28d80081e1cd4d4287d0fd0ff3" title="Size of the output array for processor_t::calc_next_eas. ">NEXTEAS_ANSWER_SIZE</a> elements. </td></tr>
    <tr><td class="paramname">nsubcalls</td><td>(int *) number of addresses of called functions in the above array. they must be put at the beginning of the array. if over=true, this answer will be zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of calculated addresses+1. If there are too many addresses or they are incalculable (indirect jumps, for example), return -1. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea83c7b24e22b7d8e81be84e892f545551"></a>clean_tbit&#160;</td><td class="fielddoc">
<p>Clear the TF bit after an insn like pushf stored it in memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) instruction address </td></tr>
    <tr><td class="paramname">getreg</td><td>(const <a class="el" href="structregval__t.html" title="Structure to hold a register value. ">regval_t</a> &amp;(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133" title="specifies __stdcall calling convention ">idaapi</a> *)(const char *name, const <a class="el" href="structregval__t.html" title="Structure to hold a register value. ">regval_t</a> *regvalues)) function to get register values </td></tr>
    <tr><td class="paramname">regvalues</td><td>(const <a class="el" href="structregval__t.html" title="Structure to hold a register value. ">regval_t</a> *) register values array </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">2</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>failed </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea9c56a4426a67497592f6107890c5213d"></a>get_reg_info2&#160;</td><td class="fielddoc">
<p>Get register information by its name. </p>
<p>example: "ah" returns:</p><ul>
<li>main_regname="eax"</li>
<li><a class="el" href="classbitrange__t.html" title="This class manages the offset and size of a value that occupies a number of contiguous bits within so...">bitrange_t</a> = { offset==8, nbits==8 }</li>
</ul>
<p>This callback may be unimplemented if the register names are all present in <a class="el" href="structprocessor__t.html#a470124dabad8e9351e326f399e68672a" title="array of register names ">processor_t::regNames</a> and they all have the same size </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regname</td><td>(const char *) </td></tr>
    <tr><td class="paramname">main_regname</td><td>(const char **) (NULL-failed) </td></tr>
    <tr><td class="paramname">bitrange</td><td>(<a class="el" href="classbitrange__t.html" title="This class manages the offset and size of a value that occupies a number of contiguous bits within so...">bitrange_t</a> *) position and size of the value within 'main_regname' (empty bitrange == whole register) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>unimplemented </td></tr>
    <tr><td class="paramname">2</td><td>implemented </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eac3d3a2df33af113b3319cce93353d15e"></a>setup_til&#160;</td><td class="fielddoc">
<p>Setup default type libraries. </p>
<p>(called after loading a new file into the database). The processor module may load tils, setup memory model and perform other actions required to set up the type system. This is an optional callback. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea1cb36be1ae9bf4cdbd9ba4df0a0b8203"></a>based_ptr&#160;</td><td class="fielddoc">
<p>Get prefix and size of 'segment based' ptr type. </p>
<p>(something like char _ss *ptr, see <a class="el" href="typeinf_8hpp.html#a849f26186c0d6c976adc32a440622133" title="Get prefix and size of &#39;segment based&#39; ptr type (something like char _ss *ptr). ">based_ptr_name_and_size()</a>) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrt</td><td>(unsigned) </td></tr>
    <tr><td class="paramname">ptrname</td><td>(const char **) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of type </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea3bfa3be2f6e625d3306e75a9225ba315"></a>max_ptr_size&#160;</td><td class="fielddoc">
<p>Get maximal size of a pointer in bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>max possible size of a pointer plus 1 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea6f8cc9547653ad01ca7b065d50dfd3bd"></a>get_default_enum_size&#160;</td><td class="fielddoc">
<p>Get default enum size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cm</td><td>(<a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9" title="calling convention and memory model ">cm_t</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sizeof(enum) </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eaad326c3589035cdce293a6a645a821cb"></a>calc_cdecl_purged_bytes2&#160;</td><td class="fielddoc">
<p>Calculate number of purged bytes after call. </p>
<p>param ea (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) address of the call instruction </p><dl class="section return"><dt>Returns</dt><dd>number of purged bytes+2 (usually add sp, N) </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea4fd473a3014b81fb1c97cf797e7dbb86"></a>get_stkarg_offset2&#160;</td><td class="fielddoc">
<p>Get offset from SP to the first stack argument. </p>
<p>For example: pc: 0, hppa: -0x34, ppc: 0x38 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the offset + 2 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eaaea5993fa21996059b962cdd376346c6"></a>til_for_file&#160;</td><td class="fielddoc">
<p>Internal notification, do not use. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea7af5797fbb1fa57d6d92e76e99b93c67"></a>equal_reglocs&#160;</td><td class="fielddoc">
<p>Are 2 register arglocs the same?. </p>
<p>We need this callback for the pc module. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a1</td><td>(<a class="el" href="classargloc__t.html" title="Describes an argument location. ">argloc_t</a> *) </td></tr>
    <tr><td class="paramname">a2</td><td>(<a class="el" href="classargloc__t.html" title="Describes an argument location. ">argloc_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>not implemented </td></tr>
    <tr><td class="paramname">2</td><td>yes </td></tr>
    <tr><td class="paramname">-1</td><td>no </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea27d4c19be54512c14f613fe9bce82915"></a>decorate_name3&#160;</td><td class="fielddoc">
<p>Decorate/undecorate a C symbol name. </p>
<p>The kernel uses this callback only if <a class="el" href="group___p_r__.html#gab8b1f08d470b9273bfe2e4f7007ae14b" title="has support for tinfo_t ">PR_TINFO</a> is set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outbuf</td><td>(<a class="el" href="pro_8h.html#a386c10c6aa4340f1d63df85f40454fce" title="regular string ">qstring</a> *) output buffer </td></tr>
    <tr><td class="paramname">name</td><td>(const char *) name of symbol </td></tr>
    <tr><td class="paramname">mangle</td><td>(bool) true-mangle, false-unmangle </td></tr>
    <tr><td class="paramname">cc</td><td>(<a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9" title="calling convention and memory model ">cm_t</a>) calling convention </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>2 if success </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea4f4955d8d640ed12b13ded86d1c22317"></a>calc_retloc3&#160;</td><td class="fielddoc">
<p>Calculate return value location. </p>
<p>The kernel uses this callback only if <a class="el" href="group___p_r__.html#gab8b1f08d470b9273bfe2e4f7007ae14b" title="has support for tinfo_t ">PR_TINFO</a> is set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">rettype</td><td>(const <a class="el" href="classtinfo__t.html" title="Primary mechanism for managing type information. ">tinfo_t</a> *) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cc</td><td>(<a class="el" href="ida_8hpp.html#a3e05fd8860fadc8f72329fc410c8f6b9" title="calling convention and memory model ">cm_t</a>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">retloc</td><td>(<a class="el" href="classargloc__t.html" title="Describes an argument location. ">argloc_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 not implemented </dd>
<dd>
2 ok, </dd>
<dd>
-1 error </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eaec8ff17b6d580d79f60f8397671bebc7"></a>calc_varglocs3&#160;</td><td class="fielddoc">
<p>Calculate locations of the arguments that correspond to '...'. </p>
<p>The kernel uses this callback only if <a class="el" href="group___p_r__.html#gab8b1f08d470b9273bfe2e4f7007ae14b" title="has support for tinfo_t ">PR_TINFO</a> is set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ftd</td><td>(const <a class="el" href="structfunc__type__data__t.html" title="Function type information (see tinfo_t::get_func_details()) ">func_type_data_t</a> *) info about all arguments (including varargs) </td></tr>
    <tr><td class="paramname">regs</td><td>(<a class="el" href="structregobjs__t.html" title="Collection of register objects. ">regobjs_t</a> *) buffer for register values </td></tr>
    <tr><td class="paramname">stkargs</td><td>(<a class="el" href="structrelobj__t.html" title="Relocatable object. ">relobj_t</a> *) stack arguments </td></tr>
    <tr><td class="paramname">nfixed</td><td>(int) number of fixed arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>not implemented </td></tr>
    <tr><td class="paramname">2</td><td>ok </td></tr>
    <tr><td class="paramname">-1</td><td>error </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea1958d45eea679d42701b739c7becb915"></a>calc_arglocs3&#160;</td><td class="fielddoc">
<p>Calculate function argument locations. </p>
<p>This callback should fill retloc, all arglocs, and stkargs. This callback supersedes calc_argloc2. This callback is never called for <a class="el" href="group___c_m___c_c__.html#ga377054c414ac35be6e5e9bf6c550b390" title="locations of all arguments and the return value are present in the function declaration. ">CM_CC_SPECIAL</a> functions. The kernel uses this callback only if <a class="el" href="group___p_r__.html#gab8b1f08d470b9273bfe2e4f7007ae14b" title="has support for tinfo_t ">PR_TINFO</a> is set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fti</td><td>(<a class="el" href="structfunc__type__data__t.html" title="Function type information (see tinfo_t::get_func_details()) ">func_type_data_t</a> *) points to the func type info </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>not implemented </td></tr>
    <tr><td class="paramname">2</td><td>ok </td></tr>
    <tr><td class="paramname">-1</td><td>error </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea0f02557a3e296491ae7c182ae8ff6534"></a>use_stkarg_type3&#160;</td><td class="fielddoc">
<p>Use information about a stack argument. </p>
<p>The kernel uses this callback only if <a class="el" href="group___p_r__.html#gab8b1f08d470b9273bfe2e4f7007ae14b" title="has support for tinfo_t ">PR_TINFO</a> is set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) address of the push instruction which pushes the function argument into the stack </td></tr>
    <tr><td class="paramname">arg</td><td>(const <a class="el" href="structfuncarg__t.html" title="Information about a single function argument. ">funcarg_t</a> *) argument info </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>ok </td></tr>
    <tr><td class="paramname">false</td><td>failed, the kernel will create a comment with the argument name or type for the instruction </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea2a8b28dcd4e5ad63784ae609dc20a63d"></a>use_regarg_type3&#160;</td><td class="fielddoc">
<p>Use information about register argument. </p>
<p>The kernel uses this callback only if <a class="el" href="group___p_r__.html#gab8b1f08d470b9273bfe2e4f7007ae14b" title="has support for tinfo_t ">PR_TINFO</a> is set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">idx</td><td>(int *) pointer to the returned value, may contain:<ul>
<li>idx of the used argument, if the argument is defined in the current instruction, a comment will be applied by the kernel</li>
<li>idx | <a class="el" href="idp_8hpp.html#a062e4611e8876c7b1608cbecab0d94ed" title="processor_t::use_regarg_type3 uses this bit in the return value to indicate that the register value h...">REG_SPOIL</a> - argument is spoiled by the instruction</li>
<li>-1 if the instruction doesn't change any registers</li>
<li>-2 if the instruction spoils all registers </li>
</ul>
</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) address of the instruction </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rargs</td><td>(const <a class="el" href="typeinf_8hpp.html#a6b5faeba43c9a59ec3aae166657ff78a" title="vector of function argument objects ">funcargvec_t</a> *) vector of register arguments (including regs extracted from scattered arguments) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>2 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea1480ed6b5161c51a9f63172024b80cf3"></a>use_arg_types3&#160;</td><td class="fielddoc">
<p>Use information about callee arguments. </p>
<p>The kernel uses this callback only if <a class="el" href="group___p_r__.html#gab8b1f08d470b9273bfe2e4f7007ae14b" title="has support for tinfo_t ">PR_TINFO</a> and <a class="el" href="group___p_r__.html#ga4bad99f470ddf7643783e7f212084c07" title="use processor_t::use_arg_types3 callback ">PR_USE_ARG_TYPES</a> are set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ea</td><td>(<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a" title="effective address ">ea_t</a>) address of the call instruction </td></tr>
    <tr><td class="paramname">fti</td><td>(<a class="el" href="structfunc__type__data__t.html" title="Function type information (see tinfo_t::get_func_details()) ">func_type_data_t</a> *) info about function type </td></tr>
    <tr><td class="paramname">rargs</td><td>(<a class="el" href="typeinf_8hpp.html#a6b5faeba43c9a59ec3aae166657ff78a" title="vector of function argument objects ">funcargvec_t</a> *) array of register arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>2 (and removes handled arguments from fti and rargs) </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea5044da7bebdd164b8b1ba788d9452e01"></a>calc_purged_bytes3&#160;</td><td class="fielddoc">
<p>Calculate number of purged bytes by the given function type. </p>
<p>The kernel uses this callback only if <a class="el" href="group___p_r__.html#gab8b1f08d470b9273bfe2e4f7007ae14b" title="has support for tinfo_t ">PR_TINFO</a> is set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_purged_bytes</td><td>(int *) ptr to output </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fti</td><td>(const <a class="el" href="structfunc__type__data__t.html" title="Function type information (see tinfo_t::get_func_details()) ">func_type_data_t</a> *) func type details </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>2 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea5f6b0fc3daca67c9f92b3d57da775bdc"></a>shadow_args_size&#160;</td><td class="fielddoc">
<p>Get size of shadow args in bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">shadow_args_size</td><td>(int *) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pfn</td><td>(<a class="el" href="classfunc__t.html" title="A function is a set of continuous ranges of addresses with characteristics. ">func_t</a> *) (may be NULL) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>2 if filled *shadow_args_size </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea439dec44180c98957182e8a96ffeb003"></a>get_varcall_regs3&#160;</td><td class="fielddoc">
<p>Get register allocation convention used in the ellipsis (...) calling convention. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regs</td><td>(<a class="el" href="classcallregs__t.html" title="Register allocation calling convention. ">callregs_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>max_possible_number_of_varcall_regs+2 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eaedebf14590250f5902778b65efc70600"></a>get_fastcall_regs3&#160;</td><td class="fielddoc">
<p>Get register allocation convention used in the fastcall calling convention. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regs</td><td>(<a class="el" href="classcallregs__t.html" title="Register allocation calling convention. ">callregs_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>max_possible_number_of_fastcall_regs+2 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984ea778866fd62f1a5c4881d491ae0fc9e53"></a>get_thiscall_regs3&#160;</td><td class="fielddoc">
<p>Get register allocation convention used in the thiscall calling convention. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regs</td><td>(<a class="el" href="classcallregs__t.html" title="Register allocation calling convention. ">callregs_t</a> *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>max_possible_number_of_fastcall_regs+2 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aedd76f79cf248c21d1d511be5a89984eab5b95fa3c04172f8e18730196fd93c2e"></a>loader&#160;</td><td class="fielddoc">
<p>This code and higher ones are reserved for the loaders. </p>
<p>The arguments and the return values are defined by the loaders </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac1e0b7613ad405cf7b165b59c9ba02c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a> processor_t::get_segm_bitness </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structprocessor__t.html#acbe4f7fded38c0295e5773fd603489a2">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get segment bitness. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">2</td><td><a class="el" href="group___p_r__.html#ga51211ffe0d08c32dece2d318a462e139" title="segments are 64-bit by default ">PR_DEFSEG64</a> </td></tr>
    <tr><td class="paramname">1</td><td><a class="el" href="group___p_r__.html#ga91a0359d79ef2256ffb0b29ae7e481cb" title="segments are 32-bit by default ">PR_DEFSEG32</a> </td></tr>
    <tr><td class="paramname">0</td><td>none specified </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abe691f9f3c80817bd9d1e19e8ee5f926"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a> processor_t::get_stkvar_scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structprocessor__t.html#acbe4f7fded38c0295e5773fd603489a2">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the stack variable scaling factor. </p>
<p>Useful for processors who refer to the stack with implicit scaling factor. TMS320C55 for example: SP(#1) really refers to (SP+2) </p>

</div>
</div>
<a class="anchor" id="a10ea0a33706e0ee35eaab7da7a69afb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">processor_t::void </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td>
          <td class="paramname"><em>assumes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to produce assume directives when segment register value changes. </p>
<p>If your processor has no segment registers, you may define it as NULL </p>

</div>
</div>
<a class="anchor" id="a46368eb35efba22852d976cee36f1b5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">processor_t::int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td>
          <td class="paramname"><em>u_ana</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyze one instruction and fill 'cmd' structure. </p>
<p>This function shouldn't change the database, flags or anything else. All these actions should be performed only by u_emu() function. <a class="el" href="classinsn__t.html#a68b331560b7f026c120373ca574c2889" title="Linear address of the instruction. ">insn_t::ea</a> contains address of instruction to analyze. </p><dl class="section return"><dt>Returns</dt><dd>length of the instruction in bytes, 0 if instruction can't be decoded. </dd></dl>

</div>
</div>
<a class="anchor" id="a9738a5b48962cd3d2f90960bae0903e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">processor_t::int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td>
          <td class="paramname"><em>u_emu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emulate instruction, create cross-references, plan to analyze subsequent instructions, modify flags etc. </p>
<p>Upon entrance to this function, all information about the instruction is in <a class="el" href="ua_8hpp.html#a9171b306fa900f4c70a03c024e6e1127" title="Structure holding information about the current instruction. ">cmd</a> structure. If zero is returned, the kernel will delete the instruction. </p>

</div>
</div>
<a class="anchor" id="a228e2d885b84e4dfafb0718e9119074d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">processor_t::void </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td>
          <td class="paramname"><em>u_out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate text representation of an instruction in <a class="el" href="ua_8hpp.html#a9171b306fa900f4c70a03c024e6e1127" title="Structure holding information about the current instruction. ">cmd</a> structure. </p>
<p>This function shouldn't change the database, flags or anything else. All these actions should be performed only by u_emu() function. </p>

</div>
</div>
<a class="anchor" id="abb16014fd9a56ce9cdd3bf1b7965f205"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">processor_t::bool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td>
          <td class="paramname"><em>u_outop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate text representation of an instruction operand. </p>
<p>This function shouldn't change the database, flags or anything else. All these actions should be performed only by u_emu() function. The output text is placed in the output buffer initialized with <a class="el" href="group__output__helpers.html#gaf1c2cd8c878bd3289a5b228c78ff1c1c" title="Initialize output buffer. ">init_output_buffer()</a> This function uses out_...() functions from <a class="el" href="ua_8hpp.html" title="Functions that deal with the disassembling of program instructions. ">ua.hpp</a> to generate the operand text </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>ok </td></tr>
    <tr><td class="paramname">0</td><td>operand is hidden. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a18ea92530299ebf826ac2ed110c92f99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">processor_t::void </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> *&#160;</td>
          <td class="paramname"><em>d_out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate text representation of data items. </p>
<p>This function MAY change the database and create cross-references, etc. </p>

</div>
</div>
<a class="anchor" id="ad58c2a400e68a56e9299338aab2b2029"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structprocessor__t.html#abb16014fd9a56ce9cdd3bf1b7965f205">bool</a> processor_t::is_canon_insn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pro_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td>
          <td class="paramname"><em>itype</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does the given value specify a valid instruction for this instruction set?. </p>
<p>See <a class="el" href="structprocessor__t.html#a7a59ab3d03679871b5384d9bca5dfcf3" title="icode of the first instruction ">instruc_start</a> and <a class="el" href="structprocessor__t.html#a72c65c0c97da5e3c8a4b1876eb313e3e" title="icode of the last instruction + 1 ">instruc_end</a> </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a3f886dfe71be841774fbf924efd71882"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a> processor_t::cnbits</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of bits in a byte for code segments (usually 8). </p>
<p>IDA supports values up to 32 bits </p>

</div>
</div>
<a class="anchor" id="af359c0e9205f527f4eff43d505d91ca4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a> processor_t::dnbits</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of bits in a byte for non-code segments (usually 8). </p>
<p>IDA supports values up to 32 bits </p>

</div>
</div>
<a class="anchor" id="a7f36c9be272d994bc341b3fcb78726f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* const* processor_t::psnames</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>short processor names (NULL terminated). </p>
<p>Each name should be shorter than 9 characters </p>

</div>
</div>
<a class="anchor" id="adb54cc1d2faab6891ad190e2e5b7bf08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* const* processor_t::plnames</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>long processor names (NULL terminated). </p>
<p>No restriction on name lengths. </p>

</div>
</div>
<a class="anchor" id="a13faa23b7174cbdbae5da42c71602d24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structasm__t.html">asm_t</a>* const* processor_t::assemblers</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pointer to array of target assembler definitions. </p>
<p>You may change this array when current processor is changed. (NULL terminated) </p>

</div>
</div>
<a class="anchor" id="a921744ebeca4dda235ecd140559b96ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structprocessor__t.html#abb16014fd9a56ce9cdd3bf1b7965f205">bool</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * processor_t::cmp_opnd) (const <a class="el" href="classop__t.html">op_t</a> &amp;op1, const <a class="el" href="classop__t.html">op_t</a> &amp;op2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare instruction operands. </p>
<p>This pointer may be NULL. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>equal </td></tr>
    <tr><td class="paramname">0</td><td>not equal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab842d78138df775d7afa6b6c4eb4d6f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structprocessor__t.html#abb16014fd9a56ce9cdd3bf1b7965f205">bool</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * processor_t::can_have_type) (<a class="el" href="classop__t.html">op_t</a> &amp;op)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Can the operand have a type as offset, segment, decimal, etc. </p>
<p>(for example, a register AX can't have a type, meaning that the user can't change its representation. see <a class="el" href="bytes_8hpp.html" title="Contains functions that deal with individual byte characteristics. ">bytes.hpp</a> for information about types and flags) This pointer may be NULL. </p>

</div>
</div>
<a class="anchor" id="a27bbc4b0f0236c146329cdeec2a24d56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_abstract_register.html">AbstractRegister</a>*(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * processor_t::getreg) (<a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a> regnum)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get register value. </p>
<p>If specified, will be used in the determining predefined comment based on the register value </p>

</div>
</div>
<a class="anchor" id="a9414a4e585ab47514144871a585cc120"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structbytes__t.html">bytes_t</a>* processor_t::codestart</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of typical code start sequences. </p>
<p>This array is used when a new file is loaded to find the beginnings of code sequences. This array is terminated with a zero length item. </p>

</div>
</div>
<a class="anchor" id="ab3849caf742c36dc743f0aa88267221a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structbytes__t.html">bytes_t</a>* processor_t::retcodes</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of 'return' instruction opcodes. </p>
<p>This array is used to determine form of autogenerated locret_... labels. The last item of it should be { 0, NULL } This array may be NULL Better way of handling return instructions is to define the <a class="el" href="structprocessor__t.html#aedd76f79cf248c21d1d511be5a89984eafe60282cb0f6faae0d06ed53e8ddaa81">is_ret_insn</a> callback in the <a class="el" href="structprocessor__t.html#ab0d7131aaf457b74265eeeb999652579" title="Various notifications for the idp. ">notify()</a> function </p>

</div>
</div>
<a class="anchor" id="a08a59ce127cc7b2f14da61fa5ace5c97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * processor_t::is_far_jump) (<a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a> icode)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>is indirect far jump or call instruction?. </p>
<p>meaningful only if the processor has 'near' and 'far' reference types </p>

</div>
</div>
<a class="anchor" id="aaca9e1d2690d7b744c8355f8fbdae4df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * processor_t::translate) (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> base, <a class="el" href="pro_8h.html#ac29a387cc69c0d1abb2f2ef05dad1a6f">adiff_t</a> offset)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translation function for offsets. </p>
<p>Currently used in the offset display functions to calculate the referenced address </p>

</div>
</div>
<a class="anchor" id="a6e58bd16cec88d15eaf406db8960c7a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * processor_t::realcvt) (<a class="el" href="structprocessor__t.html#acbe4f7fded38c0295e5773fd603489a2">void</a> *m, <a class="el" href="pro_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> *e, <a class="el" href="pro_8h.html#a05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> swt)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Floating point -&gt; IEEE conversion function. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___r_e_a_l___e_r_r_o_r__.html">Floating point/IEEE Conversion codes</a> on error </dd></dl>

</div>
</div>
<a class="anchor" id="ab1ed6541f40864dcf175219db42afa90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char processor_t::real_width[4]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of digits in floating numbers after the decimal point. </p>
<p>If an element of this array equals 0, then the corresponding floating point data is not used for the processor. This array is used to align numbers in the output.</p><ul>
<li>real_width[0] - number of digits for short floats (only PDP-11 has them)</li>
<li>real_width[1] - number of digits for "float"</li>
<li>real_width[2] - number of digits for "double"</li>
<li>real_width[3] - number of digits for "long double"</li>
</ul>
<p>Example: IBM PC module has { 0,7,15,19 } </p>

</div>
</div>
<a class="anchor" id="ada062ecba745d093044e3615928cc7ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structprocessor__t.html#abb16014fd9a56ce9cdd3bf1b7965f205">bool</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * processor_t::is_switch) (<a class="el" href="structswitch__info__ex__t.html">switch_info_ex_t</a> *si)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find 'switch' idiom. </p>
<p>This function may use (and modify) <a class="el" href="ua_8hpp.html#a9171b306fa900f4c70a03c024e6e1127" title="Structure holding information about the current instruction. ">cmd</a> (you can assume cmd is correct). It will be called for instructions marked with <a class="el" href="group___c_f__.html#gafd76ed40dfacb78082bc6f5683375379" title="The instruction passes execution using indirect. ">CF_JUMP</a>. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>switch is found, 'si' is filled </td></tr>
    <tr><td class="paramname">0</td><td>switch is not found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a312349eb79dc25a38366381a27204969"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pro_8h.html#a56f1a81c92849566ae864511088eb7e8">int32</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * processor_t::gen_map_file) (FILE *fp)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate map file. </p>
<p>If this pointer is NULL, the kernel itself will create the map file. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>empty file </td></tr>
    <tr><td class="paramname">-1</td><td>write error </td></tr>
    <tr><td class="paramname">other</td><td>number of lines in output file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a66833283dbe0f3d424a4d25fb2c141aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * processor_t::extract_address) (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ea, const char *string, <a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a> x)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract address from a string. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">BADADDR</td><td>if can't extract. </td></tr>
    <tr><td class="paramname">BADADDR-1</td><td>if kernel should use standard algorithm. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7322d29966e3324423d7c2a058b9836d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * processor_t::is_sp_based) (const <a class="el" href="classop__t.html">op_t</a> &amp;x)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the operand is relative to stack pointer or frame pointer. </p>
<p>This function is used to determine how to output a stack variable This function may be absent. If it is absent, then all operands are sp based by default. Define this function only if some stack references use frame pointer instead of stack pointer. </p><dl class="section return"><dt>Returns</dt><dd>combination of <a class="el" href="group___o_p___f_p___s_p.html">SP/FP operand flags</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ade063932531b3f164998382458a7085f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structprocessor__t.html#abb16014fd9a56ce9cdd3bf1b7965f205">bool</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * processor_t::create_func_frame) (<a class="el" href="classfunc__t.html">func_t</a> *pfn)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a function frame for a newly created function. </p>
<p>Set up frame size, its attributes etc. This function may be absent. </p>

</div>
</div>
<a class="anchor" id="a9f3860f5f4ceb9f973ec9b8f776783bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * processor_t::get_frame_retsize) (<a class="el" href="classfunc__t.html">func_t</a> *pfn)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get size of function return address in bytes. </p>
<p>If this function is absent, the kernel will assume</p><ul>
<li>4 bytes for 32-bit function</li>
<li>2 bytes otherwise <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfn</td><td>pointer to function structure, can't be NULL </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ad8f801f1af90421acc3ebcc11644bfcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structprocessor__t.html#acbe4f7fded38c0295e5773fd603489a2">void</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * processor_t::gen_stkvar_def) (char *buf, size_t bufsize, const class <a class="el" href="classmember__t.html">member_t</a> *mptr, <a class="el" href="pro_8h.html#a430639fcfd4601cd6cb310ae71481fe1">sval_t</a> v)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate stack variable definition line. </p>
<p>If this function is NULL, then the kernel will create this line itself. Default line is varname = type ptr value, where 'type' is one of byte,word,dword,qword,tbyte </p>

</div>
</div>
<a class="anchor" id="a947330e23b5dd5ea1c268bc54f2e67bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structprocessor__t.html#abb16014fd9a56ce9cdd3bf1b7965f205">bool</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * processor_t::u_outspec) (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ea, <a class="el" href="pro_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> <a class="el" href="group__seg__type.html#ga67eaaed66c079e1ac389902d19046d20">segtype</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate text representation of an item in a special segment. </p>
<p>i.e. absolute symbols, externs, communal definitions etc. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>overflow </td></tr>
    <tr><td class="paramname">0</td><td>ok </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac4768056360229a11cc1f272a4ade04c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a>(<a class="el" href="pro_8h.html#a6505e7ff3b129d8b17258304886fd133">idaapi</a> * processor_t::is_align_insn) (<a class="el" href="pro_8h.html#a7b0aeaed04e477c02cf8ea3452002d1a">ea_t</a> ea)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the instruction created only for alignment purposes?. </p>
<p>Do not directly call this function, use <a class="el" href="idp_8hpp.html#a0fd0a2914e9e1fe193175e78a5a6cdeb" title="If the instruction at &#39;ea&#39; looks like an alignment instruction, return its length in bytes...">is_align_insn()</a> returns: number of bytes in the instruction </p>

</div>
</div>
<a class="anchor" id="ab3a5bba6ff0c8bf77b55d615f785b21a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structprocessor__t.html#a46368eb35efba22852d976cee36f1b5d">int</a> processor_t::high_fixup_bits</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the <a class="el" href="group___f_i_x_u_p__.html#ga7a5bc27151e5973fd7ba3a6f77d4f2c4" title="high processor_t::high_fixup_bits of 32bit offset ">FIXUP_VHIGH</a> and <a class="el" href="group___f_i_x_u_p__.html#ga68e1431db78df74c0ee73b87b9038d19" title="low processor_t::high_fixup_bits of 32bit offset ">FIXUP_VLOW</a> fixup types are supported then the number of bits in the HIGH part. </p>
<p>For example, SPARC will have here 22 because it has HIGH22 and LOW10 relocations. See also: the description of <a class="el" href="group___p_r__.html#ga4af04e1f9461b2b18b167d118c775238" title="REF_VHIGH operand value contains full operand ">PR_FULL_HIFXP</a> bit </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="idp_8hpp.html">idp.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
