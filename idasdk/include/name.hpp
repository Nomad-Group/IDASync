/*
 *      Interactive disassembler (IDA).
 *      ALL RIGHTS RESERVED.
 *      Copyright (c) 1990-2015 Hex-Rays
 *
 */

#ifndef _NAME_HPP
#define _NAME_HPP

#include <ida.hpp>

#pragma pack(push, 1)           // IDA uses 1 byte alignments!

/*! \file name.hpp

  \brief Functions that deal with names.

  A non-tail address of the program may have a name.
  Tail addresses (i.e. the addresses in the middle of an instruction or
  data item) can not have names.
*/

class func_t;                   // funcs.hpp
typedef uchar color_t;          // lines.hpp


/// Maximum length of a name in IDA (with the trailing zero)
#define MAXNAMELEN      512


/// Name prefix used by IDA for the imported functions
#define FUNC_IMPORT_PREFIX "__imp_"


/// Translation used to build meaningful names of ascii strings.
/// Ascii strings are given a 'meaningful' name based on the first characters
/// of the string itself.
/// This array is used to translate characters which can't appear in
/// identifiers to valid ones.
/// This array is initialized with information from ida.cfg.
idaman char ida_export_data XlatAsciiName[256];


/// Set or delete name of an item at the specified address.
/// An item can be anything: instruction, function, data byte, word, string,
/// structure, etc...
/// Include name into the list of names.
/// \param ea    linear address.
///              do nothing if ea is not valid (return 0).
///              tail bytes can't have names.
/// \param name  new name.
///                - NULL: do nothing (return 0).
///                - ""  : delete name.
///                - otherwise this is a new name.
/// \param flag  \ref SN_.
///              If a bit is not specified, then the corresponding action is not performed
///              and the name will retain the same bits as before calling this function.
///              For new names, default is: non-public, non-weak, non-auto.
/// \retval 1  ok, name is changed
/// \retval 0  failure, a warning is displayed

idaman bool ida_export set_name(ea_t ea,const char *name,int flag);

/// \defgroup SN_ Set name flags
/// Passed as 'flag' parameter to set_name(ea_t, const char *, int)
//@{
#define SN_CHECK        0x01    ///< Fail if the name contains invalid characters.
                                ///< If this bit is clear, all invalid chars
                                ///< (those !is_ident_char()) will be replaced
                                ///< by ::SubstChar (usually '_').
                                ///< List of valid characters is defined in ida.cfg
#define SN_NOCHECK      0x00    ///< Replace invalid chars with ::SubstChar
#define SN_PUBLIC       0x02    ///< if set, make name public
#define SN_NON_PUBLIC   0x04    ///< if set, make name non-public
#define SN_WEAK         0x08    ///< if set, make name weak
#define SN_NON_WEAK     0x10    ///< if set, make name non-weak
#define SN_AUTO         0x20    ///< if set, make name autogenerated
#define SN_NON_AUTO     0x40    ///< if set, make name non-autogenerated
#define SN_NOLIST       0x80    ///< if set, exclude name from the list.
                                ///< if not set, then include the name into
                                ///< the list (however, if other bits are set,
                                ///< the name might be immediately excluded
                                ///< from the list).
#define SN_NOWARN       0x100   ///< don't display a warning if failed
#define SN_LOCAL        0x200   ///< create local name. a function should exist.
                                ///< local names can't be public or weak.
                                ///< also they are not included into the list of names
                                ///< they can't have dummy prefixes.
//@}

/// Set or delete a name of an item at the specified address.
/// This function is shortcut for set_name(ea,name,#SN_CHECK);

inline bool set_name(ea_t ea,const char *name) // Giveth a name (and taketh it back)
{
  return set_name(ea,name, SN_CHECK);
}


/// \name Delete a name of a program item
/// \param ea  linear address
/// \retval 1  ok, name is deleted
/// \retval 0  failure, invalid address
//@{
inline bool del_global_name(ea_t ea) { return set_name(ea,"", SN_NOWARN); }
inline bool del_local_name(ea_t ea)  { return set_name(ea,"", SN_LOCAL|SN_NOWARN);}
//@}

/// Give an autogenerated (dummy) name.
/// Autogenerated names have special prefixes (loc_...).
/// \param from  linear address of the operand which references to the address
/// \param ea    linear address
/// \retval 1  ok, dummy name is generated or the byte already had a name
/// \retval 0  failure, invalid address or tail byte

idaman bool ida_export set_dummy_name(ea_t from, ea_t ea); // give dummy name


/// \name Set/Clear bit in flags for 'autogenerated but meaningful name'
/// This bit affects value of has_user_name(), has_auto_name() functions.
/// \param ea  linear address
/// \retval 1  ok
/// \retval 0  no meaningful name is present at the specified address
//@{
idaman bool ida_export make_name_auto(ea_t ea);
idaman bool ida_export make_name_user(ea_t ea);
//@}

/// Give a name anyway.
/// This function tries to give the specified name the specified address
/// and tries to modify the name with a postfix ("_00") if the name
/// already exists.
/// It will try 100 different postfixes and fail only if all such names
/// are already in use. For example, if the specified name is "xxx",
/// the function will try to give names "xxx","xxx_0","xxx_2",... "xxx_99".
/// \param ea      linear address
/// \param name    new name
///                  - NULL: return 0
///                  - ""  : return 0
/// \param maxlen  if specified, the name will be truncated to have the specified
///                maximum length
/// \return success

idaman bool ida_export do_name_anyway(ea_t ea, const char *name, size_t maxlen=0);


/// Validate a name.
/// This function replaces all invalid characters in the name with ::SubstChar.
/// However, it will return false if name is valid but not allowed to be an
/// identifier (is a register name).
/// \param[in,out] name  ptr to name. the name will be modified
/// \return success

idaman bool ida_export validate_name3(qstring *name);


/// Can a character appear in a name? (present in ::NameChars or ::MangleChars)

idaman bool ida_export is_ident_char(char c);


/// Can a character be displayed in a name? (present in ::NameChars)

idaman bool ida_export is_visible_char(char c);


/// Is a valid name? (including ::MangleChars)

idaman bool ida_export isident(const char *name);


/// Is valid user-specified name? (valid name & !dummy prefix).
/// \param name  name to test. may be NULL.
/// \retval 1  yes
/// \retval 0  no

idaman bool ida_export is_uname(const char *name);


/// Is valid type name?
/// \param name  name to test. may be NULL.
/// \retval 1  yes
/// \retval 0  no

idaman bool ida_export is_valid_typename(const char *name);


/// Is dummy name?
/// \param name  name to test. may be NULL.
/// \return #BADADDR if not, otherwise the address denoted by the name

idaman ea_t ida_export dummy_name_ea(const char *name);


/// Extract a name or address from the specified string.
/// \param[out] out  output buffer for the identifier
/// \param line      input string
/// \param x         x coordinate of cursor
/// \return -1 if can not extract. otherwise length of the name

idaman ssize_t ida_export extract_name2(qstring *out, const char *line, int x);


/// Remove name from the list of names
/// \param ea  address of the name

idaman void ida_export hide_name(ea_t ea);


/// Insert name to the list of names

idaman void ida_export show_name(ea_t ea);


/// Get address of the name.
/// Dummy names (like byte_xxxx where xxxx are hex digits) are parsed by this
/// function to obtain the address. The database is not consulted for them.
/// This function works only with regular names.
/// \param from  linear address where the name is used.
///              if not applicable, then should be #BADADDR.
/// \param name  any name in the program or NULL
/// \return address of the name or #BADADDR

idaman ea_t ida_export get_name_ea(ea_t from, const char *name);


/// Get address of the name used in the expression for the address
/// \param from  address of the operand which references to the address
/// \param to    the referenced address
/// \return address of the name used to represent the operand

idaman ea_t ida_export get_name_base_ea(ea_t from, ea_t to);


/// Get value of the name.
/// This function knows about: regular names, enums, special segments, etc.
/// \param from        linear address where the name is used
///                    if not applicable, then should be BADADDR
/// \param name        any name in the program or NULL
/// \param[out] value  pointer to variable with answer
/// \return \ref NT_

idaman int ida_export get_name_value(ea_t from,const char *name, uval_t *value);

/// \defgroup NT_ Name value result codes
/// Return values for get_name_value()
//@{
#define NT_NONE         0       ///< name doesn't exist or has no value
#define NT_BYTE         1       ///< name is byte name (regular name)
#define NT_LOCAL        2       ///< name is local label
#define NT_STKVAR       3       ///< name is stack variable name
#define NT_ENUM         4       ///< name is symbolic constant
#define NT_ABS          5       ///< name is absolute symbol (#SEG_ABSSYM)
#define NT_SEG          6       ///< name is segment or segment register name
#define NT_STROFF       7       ///< name is structure member
#define NT_BMASK        8       ///< name is a bit group mask name
#define NT_REGVAR       9       ///< name is a renamed register (*value is idx into pfn->regvars)
//@}


/// Additional information for get_ea_name() function
struct getname_info_t
{
  size_t cb;            ///< size of this struct
  int32 inhibitor;      ///< codes to inhibit parts of demangled name (see \ref MNG_).
                        ///< Usually this is one of \inf{short_demnames} or \inf{long_demnames}.
  int32 demform;        ///< demangle only if \inf{demnames} is equal to 'demform'.
  getname_info_t(void) : cb(sizeof(*this)) {}
};


/// Get name at the specified address.
/// \param[out] out  buffer to hold the name
/// \param ea        linear address
/// \param gtn_flags how exactly the name should be retrieved.
///                  combination of \ref GN_ bits
/// \param gtni      additional information for name demangling
/// Please use the convenience functions declared below instead of calling
/// get_ea_name directly.
/// \return success

idaman ssize_t ida_export get_ea_name(
        qstring *out,
        ea_t ea,
        int gtn_flags=0,
        const getname_info_t *gtni=NULL);

/// \defgroup GN_ bits for get_ea_name() function. There is a convenience
///           function calc_gtn_flags() to calculate the GN_LOCAL flag
//@{
#define GN_VISIBLE   0x0001 ///< replace forbidden characters by SubstChar
#define GN_COLORED   0x0002 ///< return colored name
#define GN_DEMANGLED 0x0004 ///< return demangled name
#define GN_STRICT    0x0008 ///< fail if can not demangle
#define GN_SHORT     0x0010 ///< use short form of demangled name
#define GN_LONG      0x0020 ///< use long form of demangled name
#define GN_LOCAL     0x0040 ///< try to get local name first; if failed, get global
#define GN_INSNLOC   0x0080 ///< if cmd.ea and ea are in the same func, set GN_LOCAL
//@}

inline ssize_t get_true_name(qstring *out, ea_t ea, int gtn_flags=0)
{
  return get_ea_name(out, ea, gtn_flags);
}

inline ssize_t idaapi get_visible_name(qstring *out, ea_t ea, int gtn_flags=0)
{
  return get_ea_name(out, ea, GN_VISIBLE|gtn_flags);
}

inline ssize_t idaapi get_colored_name(qstring *out, ea_t ea, int gtn_flags=0)
{
  return get_ea_name(out, ea, GN_VISIBLE|GN_COLORED|gtn_flags);
}

inline ssize_t idaapi get_short_name(qstring *out, ea_t ea, int gtn_flags=0)
{
  return get_ea_name(out, ea, GN_VISIBLE|GN_DEMANGLED|GN_SHORT|gtn_flags);
}

inline ssize_t idaapi get_long_name(qstring *out, ea_t ea, int gtn_flags=0)
{
  return get_ea_name(out, ea, GN_VISIBLE|GN_DEMANGLED|GN_LONG|gtn_flags);
}

inline ssize_t idaapi get_colored_short_name(qstring *out, ea_t ea, int gtn_flags=0)
{
  return get_ea_name(out, ea, GN_VISIBLE|GN_COLORED|GN_DEMANGLED|GN_SHORT|gtn_flags);
}

inline ssize_t idaapi get_colored_long_name(qstring *out, ea_t ea, int gtn_flags=0)
{
  return get_ea_name(out, ea, GN_VISIBLE|GN_COLORED|GN_DEMANGLED|GN_LONG|gtn_flags);
}

inline qstring get_true_name(ea_t ea, int gtn_flags=0)
{
  qstring out;
  get_ea_name(&out, ea, gtn_flags);
  return out;
}

inline qstring get_visible_name(ea_t ea, int gtn_flags=0)
{
  qstring out;
  get_ea_name(&out, ea, GN_VISIBLE|gtn_flags);
  return out;
}

inline qstring idaapi get_colored_name(ea_t ea, int gtn_flags=0)
{
  qstring out;
  get_ea_name(&out, ea, GN_VISIBLE|GN_COLORED|gtn_flags);
  return out;
}

inline qstring idaapi get_short_name(ea_t ea, int gtn_flags=0)
{
  qstring out;
  get_ea_name(&out, ea, GN_VISIBLE|GN_DEMANGLED|GN_SHORT|gtn_flags);
  return out;
}

inline qstring idaapi get_long_name(ea_t ea, int gtn_flags=0)
{
  qstring out;
  get_ea_name(&out, ea, GN_VISIBLE|GN_DEMANGLED|GN_LONG|gtn_flags);
  return out;
}

inline ssize_t idaapi get_demangled_name(
        qstring *out,
        ea_t ea,
        int32 inhibitor,
        int demform,
        int gtn_flags=0)
{
  getname_info_t gtni;
  gtni.inhibitor = inhibitor;
  gtni.demform = demform;
  gtn_flags |= GN_VISIBLE | GN_DEMANGLED;
  return get_ea_name(out, ea, gtn_flags, &gtni);
}

inline ssize_t idaapi get_colored_demangled_name(
        qstring *out,
        ea_t ea,
        int32 inhibitor,
        int demform,
        int gtn_flags=0)
{
  return get_demangled_name(out, ea, inhibitor, demform, gtn_flags|GN_COLORED);
}


/// Calculate flags for get_ea_name() function
#ifdef FUNCS_HPP
inline int calc_gtn_flags(ea_t from, ea_t ea)
{
  return func_contains(get_func(from), ea) ? GN_LOCAL : 0;
}
#endif

/// Get name color.
/// \param from  linear address where the name is used.
///              if not applicable, then should be #BADADDR.
///              The kernel returns a local name color if the reference is
///              within a function, i.e. 'from' and 'ea' belong to the same function.
/// \param ea    linear address

idaman color_t ida_export get_name_color(ea_t from, ea_t ea);


/// \defgroup GETN_ Name expression flags
/// Passed as 'flags' parameter to get_name_expr()
//@{
#define GETN_APPZERO  0x0001  ///< meaningful only if the name refers to a structure.
                              ///< append a struct field name if the field offset is zero?
#define GETN_NOFIXUP  0x0002  ///< ignore the fixup information when producing the name
#define GETN_NODUMMY  0x0004  ///< do not create a new dummy name but pretend it exists
//@}

/// Convert address to name expression (name with a displacement).
/// This function takes into account fixup information and returns
/// a colored name expression (in the form  <name> +/- <offset>).
/// It also knows about structure members and arrays.
/// If the specified address doesn't have a name, a dummy name is generated.
/// \param from       linear address of instruction operand or data referring to
///                   the name. This address will be used to get fixup information,
///                   so it should point to exact position of the operand in the
///                   instruction.
/// \param n          number of referencing operand. for data items specify 0
/// \param ea         address to convert to name expression
/// \param off        the value of name expression. this parameter is used only to
///                   check that the name expression will have the wanted value.
///                   'off' may be equal to BADADDR but this is discouraged
///                   because it prohibits checks.
/// \param[out] buf   buffer for the name
/// \param bufsize    size of the output buffer
/// \param flags      \ref GETN_
/// \return < 0 if address is not valid, no segment or other failure.
///          otherwise the length of the name expression in characters.

idaman ssize_t ida_export get_name_expr(
        ea_t from,
        int n,
        ea_t ea,
        uval_t off,
        char *buf,
        size_t bufsize,
        int flags=GETN_APPZERO);

/// Get a nice colored name at the specified address.
/// Ex:
///   - segment:sub+offset
///   - segment:sub:local_label
///   - segment:label
///   - segment:address
///   - segment:address+offset
/// \param ea        linear address
/// \param[out] buf  buffer to hold the name
/// \param bufsize   size of the output buffer
/// \param flags     \ref GNCN_
/// \return the length of the generated name in bytes.

idaman ssize_t ida_export get_nice_colored_name(
        ea_t ea,
        char *buf,
        size_t bufsize,
        int flags=0);

/// \defgroup GNCN_ Nice colored name flags
/// Passed as 'flags' parameter to get_nice_colored_name()
//@{
#define GNCN_NOSEG    0x0001 ///< ignore the segment prefix when producing the name
#define GNCN_NOCOLOR  0x0002 ///< generate an uncolored name
#define GNCN_NOLABEL  0x0004 ///< don't generate labels
#define GNCN_NOFUNC   0x0008 ///< don't generate funcname+... expressions
#define GNCN_SEG_FUNC 0x0010 ///< generate both segment and function names (default is to omit segment name if a function name is present)
#define GNCN_SEGNUM   0x0020 ///< segment part is displayed as a hex number
#define GNCN_REQFUNC  0x0040 ///< return 0 if the address does not belong to a function
#define GNCN_REQNAME  0x0080 ///< return 0 if the address can only be represented as a hex number
#define GNCN_NODBGNM  0x0100 ///< don't use debug names
//@}


/// Append names of struct fields to a name if the name is a struct name.
/// \param out      pointer to the output buffer
/// \param n        number of operand n which the name appears
/// \param path     path in the struct. path is an array of id's.
///                 maximal length of array is #MAXSTRUCPATH.
///                 the first element of the array is the structure id.
///                 consecutive elements are id's of used union members (if any).
/// \param plen     size of path array
/// \param flags    the input flags. they will be returned if the struct
///                 cannot be found.
/// \param disp     displacement from the name
/// \param delta    delta to add to displacement
/// \param appzero  should append a struct field name if the displacement is zero?
/// \return flags of the innermost struct member or the input flags

idaman flags_t ida_export append_struct_fields2(
        qstring *out,
        int n,
        const tid_t *path,
        int plen,
        flags_t flags,
        adiff_t *disp,
        adiff_t delta,
        bool appzero);


/// Get offset within a structure if the operand refers to structure.
/// Ex:
///   \v{mov ax, somedata.field5-2 (before it was max ax, 3)}
/// for this instruction, op #1 the function will return
///   - disp: the value of 'field5', i.e. 5
///   - delta: -2
///   - path: the existing path if any
/// \param ea     linear address of instruction/data
/// \param n      number of operand
/// \param path   existing strpath (if any)
/// \param disp   pointer to displacement (answer will be here)
/// \param delta  pointer to displacement delta (answer will be here)
/// \return if success, then length of path + 1.
///          if failed, then 0.

idaman int ida_export get_struct_operand(
        ea_t ea,
        int n,
        tid_t *path,
        adiff_t *disp,
        adiff_t *delta);


/// \name Work with publicness of a name
//@{
idaman bool ida_export is_public_name(ea_t ea);
idaman void ida_export make_name_public(ea_t ea);
idaman void ida_export make_name_non_public(ea_t ea);
//@}


/// Generate declaration of publicness/weakness of a name if necessary.
/// \param ea    address of the name
/// \param name  colored name. If name==NULL then is will be retrieved
///              from the database.
/// \retval 0  declaration is generated
/// \retval 1  overflow of the line buffer occurred during declaration
/// \retval 2  nothing is done: name is not public

idaman int ida_export gen_name_decl(ea_t ea,const char *name);


/// \name Work with weak names.
//@{
idaman bool ida_export is_weak_name(ea_t ea);
idaman void ida_export make_name_weak(ea_t ea);
idaman void ida_export make_name_non_weak(ea_t ea);
//@}

/// \name Work with the list of names
//@{

/// Get number of names in the list

idaman size_t ida_export get_nlist_size(void);

/// Get index of the name in the list
/// \warning returns the closest match.
///         may return idx >= size.

idaman size_t ida_export get_nlist_idx(ea_t ea);

/// Is name included into names list?

idaman bool ida_export is_in_nlist(ea_t ea);

/// Get address from the list at 'idx'

idaman ea_t ida_export get_nlist_ea(size_t idx);

/// Get name using idx

idaman const char *ida_export get_nlist_name(size_t idx);

/// Rebuild names list

idaman void ida_export rebuild_nlist(void);
//@}

/// Renumber dummy names

idaman void ida_export reorder_dummy_names(void);

/// Specify strategy for retrieving debug names
enum debug_name_how_t
{
  DEBNAME_EXACT,        ///< find a name at exactly the specified address
  DEBNAME_LOWER,        ///< find a name with the address >= the specified address
  DEBNAME_UPPER,        ///< find a name with the address >  the specified address
  DEBNAME_NICE,         ///< find a name with the address <= the specified address
};

/// ea, name pair
struct ea_name_t
{
  ea_t ea;
  qstring name;
  ea_name_t(void) {}
  ea_name_t(ea_t _ea, const qstring &_name) : ea(_ea), name(_name) {}
};
DECLARE_TYPE_AS_MOVABLE(ea_name_t);
typedef qvector<ea_name_t> ea_name_vec_t; ///< vector of ea,name pairs

/// \name Debug names
/// Debug names exist during the debugging session.
/// The kernel does not verify them for anything and happily accepts
/// any string as a name.
//@{
idaman int  ida_export set_debug_names(const ea_t *addrs, const char *const *names, int qty);
idaman bool ida_export set_debug_name(ea_t ea, const char *name);
idaman ssize_t ida_export get_debug_name2(
        qstring *out,
        ea_t *ea_ptr,
        debug_name_how_t how);
idaman void ida_export del_debug_names(ea_t ea1, ea_t ea2);
idaman ea_t ida_export get_debug_name_ea(const char *name);
idaman void ida_export get_debug_names(ea_t ea1, ea_t ea2, ea_name_vec_t &names);
//@}

/// Array of valid identifier characters.
/// The kernel doesn't allow digits as first character of a name anyway.
/// This array is initialized with information from ida.cfg.
/// If it is empty, then all characters are allowed.
/// The following characters are allowed in user-defined names:
idaman ida_export_data char NameChars[256];


/// The following characters are allowed in mangled names.
/// they will be substituted with the SubstChar during output.
idaman ida_export_data char MangleChars[256];


enum demreq_type_t
{
  DQT_NPURGED_8 = -8, // only calculate number of purged bytes (sizeof(arg)==8)
  DQT_NPURGED_4 = -4, // only calculate number of purged bytes (sizeof(arg)==4)
  DQT_NPURGED_2 = -2, // only calculate number of purged bytes (sizeof(arg)==2)
  DQT_COMPILER  = 0,  // only detect compiler that generated the name
  DQT_NAME_TYPE = 1,  // only detect the name type (data/code)
  DQT_FULL      = 2,  // really demangle
};

/// Demangle a name.
/// \param out   output buffer
/// \param name  name to demangle
/// \param disable_mask bits to inhibit parts of demangled name (see \ref MNG_).
/// \return ME_... or MT__ bitmasks from demangle.hpp

idaman int32 ida_export demangle_name2(
        qstring *out,
        const char *name,
        uint32 disable_mask,
        demreq_type_t demreq=DQT_FULL);


inline int32 detect_compiler_using_demangler(const char *name)
{
  return demangle_name2(NULL, name, 0, DQT_COMPILER);
}

/// What name types to ignore
typedef int ignore_name_def_t;
const ignore_name_def_t
  ignore_none   = 0,
  ignore_regvar = 1,
  ignore_llabel = 2,
  ignore_stkvar = 3,
  ignore_glabel = 4;

/// Is the name defined locally in the specified function?
/// \param pfn    pointer to function
/// \param name   name to check
/// \param ignore which names to ignore when checking
/// \param ea1    the starting address of the range inside the function (optional)
/// \param ea2    the ending address of the range inside the function (optional)
/// \return true if the name has been defined
idaman bool ida_export is_name_defined_locally(
        func_t *pfn,
        const char *name,
        ignore_name_def_t ignore,
        ea_t ea1=BADADDR,
        ea_t ea2=BADADDR);



#ifndef NO_OBSOLETE_FUNCS
idaman DEPRECATED char *ida_export validate_name(char *name); // use validate_name3()
idaman DEPRECATED char *ida_export validate_name2(char *name, size_t bufsize);
idaman DEPRECATED char *ida_export get_true_name(ea_t from, ea_t ea, char *buf, size_t bufsize);
idaman DEPRECATED char *ida_export get_name(ea_t from, ea_t ea, char *buf, size_t bufsize);
idaman DEPRECATED char *ida_export get_colored_name(ea_t from, ea_t ea, char *buf, size_t bufsize);
idaman DEPRECATED int32 ida_export demangle_name(char *buf, size_t bufsize, const char *name, uint32 disable_mask);
idaman DEPRECATED bool ida_export get_debug_name(ea_t *ea_ptr, debug_name_how_t how, char *buf, size_t bufsize);
idaman DEPRECATED char *ida_export make_visible_name(char *dstname, const char *srcname, size_t dstsize);
idaman DEPRECATED char *ida_export extract_name(const char *line, int x, char *buf, size_t bufsize);
idaman DEPRECATED flags_t ida_export append_struct_fields(int n, const tid_t *path, int plen, flags_t flags, char *ptr, char *end, adiff_t *disp, adiff_t delta, bool appzero);
idaman DEPRECATED char *ida_export get_demangled_name(ea_t from, ea_t ea, char *buf, size_t bufsize, int32 inhibitor, int demform, bool strict);
idaman DEPRECATED char *ida_export get_colored_demangled_name(ea_t from, ea_t ea, char *buf, size_t bufsize, int32 inhibitor, int demform, bool strict);
#endif

#pragma pack(pop)
#endif // _NAME_HPP
